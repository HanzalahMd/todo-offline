{"ast":null,"code":"'use strict';\n\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\n\nvar clone = _interopDefault(require('clone'));\n\nvar equal = _interopDefault(require('deep-equal'));\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar isObject = function isObject(variableToCheck) {\n  return (typeof variableToCheck === \"undefined\" ? \"undefined\" : _typeof(variableToCheck)) === \"object\" && variableToCheck !== null;\n};\n\nvar every = function every(arrayToIterate, cb) {\n  return arrayToIterate.every(function (elem) {\n    return cb && cb(elem) || elem;\n  });\n};\n\nvar has = function has(objectWithKeys, key) {\n  return objectWithKeys.hasOwnProperty(key);\n};\n\nvar keys = function keys(objectWithKeys) {\n  return Object.keys(objectWithKeys);\n};\n\nvar each = function each(objectToIterate, cb) {\n  Object.keys(objectToIterate).forEach(function (key) {\n    cb(objectToIterate[key], key);\n  });\n};\n\nvar libIsArray = function libIsArray(variableToCheck) {\n  return Array.isArray(variableToCheck);\n};\n\nvar isBinary = function isBinary(variableToCheck) {\n  return !!(typeof Uint8Array !== 'undefined' && variableToCheck instanceof Uint8Array || variableToCheck && variableToCheck.$Uint8ArrayPolyfill);\n};\n\nvar _$1 = {\n  isArray: libIsArray,\n  each: each\n}; // Like _.isArray, but doesn't regard polyfilled Uint8Arrays on old browsers as\n// arrays.\n// XXX maybe this should be EJSON.isArray\n\nvar isArray = function isArray(x) {\n  return _$1.isArray(x) && !isBinary(x);\n};\n\nvar isIndexable = function isIndexable(x) {\n  return isArray(x) || isPlainObject(x);\n}; // Returns true if this is an object with at least one key and all keys begin\n// with $.  Unless inconsistentOK is set, throws if some keys begin with $ and\n// others don't.\n\n\nvar isOperatorObject = function isOperatorObject(valueSelector, inconsistentOK) {\n  if (!isPlainObject(valueSelector)) return false;\n  var theseAreOperators = undefined;\n\n  _$1.each(valueSelector, function (value, selKey) {\n    var thisIsOperator = selKey.substr(0, 1) === '$';\n\n    if (theseAreOperators === undefined) {\n      theseAreOperators = thisIsOperator;\n    } else if (theseAreOperators !== thisIsOperator) {\n      if (!inconsistentOK) throw new Error(\"Inconsistent operator: \" + JSON.stringify(valueSelector));\n      theseAreOperators = false;\n    }\n  });\n\n  return !!theseAreOperators; // {} has no operators\n}; // string can be converted to integer\n\n\nvar isNumericKey = function isNumericKey(s) {\n  return /^[0-9]+$/.test(s);\n};\n\nvar isPlainObject = function isPlainObject(variableToCheck) {\n  if (!variableToCheck) return false;\n  if (typeof variableToCheck === \"number\") return false;\n  if (typeof variableToCheck === \"string\") return false;\n  if (typeof variableToCheck === \"boolean\") return false;\n  if (isArray(variableToCheck)) return false;\n  if (variableToCheck === null) return false;\n  if (variableToCheck instanceof RegExp) // note that typeof(/x/) === \"object\"\n    return false;\n  if (typeof variableToCheck === \"function\") return false;\n  if (variableToCheck instanceof Date) return false;\n  if (isBinary(variableToCheck)) return false;\n  return true; // object\n};\n\nvar ModifyJsError = function ModifyJsError(message) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (typeof message === \"string\" && options.field) {\n    message += \" for field '\" + options.field + \"'\";\n  }\n\n  var e = new Error(message);\n  e.name = \"ModifyJsError\";\n  return e;\n};\n\nvar _ = {\n  all: every,\n  each: each,\n  keys: keys,\n  has: has,\n  isObject: isObject\n}; // XXX need a strategy for passing the binding of $ into this\n// function, from the compiled selector\n//\n// maybe just {key.up.to.just.before.dollarsign: array_index}\n//\n// XXX atomicity: if one modification fails, do we roll back the whole\n// change?\n//\n// options:\n//   - isInsert is set when _modify is being called to compute the document to\n//     insert as part of an upsert operation. We use this primarily to figure\n//     out when to set the fields in $setOnInsert, if present.\n\nvar modify = function modify(doc, mod, options) {\n  if (options && options.each) {\n    return;\n  }\n\n  return _modify(doc, mod, _extends({}, options, {\n    returnInsteadOfReplacing: true\n  }));\n};\n\nvar _modify = function _modify(doc, mod, options) {\n  options = options || {};\n  if (!isPlainObject(mod)) throw ModifyJsError(\"Modifier must be an object\"); // Make sure the caller can't mutate our data structures.\n\n  mod = clone(mod);\n  var isModifier = isOperatorObject(mod);\n  var newDoc;\n\n  if (!isModifier) {\n    // replace the whole document\n    newDoc = mod;\n  } else {\n    // apply modifiers to the doc.\n    newDoc = clone(doc);\n\n    _.each(mod, function (operand, op) {\n      var modFunc = MODIFIERS[op]; // Treat $setOnInsert as $set if this is an insert.\n\n      if (!modFunc) throw ModifyJsError(\"Invalid modifier specified \" + op);\n\n      _.each(operand, function (arg, keypath) {\n        if (keypath === '') {\n          throw ModifyJsError(\"An empty update path is not valid.\");\n        }\n\n        var keyparts = keypath.split('.');\n\n        if (!_.all(keyparts)) {\n          throw ModifyJsError(\"The update path '\" + keypath + \"' contains an empty field name, which is not allowed.\");\n        }\n\n        var target = findModTarget(newDoc, keyparts, {\n          noCreate: NO_CREATE_MODIFIERS[op],\n          forbidArray: op === \"$rename\",\n          arrayIndices: options.arrayIndices\n        });\n        var field = keyparts.pop();\n        modFunc(target, field, arg, keypath, newDoc);\n      });\n    });\n  }\n\n  if (options.returnInsteadOfReplacing) {\n    return newDoc;\n  } else {\n    // move new document into place.\n    _.each(_.keys(doc), function (k) {\n      // Note: this used to be for (var k in doc) however, this does not\n      // work right in Opera. Deleting from a doc while iterating over it\n      // would sometimes cause opera to skip some keys.\n      if (k !== '_id') delete doc[k];\n    });\n\n    _.each(newDoc, function (v, k) {\n      doc[k] = v;\n    });\n  }\n}; // for a.b.c.2.d.e, keyparts should be ['a', 'b', 'c', '2', 'd', 'e'],\n// and then you would operate on the 'e' property of the returned\n// object.\n//\n// if options.noCreate is falsey, creates intermediate levels of\n// structure as necessary, like mkdir -p (and raises an exception if\n// that would mean giving a non-numeric property to an array.) if\n// options.noCreate is true, return undefined instead.\n//\n// may modify the last element of keyparts to signal to the caller that it needs\n// to use a different value to index into the returned object (for example,\n// ['a', '01'] -> ['a', 1]).\n//\n// if forbidArray is true, return null if the keypath goes through an array.\n//\n// if options.arrayIndices is set, use its first element for the (first) '$' in\n// the path.\n\n\nvar findModTarget = function findModTarget(doc, keyparts, options) {\n  options = options || {};\n  var usedArrayIndex = false;\n\n  for (var i = 0; i < keyparts.length; i++) {\n    var last = i === keyparts.length - 1;\n    var keypart = keyparts[i];\n    var indexable = isIndexable(doc);\n\n    if (!indexable) {\n      if (options.noCreate) return undefined;\n      var e = ModifyJsError(\"cannot use the part '\" + keypart + \"' to traverse \" + doc);\n      e.setPropertyError = true;\n      throw e;\n    }\n\n    if (doc instanceof Array) {\n      if (options.forbidArray) return null;\n\n      if (keypart === '$') {\n        if (usedArrayIndex) throw ModifyJsError(\"Too many positional (i.e. '$') elements\");\n\n        if (!options.arrayIndices || !options.arrayIndices.length) {\n          throw ModifyJsError(\"The positional operator did not find the \" + \"match needed from the query\");\n        }\n\n        keypart = options.arrayIndices[0];\n        usedArrayIndex = true;\n      } else if (isNumericKey(keypart)) {\n        keypart = parseInt(keypart);\n      } else {\n        if (options.noCreate) return undefined;\n        throw ModifyJsError(\"can't append to array using string field name [\" + keypart + \"]\");\n      }\n\n      if (last) // handle 'a.01'\n        keyparts[i] = keypart;\n      if (options.noCreate && keypart >= doc.length) return undefined;\n\n      while (doc.length < keypart) {\n        doc.push(null);\n      }\n\n      if (!last) {\n        if (doc.length === keypart) doc.push({});else if (_typeof(doc[keypart]) !== \"object\") throw ModifyJsError(\"can't modify field '\" + keyparts[i + 1] + \"' of list value \" + JSON.stringify(doc[keypart]));\n      }\n    } else {\n      if (!(keypart in doc)) {\n        if (options.noCreate) return undefined;\n        if (!last) doc[keypart] = {};\n      }\n    }\n\n    if (last) return doc;\n    doc = doc[keypart];\n  }\n};\n\nvar NO_CREATE_MODIFIERS = {\n  $unset: true,\n  $pop: true,\n  $rename: true,\n  $pull: true,\n  $pullAll: true\n};\nvar MODIFIERS = {\n  $currentDate: function $currentDate(target, field, arg) {\n    if ((typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === \"object\" && arg.hasOwnProperty(\"$type\")) {\n      if (arg.$type !== \"date\") {\n        throw ModifyJsError(\"Minimongo does currently only support the date type \" + \"in $currentDate modifiers\", {\n          field: field\n        });\n      }\n    } else if (arg !== true) {\n      throw ModifyJsError(\"Invalid $currentDate modifier\", {\n        field: field\n      });\n    }\n\n    target[field] = new Date();\n  },\n  $min: function $min(target, field, arg) {\n    if (typeof arg !== \"number\") {\n      throw ModifyJsError(\"Modifier $min allowed for numbers only\", {\n        field: field\n      });\n    }\n\n    if (field in target) {\n      if (typeof target[field] !== \"number\") {\n        throw ModifyJsError(\"Cannot apply $min modifier to non-number\", {\n          field: field\n        });\n      }\n\n      if (target[field] > arg) {\n        target[field] = arg;\n      }\n    } else {\n      target[field] = arg;\n    }\n  },\n  $max: function $max(target, field, arg) {\n    if (typeof arg !== \"number\") {\n      throw ModifyJsError(\"Modifier $max allowed for numbers only\", {\n        field: field\n      });\n    }\n\n    if (field in target) {\n      if (typeof target[field] !== \"number\") {\n        throw ModifyJsError(\"Cannot apply $max modifier to non-number\", {\n          field: field\n        });\n      }\n\n      if (target[field] < arg) {\n        target[field] = arg;\n      }\n    } else {\n      target[field] = arg;\n    }\n  },\n  $inc: function $inc(target, field, arg) {\n    if (typeof arg !== \"number\") throw ModifyJsError(\"Modifier $inc allowed for numbers only\", {\n      field: field\n    });\n\n    if (field in target) {\n      if (typeof target[field] !== \"number\") throw ModifyJsError(\"Cannot apply $inc modifier to non-number\", {\n        field: field\n      });\n      target[field] += arg;\n    } else {\n      target[field] = arg;\n    }\n  },\n  $set: function $set(target, field, arg) {\n    if (!_.isObject(target)) {\n      // not an array or an object\n      var e = ModifyJsError(\"Cannot set property on non-object field\", {\n        field: field\n      });\n      e.setPropertyError = true;\n      throw e;\n    }\n\n    if (target === null) {\n      var e = ModifyJsError(\"Cannot set property on null\", {\n        field: field\n      });\n      e.setPropertyError = true;\n      throw e;\n    }\n\n    target[field] = arg;\n  },\n  $setOnInsert: function $setOnInsert(target, field, arg) {// converted to `$set` in `_modify`\n  },\n  $unset: function $unset(target, field, arg) {\n    if (target !== undefined) {\n      if (target instanceof Array) {\n        if (field in target) target[field] = null;\n      } else delete target[field];\n    }\n  },\n  $push: function $push(target, field, arg) {\n    if (target[field] === undefined) target[field] = [];\n    if (!(target[field] instanceof Array)) throw ModifyJsError(\"Cannot apply $push modifier to non-array\", {\n      field: field\n    });\n\n    if (!(arg && arg.$each)) {\n      // Simple mode: not $each\n      target[field].push(arg);\n      return;\n    } // Fancy mode: $each (and maybe $slice and $sort and $position)\n\n\n    var toPush = arg.$each;\n    if (!(toPush instanceof Array)) throw ModifyJsError(\"$each must be an array\", {\n      field: field\n    }); // Parse $position\n\n    var position = undefined;\n\n    if ('$position' in arg) {\n      if (typeof arg.$position !== \"number\") throw ModifyJsError(\"$position must be a numeric value\", {\n        field: field\n      }); // XXX should check to make sure integer\n\n      if (arg.$position < 0) throw ModifyJsError(\"$position in $push must be zero or positive\", {\n        field: field\n      });\n      position = arg.$position;\n    } // Parse $slice.\n\n\n    var slice = undefined;\n\n    if ('$slice' in arg) {\n      if (typeof arg.$slice !== \"number\") throw ModifyJsError(\"$slice must be a numeric value\", {\n        field: field\n      }); // XXX should check to make sure integer\n\n      if (arg.$slice > 0) throw ModifyJsError(\"$slice in $push must be zero or negative\", {\n        field: field\n      });\n      slice = arg.$slice;\n    } // Parse $sort.\n\n\n    var sortFunction = undefined;\n\n    if (arg.$sort) {\n      throw ModifyJsError(\"$sort in $push not implemented yet\"); // if (slice === undefined)\n      //   throw ModifyJsError(\"$sort requires $slice to be present\", { field });\n      // // XXX this allows us to use a $sort whose value is an array, but that's\n      // // actually an extension of the Node driver, so it won't work\n      // // server-side. Could be confusing!\n      // // XXX is it correct that we don't do geo-stuff here?\n      // sortFunction = new Minimongo.Sorter(arg.$sort).getComparator();\n      // for (var i = 0; i < toPush.length; i++) {\n      //   if (_f._type(toPush[i]) !== 3) {\n      //     throw ModifyJsError(\"$push like modifiers using $sort \" +\n      //                 \"require all elements to be objects\", { field });\n      //   }\n      // }\n    } // Actually push.\n\n\n    if (position === undefined) {\n      for (var j = 0; j < toPush.length; j++) {\n        target[field].push(toPush[j]);\n      }\n    } else {\n      var spliceArguments = [position, 0];\n\n      for (var j = 0; j < toPush.length; j++) {\n        spliceArguments.push(toPush[j]);\n      }\n\n      Array.prototype.splice.apply(target[field], spliceArguments);\n    } // Actually sort.\n\n\n    if (sortFunction) target[field].sort(sortFunction); // Actually slice.\n\n    if (slice !== undefined) {\n      if (slice === 0) target[field] = []; // differs from Array.slice!\n      else target[field] = target[field].slice(slice);\n    }\n  },\n  $pushAll: function $pushAll(target, field, arg) {\n    if (!((typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === \"object\" && arg instanceof Array)) throw ModifyJsError(\"Modifier $pushAll/pullAll allowed for arrays only\");\n    var x = target[field];\n    if (x === undefined) target[field] = arg;else if (!(x instanceof Array)) throw ModifyJsError(\"Cannot apply $pushAll modifier to non-array\", {\n      field: field\n    });else {\n      for (var i = 0; i < arg.length; i++) {\n        x.push(arg[i]);\n      }\n    }\n  },\n  $addToSet: function $addToSet(target, field, arg) {\n    var isEach = false;\n\n    if ((typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === \"object\") {\n      //check if first key is '$each'\n      var _keys = Object.keys(arg);\n\n      if (_keys[0] === \"$each\") {\n        isEach = true;\n      }\n    }\n\n    var values = isEach ? arg[\"$each\"] : [arg];\n    var x = target[field];\n    if (x === undefined) target[field] = values;else if (!(x instanceof Array)) throw ModifyJsError(\"Cannot apply $addToSet modifier to non-array\", {\n      field: field\n    });else {\n      _.each(values, function (value) {\n        for (var i = 0; i < x.length; i++) {\n          if (equal(value, x[i])) return;\n        }\n\n        x.push(value);\n      });\n    }\n  },\n  $pop: function $pop(target, field, arg) {\n    if (target === undefined) return;\n    var x = target[field];\n    if (x === undefined) return;else if (!(x instanceof Array)) throw ModifyJsError(\"Cannot apply $pop modifier to non-array\", {\n      field: field\n    });else {\n      if (typeof arg === 'number' && arg < 0) x.splice(0, 1);else x.pop();\n    }\n  },\n  $pull: function $pull(target, field, arg) {\n    if (target === undefined) return;\n    var x = target[field];\n    if (x === undefined) return;else if (!(x instanceof Array)) throw ModifyJsError(\"Cannot apply $pull/pullAll modifier to non-array\", {\n      field: field\n    });else {\n      throw ModifyJsError(\"$pull not implemented yet\"); // var out = [];\n      // if (arg != null && typeof arg === \"object\" && !(arg instanceof Array)) {\n      //   // XXX would be much nicer to compile this once, rather than\n      //   // for each document we modify.. but usually we're not\n      //   // modifying that many documents, so we'll let it slide for\n      //   // now\n      //\n      //   // XXX Minimongo.Matcher isn't up for the job, because we need\n      //   // to permit stuff like {$pull: {a: {$gt: 4}}}.. something\n      //   // like {$gt: 4} is not normally a complete selector.\n      //   // same issue as $elemMatch possibly?\n      //   var matcher = new Minimongo.Matcher(arg);\n      //   for (var i = 0; i < x.length; i++)\n      //     if (!matcher.documentMatches(x[i]).result)\n      //       out.push(x[i]);\n      // } else {\n      //   for (var i = 0; i < x.length; i++)\n      //     if (!_f._equal(x[i], arg))\n      //       out.push(x[i]);\n      // }\n      // target[field] = out;\n    }\n  },\n  $pullAll: function $pullAll(target, field, arg) {\n    if (!((typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === \"object\" && arg instanceof Array)) throw ModifyJsError(\"Modifier $pushAll/pullAll allowed for arrays only\", {\n      field: field\n    });\n    if (target === undefined) return;\n    var x = target[field];\n    if (x === undefined) return;else if (!(x instanceof Array)) throw ModifyJsError(\"Cannot apply $pull/pullAll modifier to non-array\", {\n      field: field\n    });else {\n      var out = [];\n\n      for (var i = 0; i < x.length; i++) {\n        var exclude = false;\n\n        for (var j = 0; j < arg.length; j++) {\n          if (equal(x[i], arg[j])) {\n            exclude = true;\n            break;\n          }\n        }\n\n        if (!exclude) out.push(x[i]);\n      }\n\n      target[field] = out;\n    }\n  },\n  $rename: function $rename(target, field, arg, keypath, doc) {\n    if (keypath === arg) // no idea why mongo has this restriction..\n      throw ModifyJsError(\"$rename source must differ from target\", {\n        field: field\n      });\n    if (target === null) throw ModifyJsError(\"$rename source field invalid\", {\n      field: field\n    });\n    if (typeof arg !== \"string\") throw ModifyJsError(\"$rename target must be a string\", {\n      field: field\n    });\n\n    if (arg.indexOf('\\0') > -1) {\n      // Null bytes are not allowed in Mongo field names\n      // https://docs.mongodb.com/manual/reference/limits/#Restrictions-on-Field-Names\n      throw ModifyJsError(\"The 'to' field for $rename cannot contain an embedded null byte\", {\n        field: field\n      });\n    }\n\n    if (target === undefined) return;\n    var v = target[field];\n    delete target[field];\n    var keyparts = arg.split('.');\n    var target2 = findModTarget(doc, keyparts, {\n      forbidArray: true\n    });\n    if (target2 === null) throw ModifyJsError(\"$rename target field invalid\", {\n      field: field\n    });\n    var field2 = keyparts.pop();\n    target2[field2] = v;\n  },\n  $bit: function $bit(target, field, arg) {\n    // XXX mongo only supports $bit on integers, and we only support\n    // native javascript numbers (doubles) so far, so we can't support $bit\n    throw ModifyJsError(\"$bit is not supported\", {\n      field: field\n    });\n  }\n};\nmodule.exports = modify;","map":{"version":3,"sources":["/Users/Hanzalah/Desktop/github/todo-offline/rxdb-hasura-demo/node_modules/modifyjs/dist/bundle.js"],"names":["_interopDefault","ex","clone","require","equal","_typeof","Symbol","iterator","obj","constructor","prototype","_extends","Object","assign","target","i","arguments","length","source","key","hasOwnProperty","call","isObject","variableToCheck","every","arrayToIterate","cb","elem","has","objectWithKeys","keys","each","objectToIterate","forEach","libIsArray","Array","isArray","isBinary","Uint8Array","$Uint8ArrayPolyfill","_$1","x","isIndexable","isPlainObject","isOperatorObject","valueSelector","inconsistentOK","theseAreOperators","undefined","value","selKey","thisIsOperator","substr","Error","JSON","stringify","isNumericKey","s","test","RegExp","Date","ModifyJsError","message","options","field","e","name","_","all","modify","doc","mod","_modify","returnInsteadOfReplacing","isModifier","newDoc","operand","op","modFunc","MODIFIERS","arg","keypath","keyparts","split","findModTarget","noCreate","NO_CREATE_MODIFIERS","forbidArray","arrayIndices","pop","k","v","usedArrayIndex","last","keypart","indexable","setPropertyError","parseInt","push","$unset","$pop","$rename","$pull","$pullAll","$currentDate","$type","$min","$max","$inc","$set","$setOnInsert","$push","$each","toPush","position","$position","slice","$slice","sortFunction","$sort","j","spliceArguments","splice","apply","sort","$pushAll","$addToSet","isEach","_keys","values","out","exclude","indexOf","target2","field2","$bit","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar clone = _interopDefault(require('clone'));\nvar equal = _interopDefault(require('deep-equal'));\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar isObject = (function (variableToCheck) {\n  return (typeof variableToCheck === \"undefined\" ? \"undefined\" : _typeof(variableToCheck)) === \"object\" && variableToCheck !== null;\n});\n\nvar every = (function (arrayToIterate, cb) {\n  return arrayToIterate.every(function (elem) {\n    return cb && cb(elem) || elem;\n  });\n});\n\nvar has = (function (objectWithKeys, key) {\n  return objectWithKeys.hasOwnProperty(key);\n});\n\nvar keys = (function (objectWithKeys) {\n  return Object.keys(objectWithKeys);\n});\n\nvar each = (function (objectToIterate, cb) {\n  Object.keys(objectToIterate).forEach(function (key) {\n    cb(objectToIterate[key], key);\n  });\n});\n\nvar libIsArray = (function (variableToCheck) {\n  return Array.isArray(variableToCheck);\n});\n\nvar isBinary = (function (variableToCheck) {\n  return !!(typeof Uint8Array !== 'undefined' && variableToCheck instanceof Uint8Array || variableToCheck && variableToCheck.$Uint8ArrayPolyfill);\n});\n\nvar _$1 = { isArray: libIsArray, each: each };\n// Like _.isArray, but doesn't regard polyfilled Uint8Arrays on old browsers as\n// arrays.\n// XXX maybe this should be EJSON.isArray\nvar isArray = function isArray(x) {\n  return _$1.isArray(x) && !isBinary(x);\n};\n\nvar isIndexable = function isIndexable(x) {\n  return isArray(x) || isPlainObject(x);\n};\n\n// Returns true if this is an object with at least one key and all keys begin\n// with $.  Unless inconsistentOK is set, throws if some keys begin with $ and\n// others don't.\nvar isOperatorObject = function isOperatorObject(valueSelector, inconsistentOK) {\n  if (!isPlainObject(valueSelector)) return false;\n\n  var theseAreOperators = undefined;\n  _$1.each(valueSelector, function (value, selKey) {\n    var thisIsOperator = selKey.substr(0, 1) === '$';\n    if (theseAreOperators === undefined) {\n      theseAreOperators = thisIsOperator;\n    } else if (theseAreOperators !== thisIsOperator) {\n      if (!inconsistentOK) throw new Error(\"Inconsistent operator: \" + JSON.stringify(valueSelector));\n      theseAreOperators = false;\n    }\n  });\n  return !!theseAreOperators; // {} has no operators\n};\n\n// string can be converted to integer\nvar isNumericKey = function isNumericKey(s) {\n  return (/^[0-9]+$/.test(s)\n  );\n};\n\nvar isPlainObject = (function (variableToCheck) {\n  if (!variableToCheck) return false;\n  if (typeof variableToCheck === \"number\") return false;\n  if (typeof variableToCheck === \"string\") return false;\n  if (typeof variableToCheck === \"boolean\") return false;\n  if (isArray(variableToCheck)) return false;\n  if (variableToCheck === null) return false;\n  if (variableToCheck instanceof RegExp)\n    // note that typeof(/x/) === \"object\"\n    return false;\n  if (typeof variableToCheck === \"function\") return false;\n  if (variableToCheck instanceof Date) return false;\n  if (isBinary(variableToCheck)) return false;\n\n  return true; // object\n});\n\nvar ModifyJsError = function (message) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (typeof message === \"string\" && options.field) {\n    message += \" for field '\" + options.field + \"'\";\n  }\n\n  var e = new Error(message);\n  e.name = \"ModifyJsError\";\n  return e;\n};\n\nvar _ = { all: every, each: each, keys: keys, has: has, isObject: isObject };\n// XXX need a strategy for passing the binding of $ into this\n// function, from the compiled selector\n//\n// maybe just {key.up.to.just.before.dollarsign: array_index}\n//\n// XXX atomicity: if one modification fails, do we roll back the whole\n// change?\n//\n// options:\n//   - isInsert is set when _modify is being called to compute the document to\n//     insert as part of an upsert operation. We use this primarily to figure\n//     out when to set the fields in $setOnInsert, if present.\nvar modify = function (doc, mod, options) {\n  if (options && options.each) {\n    return;\n  }\n  return _modify(doc, mod, _extends({}, options, { returnInsteadOfReplacing: true }));\n};\n\nvar _modify = function _modify(doc, mod, options) {\n  options = options || {};\n  if (!isPlainObject(mod)) throw ModifyJsError(\"Modifier must be an object\");\n\n  // Make sure the caller can't mutate our data structures.\n  mod = clone(mod);\n\n  var isModifier = isOperatorObject(mod);\n\n  var newDoc;\n\n  if (!isModifier) {\n    // replace the whole document\n    newDoc = mod;\n  } else {\n    // apply modifiers to the doc.\n    newDoc = clone(doc);\n    _.each(mod, function (operand, op) {\n      var modFunc = MODIFIERS[op];\n      // Treat $setOnInsert as $set if this is an insert.\n      if (!modFunc) throw ModifyJsError(\"Invalid modifier specified \" + op);\n      _.each(operand, function (arg, keypath) {\n        if (keypath === '') {\n          throw ModifyJsError(\"An empty update path is not valid.\");\n        }\n\n        var keyparts = keypath.split('.');\n        if (!_.all(keyparts)) {\n          throw ModifyJsError(\"The update path '\" + keypath + \"' contains an empty field name, which is not allowed.\");\n        }\n\n        var target = findModTarget(newDoc, keyparts, {\n          noCreate: NO_CREATE_MODIFIERS[op],\n          forbidArray: op === \"$rename\",\n          arrayIndices: options.arrayIndices\n        });\n        var field = keyparts.pop();\n        modFunc(target, field, arg, keypath, newDoc);\n      });\n    });\n  }\n\n  if (options.returnInsteadOfReplacing) {\n    return newDoc;\n  } else {\n    // move new document into place.\n    _.each(_.keys(doc), function (k) {\n      // Note: this used to be for (var k in doc) however, this does not\n      // work right in Opera. Deleting from a doc while iterating over it\n      // would sometimes cause opera to skip some keys.\n      if (k !== '_id') delete doc[k];\n    });\n    _.each(newDoc, function (v, k) {\n      doc[k] = v;\n    });\n  }\n};\n\n// for a.b.c.2.d.e, keyparts should be ['a', 'b', 'c', '2', 'd', 'e'],\n// and then you would operate on the 'e' property of the returned\n// object.\n//\n// if options.noCreate is falsey, creates intermediate levels of\n// structure as necessary, like mkdir -p (and raises an exception if\n// that would mean giving a non-numeric property to an array.) if\n// options.noCreate is true, return undefined instead.\n//\n// may modify the last element of keyparts to signal to the caller that it needs\n// to use a different value to index into the returned object (for example,\n// ['a', '01'] -> ['a', 1]).\n//\n// if forbidArray is true, return null if the keypath goes through an array.\n//\n// if options.arrayIndices is set, use its first element for the (first) '$' in\n// the path.\nvar findModTarget = function findModTarget(doc, keyparts, options) {\n  options = options || {};\n  var usedArrayIndex = false;\n  for (var i = 0; i < keyparts.length; i++) {\n    var last = i === keyparts.length - 1;\n    var keypart = keyparts[i];\n    var indexable = isIndexable(doc);\n    if (!indexable) {\n      if (options.noCreate) return undefined;\n      var e = ModifyJsError(\"cannot use the part '\" + keypart + \"' to traverse \" + doc);\n      e.setPropertyError = true;\n      throw e;\n    }\n    if (doc instanceof Array) {\n      if (options.forbidArray) return null;\n      if (keypart === '$') {\n        if (usedArrayIndex) throw ModifyJsError(\"Too many positional (i.e. '$') elements\");\n        if (!options.arrayIndices || !options.arrayIndices.length) {\n          throw ModifyJsError(\"The positional operator did not find the \" + \"match needed from the query\");\n        }\n        keypart = options.arrayIndices[0];\n        usedArrayIndex = true;\n      } else if (isNumericKey(keypart)) {\n        keypart = parseInt(keypart);\n      } else {\n        if (options.noCreate) return undefined;\n        throw ModifyJsError(\"can't append to array using string field name [\" + keypart + \"]\");\n      }\n      if (last)\n        // handle 'a.01'\n        keyparts[i] = keypart;\n      if (options.noCreate && keypart >= doc.length) return undefined;\n      while (doc.length < keypart) {\n        doc.push(null);\n      }if (!last) {\n        if (doc.length === keypart) doc.push({});else if (_typeof(doc[keypart]) !== \"object\") throw ModifyJsError(\"can't modify field '\" + keyparts[i + 1] + \"' of list value \" + JSON.stringify(doc[keypart]));\n      }\n    } else {\n      if (!(keypart in doc)) {\n        if (options.noCreate) return undefined;\n        if (!last) doc[keypart] = {};\n      }\n    }\n\n    if (last) return doc;\n    doc = doc[keypart];\n  }\n};\n\nvar NO_CREATE_MODIFIERS = {\n  $unset: true,\n  $pop: true,\n  $rename: true,\n  $pull: true,\n  $pullAll: true\n};\n\nvar MODIFIERS = {\n  $currentDate: function $currentDate(target, field, arg) {\n    if ((typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === \"object\" && arg.hasOwnProperty(\"$type\")) {\n      if (arg.$type !== \"date\") {\n        throw ModifyJsError(\"Minimongo does currently only support the date type \" + \"in $currentDate modifiers\", { field: field });\n      }\n    } else if (arg !== true) {\n      throw ModifyJsError(\"Invalid $currentDate modifier\", { field: field });\n    }\n    target[field] = new Date();\n  },\n  $min: function $min(target, field, arg) {\n    if (typeof arg !== \"number\") {\n      throw ModifyJsError(\"Modifier $min allowed for numbers only\", { field: field });\n    }\n    if (field in target) {\n      if (typeof target[field] !== \"number\") {\n        throw ModifyJsError(\"Cannot apply $min modifier to non-number\", { field: field });\n      }\n      if (target[field] > arg) {\n        target[field] = arg;\n      }\n    } else {\n      target[field] = arg;\n    }\n  },\n  $max: function $max(target, field, arg) {\n    if (typeof arg !== \"number\") {\n      throw ModifyJsError(\"Modifier $max allowed for numbers only\", { field: field });\n    }\n    if (field in target) {\n      if (typeof target[field] !== \"number\") {\n        throw ModifyJsError(\"Cannot apply $max modifier to non-number\", { field: field });\n      }\n      if (target[field] < arg) {\n        target[field] = arg;\n      }\n    } else {\n      target[field] = arg;\n    }\n  },\n  $inc: function $inc(target, field, arg) {\n    if (typeof arg !== \"number\") throw ModifyJsError(\"Modifier $inc allowed for numbers only\", { field: field });\n    if (field in target) {\n      if (typeof target[field] !== \"number\") throw ModifyJsError(\"Cannot apply $inc modifier to non-number\", { field: field });\n      target[field] += arg;\n    } else {\n      target[field] = arg;\n    }\n  },\n  $set: function $set(target, field, arg) {\n    if (!_.isObject(target)) {\n      // not an array or an object\n      var e = ModifyJsError(\"Cannot set property on non-object field\", { field: field });\n      e.setPropertyError = true;\n      throw e;\n    }\n    if (target === null) {\n      var e = ModifyJsError(\"Cannot set property on null\", { field: field });\n      e.setPropertyError = true;\n      throw e;\n    }\n    target[field] = arg;\n  },\n  $setOnInsert: function $setOnInsert(target, field, arg) {\n    // converted to `$set` in `_modify`\n  },\n  $unset: function $unset(target, field, arg) {\n    if (target !== undefined) {\n      if (target instanceof Array) {\n        if (field in target) target[field] = null;\n      } else delete target[field];\n    }\n  },\n  $push: function $push(target, field, arg) {\n    if (target[field] === undefined) target[field] = [];\n    if (!(target[field] instanceof Array)) throw ModifyJsError(\"Cannot apply $push modifier to non-array\", { field: field });\n\n    if (!(arg && arg.$each)) {\n      // Simple mode: not $each\n      target[field].push(arg);\n      return;\n    }\n\n    // Fancy mode: $each (and maybe $slice and $sort and $position)\n    var toPush = arg.$each;\n    if (!(toPush instanceof Array)) throw ModifyJsError(\"$each must be an array\", { field: field });\n\n    // Parse $position\n    var position = undefined;\n    if ('$position' in arg) {\n      if (typeof arg.$position !== \"number\") throw ModifyJsError(\"$position must be a numeric value\", { field: field });\n      // XXX should check to make sure integer\n      if (arg.$position < 0) throw ModifyJsError(\"$position in $push must be zero or positive\", { field: field });\n      position = arg.$position;\n    }\n\n    // Parse $slice.\n    var slice = undefined;\n    if ('$slice' in arg) {\n      if (typeof arg.$slice !== \"number\") throw ModifyJsError(\"$slice must be a numeric value\", { field: field });\n      // XXX should check to make sure integer\n      if (arg.$slice > 0) throw ModifyJsError(\"$slice in $push must be zero or negative\", { field: field });\n      slice = arg.$slice;\n    }\n\n    // Parse $sort.\n    var sortFunction = undefined;\n    if (arg.$sort) {\n      throw ModifyJsError(\"$sort in $push not implemented yet\");\n      // if (slice === undefined)\n      //   throw ModifyJsError(\"$sort requires $slice to be present\", { field });\n      // // XXX this allows us to use a $sort whose value is an array, but that's\n      // // actually an extension of the Node driver, so it won't work\n      // // server-side. Could be confusing!\n      // // XXX is it correct that we don't do geo-stuff here?\n      // sortFunction = new Minimongo.Sorter(arg.$sort).getComparator();\n      // for (var i = 0; i < toPush.length; i++) {\n      //   if (_f._type(toPush[i]) !== 3) {\n      //     throw ModifyJsError(\"$push like modifiers using $sort \" +\n      //                 \"require all elements to be objects\", { field });\n      //   }\n      // }\n    }\n\n    // Actually push.\n    if (position === undefined) {\n      for (var j = 0; j < toPush.length; j++) {\n        target[field].push(toPush[j]);\n      }\n    } else {\n      var spliceArguments = [position, 0];\n      for (var j = 0; j < toPush.length; j++) {\n        spliceArguments.push(toPush[j]);\n      }Array.prototype.splice.apply(target[field], spliceArguments);\n    }\n\n    // Actually sort.\n    if (sortFunction) target[field].sort(sortFunction);\n\n    // Actually slice.\n    if (slice !== undefined) {\n      if (slice === 0) target[field] = []; // differs from Array.slice!\n      else target[field] = target[field].slice(slice);\n    }\n  },\n  $pushAll: function $pushAll(target, field, arg) {\n    if (!((typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === \"object\" && arg instanceof Array)) throw ModifyJsError(\"Modifier $pushAll/pullAll allowed for arrays only\");\n    var x = target[field];\n    if (x === undefined) target[field] = arg;else if (!(x instanceof Array)) throw ModifyJsError(\"Cannot apply $pushAll modifier to non-array\", { field: field });else {\n      for (var i = 0; i < arg.length; i++) {\n        x.push(arg[i]);\n      }\n    }\n  },\n  $addToSet: function $addToSet(target, field, arg) {\n    var isEach = false;\n    if ((typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === \"object\") {\n      //check if first key is '$each'\n      var _keys = Object.keys(arg);\n      if (_keys[0] === \"$each\") {\n        isEach = true;\n      }\n    }\n    var values = isEach ? arg[\"$each\"] : [arg];\n    var x = target[field];\n    if (x === undefined) target[field] = values;else if (!(x instanceof Array)) throw ModifyJsError(\"Cannot apply $addToSet modifier to non-array\", { field: field });else {\n      _.each(values, function (value) {\n        for (var i = 0; i < x.length; i++) {\n          if (equal(value, x[i])) return;\n        }x.push(value);\n      });\n    }\n  },\n  $pop: function $pop(target, field, arg) {\n    if (target === undefined) return;\n    var x = target[field];\n    if (x === undefined) return;else if (!(x instanceof Array)) throw ModifyJsError(\"Cannot apply $pop modifier to non-array\", { field: field });else {\n      if (typeof arg === 'number' && arg < 0) x.splice(0, 1);else x.pop();\n    }\n  },\n  $pull: function $pull(target, field, arg) {\n    if (target === undefined) return;\n    var x = target[field];\n    if (x === undefined) return;else if (!(x instanceof Array)) throw ModifyJsError(\"Cannot apply $pull/pullAll modifier to non-array\", { field: field });else {\n      throw ModifyJsError(\"$pull not implemented yet\");\n      // var out = [];\n      // if (arg != null && typeof arg === \"object\" && !(arg instanceof Array)) {\n      //   // XXX would be much nicer to compile this once, rather than\n      //   // for each document we modify.. but usually we're not\n      //   // modifying that many documents, so we'll let it slide for\n      //   // now\n      //\n      //   // XXX Minimongo.Matcher isn't up for the job, because we need\n      //   // to permit stuff like {$pull: {a: {$gt: 4}}}.. something\n      //   // like {$gt: 4} is not normally a complete selector.\n      //   // same issue as $elemMatch possibly?\n      //   var matcher = new Minimongo.Matcher(arg);\n      //   for (var i = 0; i < x.length; i++)\n      //     if (!matcher.documentMatches(x[i]).result)\n      //       out.push(x[i]);\n      // } else {\n      //   for (var i = 0; i < x.length; i++)\n      //     if (!_f._equal(x[i], arg))\n      //       out.push(x[i]);\n      // }\n      // target[field] = out;\n    }\n  },\n  $pullAll: function $pullAll(target, field, arg) {\n    if (!((typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === \"object\" && arg instanceof Array)) throw ModifyJsError(\"Modifier $pushAll/pullAll allowed for arrays only\", { field: field });\n    if (target === undefined) return;\n    var x = target[field];\n    if (x === undefined) return;else if (!(x instanceof Array)) throw ModifyJsError(\"Cannot apply $pull/pullAll modifier to non-array\", { field: field });else {\n      var out = [];\n      for (var i = 0; i < x.length; i++) {\n        var exclude = false;\n        for (var j = 0; j < arg.length; j++) {\n          if (equal(x[i], arg[j])) {\n            exclude = true;\n            break;\n          }\n        }\n        if (!exclude) out.push(x[i]);\n      }\n      target[field] = out;\n    }\n  },\n  $rename: function $rename(target, field, arg, keypath, doc) {\n    if (keypath === arg)\n      // no idea why mongo has this restriction..\n      throw ModifyJsError(\"$rename source must differ from target\", { field: field });\n    if (target === null) throw ModifyJsError(\"$rename source field invalid\", { field: field });\n    if (typeof arg !== \"string\") throw ModifyJsError(\"$rename target must be a string\", { field: field });\n    if (arg.indexOf('\\0') > -1) {\n      // Null bytes are not allowed in Mongo field names\n      // https://docs.mongodb.com/manual/reference/limits/#Restrictions-on-Field-Names\n      throw ModifyJsError(\"The 'to' field for $rename cannot contain an embedded null byte\", { field: field });\n    }\n    if (target === undefined) return;\n    var v = target[field];\n    delete target[field];\n\n    var keyparts = arg.split('.');\n    var target2 = findModTarget(doc, keyparts, { forbidArray: true });\n    if (target2 === null) throw ModifyJsError(\"$rename target field invalid\", { field: field });\n    var field2 = keyparts.pop();\n    target2[field2] = v;\n  },\n  $bit: function $bit(target, field, arg) {\n    // XXX mongo only supports $bit on integers, and we only support\n    // native javascript numbers (doubles) so far, so we can't support $bit\n    throw ModifyJsError(\"$bit is not supported\", { field: field });\n  }\n};\n\nmodule.exports = modify;\n"]},"metadata":{},"sourceType":"script"}
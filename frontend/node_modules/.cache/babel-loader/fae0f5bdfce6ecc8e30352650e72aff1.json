{"ast":null,"code":"import { explainError } from 'pouchdb-utils';\nimport { collate } from 'pouchdb-collate';\nvar CHECKPOINT_VERSION = 1;\nvar REPLICATOR = \"pouchdb\"; // This is an arbitrary number to limit the\n// amount of replication history we save in the checkpoint.\n// If we save too much, the checkpoing docs will become very big,\n// if we save fewer, we'll run a greater risk of having to\n// read all the changes from 0 when checkpoint PUTs fail\n// CouchDB 2.0 has a more involved history pruning,\n// but let's go for the simple version for now.\n\nvar CHECKPOINT_HISTORY_SIZE = 5;\nvar LOWEST_SEQ = 0;\n\nfunction updateCheckpoint(db, id, checkpoint, session, returnValue) {\n  return db.get(id).catch(function (err) {\n    if (err.status === 404) {\n      if (db.adapter === 'http' || db.adapter === 'https') {\n        explainError(404, 'PouchDB is just checking if a remote checkpoint exists.');\n      }\n\n      return {\n        session_id: session,\n        _id: id,\n        history: [],\n        replicator: REPLICATOR,\n        version: CHECKPOINT_VERSION\n      };\n    }\n\n    throw err;\n  }).then(function (doc) {\n    if (returnValue.cancelled) {\n      return;\n    } // if the checkpoint has not changed, do not update\n\n\n    if (doc.last_seq === checkpoint) {\n      return;\n    } // Filter out current entry for this replication\n\n\n    doc.history = (doc.history || []).filter(function (item) {\n      return item.session_id !== session;\n    }); // Add the latest checkpoint to history\n\n    doc.history.unshift({\n      last_seq: checkpoint,\n      session_id: session\n    }); // Just take the last pieces in history, to\n    // avoid really big checkpoint docs.\n    // see comment on history size above\n\n    doc.history = doc.history.slice(0, CHECKPOINT_HISTORY_SIZE);\n    doc.version = CHECKPOINT_VERSION;\n    doc.replicator = REPLICATOR;\n    doc.session_id = session;\n    doc.last_seq = checkpoint;\n    return db.put(doc).catch(function (err) {\n      if (err.status === 409) {\n        // retry; someone is trying to write a checkpoint simultaneously\n        return updateCheckpoint(db, id, checkpoint, session, returnValue);\n      }\n\n      throw err;\n    });\n  });\n}\n\nfunction Checkpointer(src, target, id, returnValue, opts) {\n  this.src = src;\n  this.target = target;\n  this.id = id;\n  this.returnValue = returnValue;\n  this.opts = opts || {};\n}\n\nCheckpointer.prototype.writeCheckpoint = function (checkpoint, session) {\n  var self = this;\n  return this.updateTarget(checkpoint, session).then(function () {\n    return self.updateSource(checkpoint, session);\n  });\n};\n\nCheckpointer.prototype.updateTarget = function (checkpoint, session) {\n  if (this.opts.writeTargetCheckpoint) {\n    return updateCheckpoint(this.target, this.id, checkpoint, session, this.returnValue);\n  } else {\n    return Promise.resolve(true);\n  }\n};\n\nCheckpointer.prototype.updateSource = function (checkpoint, session) {\n  if (this.opts.writeSourceCheckpoint) {\n    var self = this;\n    return updateCheckpoint(this.src, this.id, checkpoint, session, this.returnValue).catch(function (err) {\n      if (isForbiddenError(err)) {\n        self.opts.writeSourceCheckpoint = false;\n        return true;\n      }\n\n      throw err;\n    });\n  } else {\n    return Promise.resolve(true);\n  }\n};\n\nvar comparisons = {\n  \"undefined\": function undefined(targetDoc, sourceDoc) {\n    // This is the previous comparison function\n    if (collate(targetDoc.last_seq, sourceDoc.last_seq) === 0) {\n      return sourceDoc.last_seq;\n    }\n    /* istanbul ignore next */\n\n\n    return 0;\n  },\n  \"1\": function _(targetDoc, sourceDoc) {\n    // This is the comparison function ported from CouchDB\n    return compareReplicationLogs(sourceDoc, targetDoc).last_seq;\n  }\n};\n\nCheckpointer.prototype.getCheckpoint = function () {\n  var self = this;\n\n  if (self.opts && self.opts.writeSourceCheckpoint && !self.opts.writeTargetCheckpoint) {\n    return self.src.get(self.id).then(function (sourceDoc) {\n      return sourceDoc.last_seq || LOWEST_SEQ;\n    }).catch(function (err) {\n      /* istanbul ignore if */\n      if (err.status !== 404) {\n        throw err;\n      }\n\n      return LOWEST_SEQ;\n    });\n  }\n\n  return self.target.get(self.id).then(function (targetDoc) {\n    if (self.opts && self.opts.writeTargetCheckpoint && !self.opts.writeSourceCheckpoint) {\n      return targetDoc.last_seq || LOWEST_SEQ;\n    }\n\n    return self.src.get(self.id).then(function (sourceDoc) {\n      // Since we can't migrate an old version doc to a new one\n      // (no session id), we just go with the lowest seq in this case\n\n      /* istanbul ignore if */\n      if (targetDoc.version !== sourceDoc.version) {\n        return LOWEST_SEQ;\n      }\n\n      var version;\n\n      if (targetDoc.version) {\n        version = targetDoc.version.toString();\n      } else {\n        version = \"undefined\";\n      }\n\n      if (version in comparisons) {\n        return comparisons[version](targetDoc, sourceDoc);\n      }\n      /* istanbul ignore next */\n\n\n      return LOWEST_SEQ;\n    }, function (err) {\n      if (err.status === 404 && targetDoc.last_seq) {\n        return self.src.put({\n          _id: self.id,\n          last_seq: LOWEST_SEQ\n        }).then(function () {\n          return LOWEST_SEQ;\n        }, function (err) {\n          if (isForbiddenError(err)) {\n            self.opts.writeSourceCheckpoint = false;\n            return targetDoc.last_seq;\n          }\n          /* istanbul ignore next */\n\n\n          return LOWEST_SEQ;\n        });\n      }\n\n      throw err;\n    });\n  }).catch(function (err) {\n    if (err.status !== 404) {\n      throw err;\n    }\n\n    return LOWEST_SEQ;\n  });\n}; // This checkpoint comparison is ported from CouchDBs source\n// they come from here:\n// https://github.com/apache/couchdb-couch-replicator/blob/master/src/couch_replicator.erl#L863-L906\n\n\nfunction compareReplicationLogs(srcDoc, tgtDoc) {\n  if (srcDoc.session_id === tgtDoc.session_id) {\n    return {\n      last_seq: srcDoc.last_seq,\n      history: srcDoc.history\n    };\n  }\n\n  return compareReplicationHistory(srcDoc.history, tgtDoc.history);\n}\n\nfunction compareReplicationHistory(sourceHistory, targetHistory) {\n  // the erlang loop via function arguments is not so easy to repeat in JS\n  // therefore, doing this as recursion\n  var S = sourceHistory[0];\n  var sourceRest = sourceHistory.slice(1);\n  var T = targetHistory[0];\n  var targetRest = targetHistory.slice(1);\n\n  if (!S || targetHistory.length === 0) {\n    return {\n      last_seq: LOWEST_SEQ,\n      history: []\n    };\n  }\n\n  var sourceId = S.session_id;\n  /* istanbul ignore if */\n\n  if (hasSessionId(sourceId, targetHistory)) {\n    return {\n      last_seq: S.last_seq,\n      history: sourceHistory\n    };\n  }\n\n  var targetId = T.session_id;\n\n  if (hasSessionId(targetId, sourceRest)) {\n    return {\n      last_seq: T.last_seq,\n      history: targetRest\n    };\n  }\n\n  return compareReplicationHistory(sourceRest, targetRest);\n}\n\nfunction hasSessionId(sessionId, history) {\n  var props = history[0];\n  var rest = history.slice(1);\n\n  if (!sessionId || history.length === 0) {\n    return false;\n  }\n\n  if (sessionId === props.session_id) {\n    return true;\n  }\n\n  return hasSessionId(sessionId, rest);\n}\n\nfunction isForbiddenError(err) {\n  return typeof err.status === 'number' && Math.floor(err.status / 100) === 4;\n}\n\nexport default Checkpointer;","map":{"version":3,"sources":["/Users/Hanzalah/Desktop/github/todo-offline/rxdb-hasura-demo/node_modules/pouchdb-checkpointer/lib/index.es.js"],"names":["explainError","collate","CHECKPOINT_VERSION","REPLICATOR","CHECKPOINT_HISTORY_SIZE","LOWEST_SEQ","updateCheckpoint","db","id","checkpoint","session","returnValue","get","catch","err","status","adapter","session_id","_id","history","replicator","version","then","doc","cancelled","last_seq","filter","item","unshift","slice","put","Checkpointer","src","target","opts","prototype","writeCheckpoint","self","updateTarget","updateSource","writeTargetCheckpoint","Promise","resolve","writeSourceCheckpoint","isForbiddenError","comparisons","targetDoc","sourceDoc","compareReplicationLogs","getCheckpoint","toString","srcDoc","tgtDoc","compareReplicationHistory","sourceHistory","targetHistory","S","sourceRest","T","targetRest","length","sourceId","hasSessionId","targetId","sessionId","props","rest","Math","floor"],"mappings":"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","sourcesContent":["import { explainError } from 'pouchdb-utils';\nimport { collate } from 'pouchdb-collate';\n\nvar CHECKPOINT_VERSION = 1;\nvar REPLICATOR = \"pouchdb\";\n// This is an arbitrary number to limit the\n// amount of replication history we save in the checkpoint.\n// If we save too much, the checkpoing docs will become very big,\n// if we save fewer, we'll run a greater risk of having to\n// read all the changes from 0 when checkpoint PUTs fail\n// CouchDB 2.0 has a more involved history pruning,\n// but let's go for the simple version for now.\nvar CHECKPOINT_HISTORY_SIZE = 5;\nvar LOWEST_SEQ = 0;\n\nfunction updateCheckpoint(db, id, checkpoint, session, returnValue) {\n  return db.get(id).catch(function (err) {\n    if (err.status === 404) {\n      if (db.adapter === 'http' || db.adapter === 'https') {\n        explainError(\n          404, 'PouchDB is just checking if a remote checkpoint exists.'\n        );\n      }\n      return {\n        session_id: session,\n        _id: id,\n        history: [],\n        replicator: REPLICATOR,\n        version: CHECKPOINT_VERSION\n      };\n    }\n    throw err;\n  }).then(function (doc) {\n    if (returnValue.cancelled) {\n      return;\n    }\n\n    // if the checkpoint has not changed, do not update\n    if (doc.last_seq === checkpoint) {\n      return;\n    }\n\n    // Filter out current entry for this replication\n    doc.history = (doc.history || []).filter(function (item) {\n      return item.session_id !== session;\n    });\n\n    // Add the latest checkpoint to history\n    doc.history.unshift({\n      last_seq: checkpoint,\n      session_id: session\n    });\n\n    // Just take the last pieces in history, to\n    // avoid really big checkpoint docs.\n    // see comment on history size above\n    doc.history = doc.history.slice(0, CHECKPOINT_HISTORY_SIZE);\n\n    doc.version = CHECKPOINT_VERSION;\n    doc.replicator = REPLICATOR;\n\n    doc.session_id = session;\n    doc.last_seq = checkpoint;\n\n    return db.put(doc).catch(function (err) {\n      if (err.status === 409) {\n        // retry; someone is trying to write a checkpoint simultaneously\n        return updateCheckpoint(db, id, checkpoint, session, returnValue);\n      }\n      throw err;\n    });\n  });\n}\n\nfunction Checkpointer(src, target, id, returnValue, opts) {\n  this.src = src;\n  this.target = target;\n  this.id = id;\n  this.returnValue = returnValue;\n  this.opts = opts || {};\n}\n\nCheckpointer.prototype.writeCheckpoint = function (checkpoint, session) {\n  var self = this;\n  return this.updateTarget(checkpoint, session).then(function () {\n    return self.updateSource(checkpoint, session);\n  });\n};\n\nCheckpointer.prototype.updateTarget = function (checkpoint, session) {\n  if (this.opts.writeTargetCheckpoint) {\n    return updateCheckpoint(this.target, this.id, checkpoint,\n      session, this.returnValue);\n  } else {\n    return Promise.resolve(true);\n  }\n};\n\nCheckpointer.prototype.updateSource = function (checkpoint, session) {\n  if (this.opts.writeSourceCheckpoint) {\n    var self = this;\n    return updateCheckpoint(this.src, this.id, checkpoint,\n      session, this.returnValue)\n      .catch(function (err) {\n        if (isForbiddenError(err)) {\n          self.opts.writeSourceCheckpoint = false;\n          return true;\n        }\n        throw err;\n      });\n  } else {\n    return Promise.resolve(true);\n  }\n};\n\nvar comparisons = {\n  \"undefined\": function (targetDoc, sourceDoc) {\n    // This is the previous comparison function\n    if (collate(targetDoc.last_seq, sourceDoc.last_seq) === 0) {\n      return sourceDoc.last_seq;\n    }\n    /* istanbul ignore next */\n    return 0;\n  },\n  \"1\": function (targetDoc, sourceDoc) {\n    // This is the comparison function ported from CouchDB\n    return compareReplicationLogs(sourceDoc, targetDoc).last_seq;\n  }\n};\n\nCheckpointer.prototype.getCheckpoint = function () {\n  var self = this;\n\n  if (self.opts && self.opts.writeSourceCheckpoint && !self.opts.writeTargetCheckpoint) {\n    return self.src.get(self.id).then(function (sourceDoc) {\n      return sourceDoc.last_seq || LOWEST_SEQ;\n    }).catch(function (err) {\n      /* istanbul ignore if */\n      if (err.status !== 404) {\n        throw err;\n      }\n      return LOWEST_SEQ;\n    });\n  }\n\n  return self.target.get(self.id).then(function (targetDoc) {\n    if (self.opts && self.opts.writeTargetCheckpoint && !self.opts.writeSourceCheckpoint) {\n      return targetDoc.last_seq || LOWEST_SEQ;\n    }\n\n    return self.src.get(self.id).then(function (sourceDoc) {\n      // Since we can't migrate an old version doc to a new one\n      // (no session id), we just go with the lowest seq in this case\n      /* istanbul ignore if */\n      if (targetDoc.version !== sourceDoc.version) {\n        return LOWEST_SEQ;\n      }\n\n      var version;\n      if (targetDoc.version) {\n        version = targetDoc.version.toString();\n      } else {\n        version = \"undefined\";\n      }\n\n      if (version in comparisons) {\n        return comparisons[version](targetDoc, sourceDoc);\n      }\n      /* istanbul ignore next */\n      return LOWEST_SEQ;\n    }, function (err) {\n      if (err.status === 404 && targetDoc.last_seq) {\n        return self.src.put({\n          _id: self.id,\n          last_seq: LOWEST_SEQ\n        }).then(function () {\n          return LOWEST_SEQ;\n        }, function (err) {\n          if (isForbiddenError(err)) {\n            self.opts.writeSourceCheckpoint = false;\n            return targetDoc.last_seq;\n          }\n          /* istanbul ignore next */\n          return LOWEST_SEQ;\n        });\n      }\n      throw err;\n    });\n  }).catch(function (err) {\n    if (err.status !== 404) {\n      throw err;\n    }\n    return LOWEST_SEQ;\n  });\n};\n// This checkpoint comparison is ported from CouchDBs source\n// they come from here:\n// https://github.com/apache/couchdb-couch-replicator/blob/master/src/couch_replicator.erl#L863-L906\n\nfunction compareReplicationLogs(srcDoc, tgtDoc) {\n  if (srcDoc.session_id === tgtDoc.session_id) {\n    return {\n      last_seq: srcDoc.last_seq,\n      history: srcDoc.history\n    };\n  }\n\n  return compareReplicationHistory(srcDoc.history, tgtDoc.history);\n}\n\nfunction compareReplicationHistory(sourceHistory, targetHistory) {\n  // the erlang loop via function arguments is not so easy to repeat in JS\n  // therefore, doing this as recursion\n  var S = sourceHistory[0];\n  var sourceRest = sourceHistory.slice(1);\n  var T = targetHistory[0];\n  var targetRest = targetHistory.slice(1);\n\n  if (!S || targetHistory.length === 0) {\n    return {\n      last_seq: LOWEST_SEQ,\n      history: []\n    };\n  }\n\n  var sourceId = S.session_id;\n  /* istanbul ignore if */\n  if (hasSessionId(sourceId, targetHistory)) {\n    return {\n      last_seq: S.last_seq,\n      history: sourceHistory\n    };\n  }\n\n  var targetId = T.session_id;\n  if (hasSessionId(targetId, sourceRest)) {\n    return {\n      last_seq: T.last_seq,\n      history: targetRest\n    };\n  }\n\n  return compareReplicationHistory(sourceRest, targetRest);\n}\n\nfunction hasSessionId(sessionId, history) {\n  var props = history[0];\n  var rest = history.slice(1);\n\n  if (!sessionId || history.length === 0) {\n    return false;\n  }\n\n  if (sessionId === props.session_id) {\n    return true;\n  }\n\n  return hasSessionId(sessionId, rest);\n}\n\nfunction isForbiddenError(err) {\n  return typeof err.status === 'number' && Math.floor(err.status / 100) === 4;\n}\n\nexport default Checkpointer;\n"]},"metadata":{},"sourceType":"module"}
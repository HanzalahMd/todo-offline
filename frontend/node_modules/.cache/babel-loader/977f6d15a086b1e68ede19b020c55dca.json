{"ast":null,"code":"function pad(str, padWith, upToLength) {\n  var padding = '';\n  var targetLength = upToLength - str.length;\n  /* istanbul ignore next */\n\n  while (padding.length < targetLength) {\n    padding += padWith;\n  }\n\n  return padding;\n}\n\nfunction padLeft(str, padWith, upToLength) {\n  var padding = pad(str, padWith, upToLength);\n  return padding + str;\n}\n\nvar MIN_MAGNITUDE = -324; // verified by -Number.MIN_VALUE\n\nvar MAGNITUDE_DIGITS = 3; // ditto\n\nvar SEP = ''; // set to '_' for easier debugging \n\nfunction collate(a, b) {\n  if (a === b) {\n    return 0;\n  }\n\n  a = normalizeKey(a);\n  b = normalizeKey(b);\n  var ai = collationIndex(a);\n  var bi = collationIndex(b);\n\n  if (ai - bi !== 0) {\n    return ai - bi;\n  }\n\n  switch (typeof a) {\n    case 'number':\n      return a - b;\n\n    case 'boolean':\n      return a < b ? -1 : 1;\n\n    case 'string':\n      return stringCollate(a, b);\n  }\n\n  return Array.isArray(a) ? arrayCollate(a, b) : objectCollate(a, b);\n} // couch considers null/NaN/Infinity/-Infinity === undefined,\n// for the purposes of mapreduce indexes. also, dates get stringified.\n\n\nfunction normalizeKey(key) {\n  switch (typeof key) {\n    case 'undefined':\n      return null;\n\n    case 'number':\n      if (key === Infinity || key === -Infinity || isNaN(key)) {\n        return null;\n      }\n\n      return key;\n\n    case 'object':\n      var origKey = key;\n\n      if (Array.isArray(key)) {\n        var len = key.length;\n        key = new Array(len);\n\n        for (var i = 0; i < len; i++) {\n          key[i] = normalizeKey(origKey[i]);\n        }\n        /* istanbul ignore next */\n\n      } else if (key instanceof Date) {\n        return key.toJSON();\n      } else if (key !== null) {\n        // generic object\n        key = {};\n\n        for (var k in origKey) {\n          if (origKey.hasOwnProperty(k)) {\n            var val = origKey[k];\n\n            if (typeof val !== 'undefined') {\n              key[k] = normalizeKey(val);\n            }\n          }\n        }\n      }\n\n  }\n\n  return key;\n}\n\nfunction indexify(key) {\n  if (key !== null) {\n    switch (typeof key) {\n      case 'boolean':\n        return key ? 1 : 0;\n\n      case 'number':\n        return numToIndexableString(key);\n\n      case 'string':\n        // We've to be sure that key does not contain \\u0000\n        // Do order-preserving replacements:\n        // 0 -> 1, 1\n        // 1 -> 1, 2\n        // 2 -> 2, 2\n\n        /* eslint-disable no-control-regex */\n        return key.replace(/\\u0002/g, \"\\x02\\x02\").replace(/\\u0001/g, \"\\x01\\x02\").replace(/\\u0000/g, \"\\x01\\x01\");\n\n      /* eslint-enable no-control-regex */\n\n      case 'object':\n        var isArray = Array.isArray(key);\n        var arr = isArray ? key : Object.keys(key);\n        var i = -1;\n        var len = arr.length;\n        var result = '';\n\n        if (isArray) {\n          while (++i < len) {\n            result += toIndexableString(arr[i]);\n          }\n        } else {\n          while (++i < len) {\n            var objKey = arr[i];\n            result += toIndexableString(objKey) + toIndexableString(key[objKey]);\n          }\n        }\n\n        return result;\n    }\n  }\n\n  return '';\n} // convert the given key to a string that would be appropriate\n// for lexical sorting, e.g. within a database, where the\n// sorting is the same given by the collate() function.\n\n\nfunction toIndexableString(key) {\n  var zero = \"\\0\";\n  key = normalizeKey(key);\n  return collationIndex(key) + SEP + indexify(key) + zero;\n}\n\nfunction parseNumber(str, i) {\n  var originalIdx = i;\n  var num;\n  var zero = str[i] === '1';\n\n  if (zero) {\n    num = 0;\n    i++;\n  } else {\n    var neg = str[i] === '0';\n    i++;\n    var numAsString = '';\n    var magAsString = str.substring(i, i + MAGNITUDE_DIGITS);\n    var magnitude = parseInt(magAsString, 10) + MIN_MAGNITUDE;\n    /* istanbul ignore next */\n\n    if (neg) {\n      magnitude = -magnitude;\n    }\n\n    i += MAGNITUDE_DIGITS;\n\n    while (true) {\n      var ch = str[i];\n\n      if (ch === \"\\0\") {\n        break;\n      } else {\n        numAsString += ch;\n      }\n\n      i++;\n    }\n\n    numAsString = numAsString.split('.');\n\n    if (numAsString.length === 1) {\n      num = parseInt(numAsString, 10);\n    } else {\n      /* istanbul ignore next */\n      num = parseFloat(numAsString[0] + '.' + numAsString[1]);\n    }\n    /* istanbul ignore next */\n\n\n    if (neg) {\n      num = num - 10;\n    }\n    /* istanbul ignore next */\n\n\n    if (magnitude !== 0) {\n      // parseFloat is more reliable than pow due to rounding errors\n      // e.g. Number.MAX_VALUE would return Infinity if we did\n      // num * Math.pow(10, magnitude);\n      num = parseFloat(num + 'e' + magnitude);\n    }\n  }\n\n  return {\n    num: num,\n    length: i - originalIdx\n  };\n} // move up the stack while parsing\n// this function moved outside of parseIndexableString for performance\n\n\nfunction pop(stack, metaStack) {\n  var obj = stack.pop();\n\n  if (metaStack.length) {\n    var lastMetaElement = metaStack[metaStack.length - 1];\n\n    if (obj === lastMetaElement.element) {\n      // popping a meta-element, e.g. an object whose value is another object\n      metaStack.pop();\n      lastMetaElement = metaStack[metaStack.length - 1];\n    }\n\n    var element = lastMetaElement.element;\n    var lastElementIndex = lastMetaElement.index;\n\n    if (Array.isArray(element)) {\n      element.push(obj);\n    } else if (lastElementIndex === stack.length - 2) {\n      // obj with key+value\n      var key = stack.pop();\n      element[key] = obj;\n    } else {\n      stack.push(obj); // obj with key only\n    }\n  }\n}\n\nfunction parseIndexableString(str) {\n  var stack = [];\n  var metaStack = []; // stack for arrays and objects\n\n  var i = 0;\n  /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n\n  while (true) {\n    var collationIndex = str[i++];\n\n    if (collationIndex === \"\\0\") {\n      if (stack.length === 1) {\n        return stack.pop();\n      } else {\n        pop(stack, metaStack);\n        continue;\n      }\n    }\n\n    switch (collationIndex) {\n      case '1':\n        stack.push(null);\n        break;\n\n      case '2':\n        stack.push(str[i] === '1');\n        i++;\n        break;\n\n      case '3':\n        var parsedNum = parseNumber(str, i);\n        stack.push(parsedNum.num);\n        i += parsedNum.length;\n        break;\n\n      case '4':\n        var parsedStr = '';\n        /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n\n        while (true) {\n          var ch = str[i];\n\n          if (ch === \"\\0\") {\n            break;\n          }\n\n          parsedStr += ch;\n          i++;\n        } // perform the reverse of the order-preserving replacement\n        // algorithm (see above)\n\n        /* eslint-disable no-control-regex */\n\n\n        parsedStr = parsedStr.replace(/\\u0001\\u0001/g, \"\\0\").replace(/\\u0001\\u0002/g, \"\\x01\").replace(/\\u0002\\u0002/g, \"\\x02\");\n        /* eslint-enable no-control-regex */\n\n        stack.push(parsedStr);\n        break;\n\n      case '5':\n        var arrayElement = {\n          element: [],\n          index: stack.length\n        };\n        stack.push(arrayElement.element);\n        metaStack.push(arrayElement);\n        break;\n\n      case '6':\n        var objElement = {\n          element: {},\n          index: stack.length\n        };\n        stack.push(objElement.element);\n        metaStack.push(objElement);\n        break;\n\n      /* istanbul ignore next */\n\n      default:\n        throw new Error('bad collationIndex or unexpectedly reached end of input: ' + collationIndex);\n    }\n  }\n}\n\nfunction arrayCollate(a, b) {\n  var len = Math.min(a.length, b.length);\n\n  for (var i = 0; i < len; i++) {\n    var sort = collate(a[i], b[i]);\n\n    if (sort !== 0) {\n      return sort;\n    }\n  }\n\n  return a.length === b.length ? 0 : a.length > b.length ? 1 : -1;\n}\n\nfunction stringCollate(a, b) {\n  // See: https://github.com/daleharvey/pouchdb/issues/40\n  // This is incompatible with the CouchDB implementation, but its the\n  // best we can do for now\n  return a === b ? 0 : a > b ? 1 : -1;\n}\n\nfunction objectCollate(a, b) {\n  var ak = Object.keys(a),\n      bk = Object.keys(b);\n  var len = Math.min(ak.length, bk.length);\n\n  for (var i = 0; i < len; i++) {\n    // First sort the keys\n    var sort = collate(ak[i], bk[i]);\n\n    if (sort !== 0) {\n      return sort;\n    } // if the keys are equal sort the values\n\n\n    sort = collate(a[ak[i]], b[bk[i]]);\n\n    if (sort !== 0) {\n      return sort;\n    }\n  }\n\n  return ak.length === bk.length ? 0 : ak.length > bk.length ? 1 : -1;\n} // The collation is defined by erlangs ordered terms\n// the atoms null, true, false come first, then numbers, strings,\n// arrays, then objects\n// null/undefined/NaN/Infinity/-Infinity are all considered null\n\n\nfunction collationIndex(x) {\n  var id = ['boolean', 'number', 'string', 'object'];\n  var idx = id.indexOf(typeof x); //false if -1 otherwise true, but fast!!!!1\n\n  if (~idx) {\n    if (x === null) {\n      return 1;\n    }\n\n    if (Array.isArray(x)) {\n      return 5;\n    }\n\n    return idx < 3 ? idx + 2 : idx + 3;\n  }\n  /* istanbul ignore next */\n\n\n  if (Array.isArray(x)) {\n    return 5;\n  }\n} // conversion:\n// x yyy zz...zz\n// x = 0 for negative, 1 for 0, 2 for positive\n// y = exponent (for negative numbers negated) moved so that it's >= 0\n// z = mantisse\n\n\nfunction numToIndexableString(num) {\n  if (num === 0) {\n    return '1';\n  } // convert number to exponential format for easier and\n  // more succinct string sorting\n\n\n  var expFormat = num.toExponential().split(/e\\+?/);\n  var magnitude = parseInt(expFormat[1], 10);\n  var neg = num < 0;\n  var result = neg ? '0' : '2'; // first sort by magnitude\n  // it's easier if all magnitudes are positive\n\n  var magForComparison = (neg ? -magnitude : magnitude) - MIN_MAGNITUDE;\n  var magString = padLeft(magForComparison.toString(), '0', MAGNITUDE_DIGITS);\n  result += SEP + magString; // then sort by the factor\n\n  var factor = Math.abs(parseFloat(expFormat[0])); // [1..10)\n\n  /* istanbul ignore next */\n\n  if (neg) {\n    // for negative reverse ordering\n    factor = 10 - factor;\n  }\n\n  var factorStr = factor.toFixed(20); // strip zeros from the end\n\n  factorStr = factorStr.replace(/\\.?0+$/, '');\n  result += SEP + factorStr;\n  return result;\n}\n\nexport { collate, normalizeKey, toIndexableString, parseIndexableString };","map":{"version":3,"sources":["/Users/Hanzalah/Desktop/github/todo-offline/rxdb-hasura-demo/node_modules/pouchdb-collate/lib/index.es.js"],"names":["pad","str","padWith","upToLength","padding","targetLength","length","padLeft","MIN_MAGNITUDE","MAGNITUDE_DIGITS","SEP","collate","a","b","normalizeKey","ai","collationIndex","bi","stringCollate","Array","isArray","arrayCollate","objectCollate","key","Infinity","isNaN","origKey","len","i","Date","toJSON","k","hasOwnProperty","val","indexify","numToIndexableString","replace","arr","Object","keys","result","toIndexableString","objKey","zero","parseNumber","originalIdx","num","neg","numAsString","magAsString","substring","magnitude","parseInt","ch","split","parseFloat","pop","stack","metaStack","obj","lastMetaElement","element","lastElementIndex","index","push","parseIndexableString","parsedNum","parsedStr","arrayElement","objElement","Error","Math","min","sort","ak","bk","x","id","idx","indexOf","expFormat","toExponential","magForComparison","magString","toString","factor","abs","factorStr","toFixed"],"mappings":"AAAA,SAASA,GAAT,CAAaC,GAAb,EAAkBC,OAAlB,EAA2BC,UAA3B,EAAuC;AACrC,MAAIC,OAAO,GAAG,EAAd;AACA,MAAIC,YAAY,GAAGF,UAAU,GAAGF,GAAG,CAACK,MAApC;AACA;;AACA,SAAOF,OAAO,CAACE,MAAR,GAAiBD,YAAxB,EAAsC;AACpCD,IAAAA,OAAO,IAAIF,OAAX;AACD;;AACD,SAAOE,OAAP;AACD;;AAED,SAASG,OAAT,CAAiBN,GAAjB,EAAsBC,OAAtB,EAA+BC,UAA/B,EAA2C;AACzC,MAAIC,OAAO,GAAGJ,GAAG,CAACC,GAAD,EAAMC,OAAN,EAAeC,UAAf,CAAjB;AACA,SAAOC,OAAO,GAAGH,GAAjB;AACD;;AAED,IAAIO,aAAa,GAAG,CAAC,GAArB,C,CAA0B;;AAC1B,IAAIC,gBAAgB,GAAG,CAAvB,C,CAA0B;;AAC1B,IAAIC,GAAG,GAAG,EAAV,C,CAAc;;AAEd,SAASC,OAAT,CAAiBC,CAAjB,EAAoBC,CAApB,EAAuB;AAErB,MAAID,CAAC,KAAKC,CAAV,EAAa;AACX,WAAO,CAAP;AACD;;AAEDD,EAAAA,CAAC,GAAGE,YAAY,CAACF,CAAD,CAAhB;AACAC,EAAAA,CAAC,GAAGC,YAAY,CAACD,CAAD,CAAhB;AAEA,MAAIE,EAAE,GAAGC,cAAc,CAACJ,CAAD,CAAvB;AACA,MAAIK,EAAE,GAAGD,cAAc,CAACH,CAAD,CAAvB;;AACA,MAAKE,EAAE,GAAGE,EAAN,KAAc,CAAlB,EAAqB;AACnB,WAAOF,EAAE,GAAGE,EAAZ;AACD;;AACD,UAAQ,OAAOL,CAAf;AACE,SAAK,QAAL;AACE,aAAOA,CAAC,GAAGC,CAAX;;AACF,SAAK,SAAL;AACE,aAAOD,CAAC,GAAGC,CAAJ,GAAQ,CAAC,CAAT,GAAa,CAApB;;AACF,SAAK,QAAL;AACE,aAAOK,aAAa,CAACN,CAAD,EAAIC,CAAJ,CAApB;AANJ;;AAQA,SAAOM,KAAK,CAACC,OAAN,CAAcR,CAAd,IAAmBS,YAAY,CAACT,CAAD,EAAIC,CAAJ,CAA/B,GAAwCS,aAAa,CAACV,CAAD,EAAIC,CAAJ,CAA5D;AACD,C,CAED;AACA;;;AACA,SAASC,YAAT,CAAsBS,GAAtB,EAA2B;AACzB,UAAQ,OAAOA,GAAf;AACE,SAAK,WAAL;AACE,aAAO,IAAP;;AACF,SAAK,QAAL;AACE,UAAIA,GAAG,KAAKC,QAAR,IAAoBD,GAAG,KAAK,CAACC,QAA7B,IAAyCC,KAAK,CAACF,GAAD,CAAlD,EAAyD;AACvD,eAAO,IAAP;AACD;;AACD,aAAOA,GAAP;;AACF,SAAK,QAAL;AACE,UAAIG,OAAO,GAAGH,GAAd;;AACA,UAAIJ,KAAK,CAACC,OAAN,CAAcG,GAAd,CAAJ,EAAwB;AACtB,YAAII,GAAG,GAAGJ,GAAG,CAACjB,MAAd;AACAiB,QAAAA,GAAG,GAAG,IAAIJ,KAAJ,CAAUQ,GAAV,CAAN;;AACA,aAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,GAApB,EAAyBC,CAAC,EAA1B,EAA8B;AAC5BL,UAAAA,GAAG,CAACK,CAAD,CAAH,GAASd,YAAY,CAACY,OAAO,CAACE,CAAD,CAAR,CAArB;AACD;AACH;;AACC,OAPD,MAOO,IAAIL,GAAG,YAAYM,IAAnB,EAAyB;AAC9B,eAAON,GAAG,CAACO,MAAJ,EAAP;AACD,OAFM,MAEA,IAAIP,GAAG,KAAK,IAAZ,EAAkB;AAAE;AACzBA,QAAAA,GAAG,GAAG,EAAN;;AACA,aAAK,IAAIQ,CAAT,IAAcL,OAAd,EAAuB;AACrB,cAAIA,OAAO,CAACM,cAAR,CAAuBD,CAAvB,CAAJ,EAA+B;AAC7B,gBAAIE,GAAG,GAAGP,OAAO,CAACK,CAAD,CAAjB;;AACA,gBAAI,OAAOE,GAAP,KAAe,WAAnB,EAAgC;AAC9BV,cAAAA,GAAG,CAACQ,CAAD,CAAH,GAASjB,YAAY,CAACmB,GAAD,CAArB;AACD;AACF;AACF;AACF;;AA7BL;;AA+BA,SAAOV,GAAP;AACD;;AAED,SAASW,QAAT,CAAkBX,GAAlB,EAAuB;AACrB,MAAIA,GAAG,KAAK,IAAZ,EAAkB;AAChB,YAAQ,OAAOA,GAAf;AACE,WAAK,SAAL;AACE,eAAOA,GAAG,GAAG,CAAH,GAAO,CAAjB;;AACF,WAAK,QAAL;AACE,eAAOY,oBAAoB,CAACZ,GAAD,CAA3B;;AACF,WAAK,QAAL;AACE;AACA;AACA;AACA;AACA;;AACA;AACA,eAAOA,GAAG,CACPa,OADI,CACI,SADJ,EACe,UADf,EAEJA,OAFI,CAEI,SAFJ,EAEe,UAFf,EAGJA,OAHI,CAGI,SAHJ,EAGe,UAHf,CAAP;;AAIA;;AACF,WAAK,QAAL;AACE,YAAIhB,OAAO,GAAGD,KAAK,CAACC,OAAN,CAAcG,GAAd,CAAd;AACA,YAAIc,GAAG,GAAGjB,OAAO,GAAGG,GAAH,GAASe,MAAM,CAACC,IAAP,CAAYhB,GAAZ,CAA1B;AACA,YAAIK,CAAC,GAAG,CAAC,CAAT;AACA,YAAID,GAAG,GAAGU,GAAG,CAAC/B,MAAd;AACA,YAAIkC,MAAM,GAAG,EAAb;;AACA,YAAIpB,OAAJ,EAAa;AACX,iBAAO,EAAEQ,CAAF,GAAMD,GAAb,EAAkB;AAChBa,YAAAA,MAAM,IAAIC,iBAAiB,CAACJ,GAAG,CAACT,CAAD,CAAJ,CAA3B;AACD;AACF,SAJD,MAIO;AACL,iBAAO,EAAEA,CAAF,GAAMD,GAAb,EAAkB;AAChB,gBAAIe,MAAM,GAAGL,GAAG,CAACT,CAAD,CAAhB;AACAY,YAAAA,MAAM,IAAIC,iBAAiB,CAACC,MAAD,CAAjB,GACND,iBAAiB,CAAClB,GAAG,CAACmB,MAAD,CAAJ,CADrB;AAED;AACF;;AACD,eAAOF,MAAP;AAlCJ;AAoCD;;AACD,SAAO,EAAP;AACD,C,CAED;AACA;AACA;;;AACA,SAASC,iBAAT,CAA2BlB,GAA3B,EAAgC;AAC9B,MAAIoB,IAAI,GAAG,IAAX;AACApB,EAAAA,GAAG,GAAGT,YAAY,CAACS,GAAD,CAAlB;AACA,SAAOP,cAAc,CAACO,GAAD,CAAd,GAAsBb,GAAtB,GAA4BwB,QAAQ,CAACX,GAAD,CAApC,GAA4CoB,IAAnD;AACD;;AAED,SAASC,WAAT,CAAqB3C,GAArB,EAA0B2B,CAA1B,EAA6B;AAC3B,MAAIiB,WAAW,GAAGjB,CAAlB;AACA,MAAIkB,GAAJ;AACA,MAAIH,IAAI,GAAG1C,GAAG,CAAC2B,CAAD,CAAH,KAAW,GAAtB;;AACA,MAAIe,IAAJ,EAAU;AACRG,IAAAA,GAAG,GAAG,CAAN;AACAlB,IAAAA,CAAC;AACF,GAHD,MAGO;AACL,QAAImB,GAAG,GAAG9C,GAAG,CAAC2B,CAAD,CAAH,KAAW,GAArB;AACAA,IAAAA,CAAC;AACD,QAAIoB,WAAW,GAAG,EAAlB;AACA,QAAIC,WAAW,GAAGhD,GAAG,CAACiD,SAAJ,CAActB,CAAd,EAAiBA,CAAC,GAAGnB,gBAArB,CAAlB;AACA,QAAI0C,SAAS,GAAGC,QAAQ,CAACH,WAAD,EAAc,EAAd,CAAR,GAA4BzC,aAA5C;AACA;;AACA,QAAIuC,GAAJ,EAAS;AACPI,MAAAA,SAAS,GAAG,CAACA,SAAb;AACD;;AACDvB,IAAAA,CAAC,IAAInB,gBAAL;;AACA,WAAO,IAAP,EAAa;AACX,UAAI4C,EAAE,GAAGpD,GAAG,CAAC2B,CAAD,CAAZ;;AACA,UAAIyB,EAAE,KAAK,IAAX,EAAqB;AACnB;AACD,OAFD,MAEO;AACLL,QAAAA,WAAW,IAAIK,EAAf;AACD;;AACDzB,MAAAA,CAAC;AACF;;AACDoB,IAAAA,WAAW,GAAGA,WAAW,CAACM,KAAZ,CAAkB,GAAlB,CAAd;;AACA,QAAIN,WAAW,CAAC1C,MAAZ,KAAuB,CAA3B,EAA8B;AAC5BwC,MAAAA,GAAG,GAAGM,QAAQ,CAACJ,WAAD,EAAc,EAAd,CAAd;AACD,KAFD,MAEO;AACL;AACAF,MAAAA,GAAG,GAAGS,UAAU,CAACP,WAAW,CAAC,CAAD,CAAX,GAAiB,GAAjB,GAAuBA,WAAW,CAAC,CAAD,CAAnC,CAAhB;AACD;AACD;;;AACA,QAAID,GAAJ,EAAS;AACPD,MAAAA,GAAG,GAAGA,GAAG,GAAG,EAAZ;AACD;AACD;;;AACA,QAAIK,SAAS,KAAK,CAAlB,EAAqB;AACnB;AACA;AACA;AACAL,MAAAA,GAAG,GAAGS,UAAU,CAACT,GAAG,GAAG,GAAN,GAAYK,SAAb,CAAhB;AACD;AACF;;AACD,SAAO;AAACL,IAAAA,GAAG,EAAEA,GAAN;AAAWxC,IAAAA,MAAM,EAAGsB,CAAC,GAAGiB;AAAxB,GAAP;AACD,C,CAED;AACA;;;AACA,SAASW,GAAT,CAAaC,KAAb,EAAoBC,SAApB,EAA+B;AAC7B,MAAIC,GAAG,GAAGF,KAAK,CAACD,GAAN,EAAV;;AAEA,MAAIE,SAAS,CAACpD,MAAd,EAAsB;AACpB,QAAIsD,eAAe,GAAGF,SAAS,CAACA,SAAS,CAACpD,MAAV,GAAmB,CAApB,CAA/B;;AACA,QAAIqD,GAAG,KAAKC,eAAe,CAACC,OAA5B,EAAqC;AACnC;AACAH,MAAAA,SAAS,CAACF,GAAV;AACAI,MAAAA,eAAe,GAAGF,SAAS,CAACA,SAAS,CAACpD,MAAV,GAAmB,CAApB,CAA3B;AACD;;AACD,QAAIuD,OAAO,GAAGD,eAAe,CAACC,OAA9B;AACA,QAAIC,gBAAgB,GAAGF,eAAe,CAACG,KAAvC;;AACA,QAAI5C,KAAK,CAACC,OAAN,CAAcyC,OAAd,CAAJ,EAA4B;AAC1BA,MAAAA,OAAO,CAACG,IAAR,CAAaL,GAAb;AACD,KAFD,MAEO,IAAIG,gBAAgB,KAAKL,KAAK,CAACnD,MAAN,GAAe,CAAxC,EAA2C;AAAE;AAClD,UAAIiB,GAAG,GAAGkC,KAAK,CAACD,GAAN,EAAV;AACAK,MAAAA,OAAO,CAACtC,GAAD,CAAP,GAAeoC,GAAf;AACD,KAHM,MAGA;AACLF,MAAAA,KAAK,CAACO,IAAN,CAAWL,GAAX,EADK,CACY;AAClB;AACF;AACF;;AAED,SAASM,oBAAT,CAA8BhE,GAA9B,EAAmC;AACjC,MAAIwD,KAAK,GAAG,EAAZ;AACA,MAAIC,SAAS,GAAG,EAAhB,CAFiC,CAEb;;AACpB,MAAI9B,CAAC,GAAG,CAAR;AAEA;;AACA,SAAO,IAAP,EAAa;AACX,QAAIZ,cAAc,GAAGf,GAAG,CAAC2B,CAAC,EAAF,CAAxB;;AACA,QAAIZ,cAAc,KAAK,IAAvB,EAAiC;AAC/B,UAAIyC,KAAK,CAACnD,MAAN,KAAiB,CAArB,EAAwB;AACtB,eAAOmD,KAAK,CAACD,GAAN,EAAP;AACD,OAFD,MAEO;AACLA,QAAAA,GAAG,CAACC,KAAD,EAAQC,SAAR,CAAH;AACA;AACD;AACF;;AACD,YAAQ1C,cAAR;AACE,WAAK,GAAL;AACEyC,QAAAA,KAAK,CAACO,IAAN,CAAW,IAAX;AACA;;AACF,WAAK,GAAL;AACEP,QAAAA,KAAK,CAACO,IAAN,CAAW/D,GAAG,CAAC2B,CAAD,CAAH,KAAW,GAAtB;AACAA,QAAAA,CAAC;AACD;;AACF,WAAK,GAAL;AACE,YAAIsC,SAAS,GAAGtB,WAAW,CAAC3C,GAAD,EAAM2B,CAAN,CAA3B;AACA6B,QAAAA,KAAK,CAACO,IAAN,CAAWE,SAAS,CAACpB,GAArB;AACAlB,QAAAA,CAAC,IAAIsC,SAAS,CAAC5D,MAAf;AACA;;AACF,WAAK,GAAL;AACE,YAAI6D,SAAS,GAAG,EAAhB;AACA;;AACA,eAAO,IAAP,EAAa;AACX,cAAId,EAAE,GAAGpD,GAAG,CAAC2B,CAAD,CAAZ;;AACA,cAAIyB,EAAE,KAAK,IAAX,EAAqB;AACnB;AACD;;AACDc,UAAAA,SAAS,IAAId,EAAb;AACAzB,UAAAA,CAAC;AACF,SAVH,CAWE;AACA;;AACA;;;AACAuC,QAAAA,SAAS,GAAGA,SAAS,CAAC/B,OAAV,CAAkB,eAAlB,EAAmC,IAAnC,EACTA,OADS,CACD,eADC,EACgB,MADhB,EAETA,OAFS,CAED,eAFC,EAEgB,MAFhB,CAAZ;AAGA;;AACAqB,QAAAA,KAAK,CAACO,IAAN,CAAWG,SAAX;AACA;;AACF,WAAK,GAAL;AACE,YAAIC,YAAY,GAAG;AAAEP,UAAAA,OAAO,EAAE,EAAX;AAAeE,UAAAA,KAAK,EAAEN,KAAK,CAACnD;AAA5B,SAAnB;AACAmD,QAAAA,KAAK,CAACO,IAAN,CAAWI,YAAY,CAACP,OAAxB;AACAH,QAAAA,SAAS,CAACM,IAAV,CAAeI,YAAf;AACA;;AACF,WAAK,GAAL;AACE,YAAIC,UAAU,GAAG;AAAER,UAAAA,OAAO,EAAE,EAAX;AAAeE,UAAAA,KAAK,EAAEN,KAAK,CAACnD;AAA5B,SAAjB;AACAmD,QAAAA,KAAK,CAACO,IAAN,CAAWK,UAAU,CAACR,OAAtB;AACAH,QAAAA,SAAS,CAACM,IAAV,CAAeK,UAAf;AACA;;AACF;;AACA;AACE,cAAM,IAAIC,KAAJ,CACJ,8DACEtD,cAFE,CAAN;AA7CJ;AAiDD;AACF;;AAED,SAASK,YAAT,CAAsBT,CAAtB,EAAyBC,CAAzB,EAA4B;AAC1B,MAAIc,GAAG,GAAG4C,IAAI,CAACC,GAAL,CAAS5D,CAAC,CAACN,MAAX,EAAmBO,CAAC,CAACP,MAArB,CAAV;;AACA,OAAK,IAAIsB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,GAApB,EAAyBC,CAAC,EAA1B,EAA8B;AAC5B,QAAI6C,IAAI,GAAG9D,OAAO,CAACC,CAAC,CAACgB,CAAD,CAAF,EAAOf,CAAC,CAACe,CAAD,CAAR,CAAlB;;AACA,QAAI6C,IAAI,KAAK,CAAb,EAAgB;AACd,aAAOA,IAAP;AACD;AACF;;AACD,SAAQ7D,CAAC,CAACN,MAAF,KAAaO,CAAC,CAACP,MAAhB,GAA0B,CAA1B,GACJM,CAAC,CAACN,MAAF,GAAWO,CAAC,CAACP,MAAd,GAAwB,CAAxB,GAA4B,CAAC,CAD/B;AAED;;AACD,SAASY,aAAT,CAAuBN,CAAvB,EAA0BC,CAA1B,EAA6B;AAC3B;AACA;AACA;AACA,SAAQD,CAAC,KAAKC,CAAP,GAAY,CAAZ,GAAkBD,CAAC,GAAGC,CAAL,GAAU,CAAV,GAAc,CAAC,CAAvC;AACD;;AACD,SAASS,aAAT,CAAuBV,CAAvB,EAA0BC,CAA1B,EAA6B;AAC3B,MAAI6D,EAAE,GAAGpC,MAAM,CAACC,IAAP,CAAY3B,CAAZ,CAAT;AAAA,MAAyB+D,EAAE,GAAGrC,MAAM,CAACC,IAAP,CAAY1B,CAAZ,CAA9B;AACA,MAAIc,GAAG,GAAG4C,IAAI,CAACC,GAAL,CAASE,EAAE,CAACpE,MAAZ,EAAoBqE,EAAE,CAACrE,MAAvB,CAAV;;AACA,OAAK,IAAIsB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,GAApB,EAAyBC,CAAC,EAA1B,EAA8B;AAC5B;AACA,QAAI6C,IAAI,GAAG9D,OAAO,CAAC+D,EAAE,CAAC9C,CAAD,CAAH,EAAQ+C,EAAE,CAAC/C,CAAD,CAAV,CAAlB;;AACA,QAAI6C,IAAI,KAAK,CAAb,EAAgB;AACd,aAAOA,IAAP;AACD,KAL2B,CAM5B;;;AACAA,IAAAA,IAAI,GAAG9D,OAAO,CAACC,CAAC,CAAC8D,EAAE,CAAC9C,CAAD,CAAH,CAAF,EAAWf,CAAC,CAAC8D,EAAE,CAAC/C,CAAD,CAAH,CAAZ,CAAd;;AACA,QAAI6C,IAAI,KAAK,CAAb,EAAgB;AACd,aAAOA,IAAP;AACD;AAEF;;AACD,SAAQC,EAAE,CAACpE,MAAH,KAAcqE,EAAE,CAACrE,MAAlB,GAA4B,CAA5B,GACJoE,EAAE,CAACpE,MAAH,GAAYqE,EAAE,CAACrE,MAAhB,GAA0B,CAA1B,GAA8B,CAAC,CADjC;AAED,C,CACD;AACA;AACA;AACA;;;AACA,SAASU,cAAT,CAAwB4D,CAAxB,EAA2B;AACzB,MAAIC,EAAE,GAAG,CAAC,SAAD,EAAY,QAAZ,EAAsB,QAAtB,EAAgC,QAAhC,CAAT;AACA,MAAIC,GAAG,GAAGD,EAAE,CAACE,OAAH,CAAW,OAAOH,CAAlB,CAAV,CAFyB,CAGzB;;AACA,MAAI,CAACE,GAAL,EAAU;AACR,QAAIF,CAAC,KAAK,IAAV,EAAgB;AACd,aAAO,CAAP;AACD;;AACD,QAAIzD,KAAK,CAACC,OAAN,CAAcwD,CAAd,CAAJ,EAAsB;AACpB,aAAO,CAAP;AACD;;AACD,WAAOE,GAAG,GAAG,CAAN,GAAWA,GAAG,GAAG,CAAjB,GAAuBA,GAAG,GAAG,CAApC;AACD;AACD;;;AACA,MAAI3D,KAAK,CAACC,OAAN,CAAcwD,CAAd,CAAJ,EAAsB;AACpB,WAAO,CAAP;AACD;AACF,C,CAED;AACA;AACA;AACA;AACA;;;AACA,SAASzC,oBAAT,CAA8BW,GAA9B,EAAmC;AAEjC,MAAIA,GAAG,KAAK,CAAZ,EAAe;AACb,WAAO,GAAP;AACD,GAJgC,CAMjC;AACA;;;AACA,MAAIkC,SAAS,GAAGlC,GAAG,CAACmC,aAAJ,GAAoB3B,KAApB,CAA0B,MAA1B,CAAhB;AACA,MAAIH,SAAS,GAAGC,QAAQ,CAAC4B,SAAS,CAAC,CAAD,CAAV,EAAe,EAAf,CAAxB;AAEA,MAAIjC,GAAG,GAAGD,GAAG,GAAG,CAAhB;AAEA,MAAIN,MAAM,GAAGO,GAAG,GAAG,GAAH,GAAS,GAAzB,CAbiC,CAejC;AACA;;AACA,MAAImC,gBAAgB,GAAI,CAACnC,GAAG,GAAG,CAACI,SAAJ,GAAgBA,SAApB,IAAiC3C,aAAzD;AACA,MAAI2E,SAAS,GAAG5E,OAAO,CAAE2E,gBAAD,CAAmBE,QAAnB,EAAD,EAAgC,GAAhC,EAAqC3E,gBAArC,CAAvB;AAEA+B,EAAAA,MAAM,IAAI9B,GAAG,GAAGyE,SAAhB,CApBiC,CAsBjC;;AACA,MAAIE,MAAM,GAAGd,IAAI,CAACe,GAAL,CAAS/B,UAAU,CAACyB,SAAS,CAAC,CAAD,CAAV,CAAnB,CAAb,CAvBiC,CAuBgB;;AACjD;;AACA,MAAIjC,GAAJ,EAAS;AAAE;AACTsC,IAAAA,MAAM,GAAG,KAAKA,MAAd;AACD;;AAED,MAAIE,SAAS,GAAGF,MAAM,CAACG,OAAP,CAAe,EAAf,CAAhB,CA7BiC,CA+BjC;;AACAD,EAAAA,SAAS,GAAGA,SAAS,CAACnD,OAAV,CAAkB,QAAlB,EAA4B,EAA5B,CAAZ;AAEAI,EAAAA,MAAM,IAAI9B,GAAG,GAAG6E,SAAhB;AAEA,SAAO/C,MAAP;AACD;;AAED,SAAS7B,OAAT,EAAkBG,YAAlB,EAAgC2B,iBAAhC,EAAmDwB,oBAAnD","sourcesContent":["function pad(str, padWith, upToLength) {\n  var padding = '';\n  var targetLength = upToLength - str.length;\n  /* istanbul ignore next */\n  while (padding.length < targetLength) {\n    padding += padWith;\n  }\n  return padding;\n}\n\nfunction padLeft(str, padWith, upToLength) {\n  var padding = pad(str, padWith, upToLength);\n  return padding + str;\n}\n\nvar MIN_MAGNITUDE = -324; // verified by -Number.MIN_VALUE\nvar MAGNITUDE_DIGITS = 3; // ditto\nvar SEP = ''; // set to '_' for easier debugging \n\nfunction collate(a, b) {\n\n  if (a === b) {\n    return 0;\n  }\n\n  a = normalizeKey(a);\n  b = normalizeKey(b);\n\n  var ai = collationIndex(a);\n  var bi = collationIndex(b);\n  if ((ai - bi) !== 0) {\n    return ai - bi;\n  }\n  switch (typeof a) {\n    case 'number':\n      return a - b;\n    case 'boolean':\n      return a < b ? -1 : 1;\n    case 'string':\n      return stringCollate(a, b);\n  }\n  return Array.isArray(a) ? arrayCollate(a, b) : objectCollate(a, b);\n}\n\n// couch considers null/NaN/Infinity/-Infinity === undefined,\n// for the purposes of mapreduce indexes. also, dates get stringified.\nfunction normalizeKey(key) {\n  switch (typeof key) {\n    case 'undefined':\n      return null;\n    case 'number':\n      if (key === Infinity || key === -Infinity || isNaN(key)) {\n        return null;\n      }\n      return key;\n    case 'object':\n      var origKey = key;\n      if (Array.isArray(key)) {\n        var len = key.length;\n        key = new Array(len);\n        for (var i = 0; i < len; i++) {\n          key[i] = normalizeKey(origKey[i]);\n        }\n      /* istanbul ignore next */\n      } else if (key instanceof Date) {\n        return key.toJSON();\n      } else if (key !== null) { // generic object\n        key = {};\n        for (var k in origKey) {\n          if (origKey.hasOwnProperty(k)) {\n            var val = origKey[k];\n            if (typeof val !== 'undefined') {\n              key[k] = normalizeKey(val);\n            }\n          }\n        }\n      }\n  }\n  return key;\n}\n\nfunction indexify(key) {\n  if (key !== null) {\n    switch (typeof key) {\n      case 'boolean':\n        return key ? 1 : 0;\n      case 'number':\n        return numToIndexableString(key);\n      case 'string':\n        // We've to be sure that key does not contain \\u0000\n        // Do order-preserving replacements:\n        // 0 -> 1, 1\n        // 1 -> 1, 2\n        // 2 -> 2, 2\n        /* eslint-disable no-control-regex */\n        return key\n          .replace(/\\u0002/g, '\\u0002\\u0002')\n          .replace(/\\u0001/g, '\\u0001\\u0002')\n          .replace(/\\u0000/g, '\\u0001\\u0001');\n        /* eslint-enable no-control-regex */\n      case 'object':\n        var isArray = Array.isArray(key);\n        var arr = isArray ? key : Object.keys(key);\n        var i = -1;\n        var len = arr.length;\n        var result = '';\n        if (isArray) {\n          while (++i < len) {\n            result += toIndexableString(arr[i]);\n          }\n        } else {\n          while (++i < len) {\n            var objKey = arr[i];\n            result += toIndexableString(objKey) +\n                toIndexableString(key[objKey]);\n          }\n        }\n        return result;\n    }\n  }\n  return '';\n}\n\n// convert the given key to a string that would be appropriate\n// for lexical sorting, e.g. within a database, where the\n// sorting is the same given by the collate() function.\nfunction toIndexableString(key) {\n  var zero = '\\u0000';\n  key = normalizeKey(key);\n  return collationIndex(key) + SEP + indexify(key) + zero;\n}\n\nfunction parseNumber(str, i) {\n  var originalIdx = i;\n  var num;\n  var zero = str[i] === '1';\n  if (zero) {\n    num = 0;\n    i++;\n  } else {\n    var neg = str[i] === '0';\n    i++;\n    var numAsString = '';\n    var magAsString = str.substring(i, i + MAGNITUDE_DIGITS);\n    var magnitude = parseInt(magAsString, 10) + MIN_MAGNITUDE;\n    /* istanbul ignore next */\n    if (neg) {\n      magnitude = -magnitude;\n    }\n    i += MAGNITUDE_DIGITS;\n    while (true) {\n      var ch = str[i];\n      if (ch === '\\u0000') {\n        break;\n      } else {\n        numAsString += ch;\n      }\n      i++;\n    }\n    numAsString = numAsString.split('.');\n    if (numAsString.length === 1) {\n      num = parseInt(numAsString, 10);\n    } else {\n      /* istanbul ignore next */\n      num = parseFloat(numAsString[0] + '.' + numAsString[1]);\n    }\n    /* istanbul ignore next */\n    if (neg) {\n      num = num - 10;\n    }\n    /* istanbul ignore next */\n    if (magnitude !== 0) {\n      // parseFloat is more reliable than pow due to rounding errors\n      // e.g. Number.MAX_VALUE would return Infinity if we did\n      // num * Math.pow(10, magnitude);\n      num = parseFloat(num + 'e' + magnitude);\n    }\n  }\n  return {num: num, length : i - originalIdx};\n}\n\n// move up the stack while parsing\n// this function moved outside of parseIndexableString for performance\nfunction pop(stack, metaStack) {\n  var obj = stack.pop();\n\n  if (metaStack.length) {\n    var lastMetaElement = metaStack[metaStack.length - 1];\n    if (obj === lastMetaElement.element) {\n      // popping a meta-element, e.g. an object whose value is another object\n      metaStack.pop();\n      lastMetaElement = metaStack[metaStack.length - 1];\n    }\n    var element = lastMetaElement.element;\n    var lastElementIndex = lastMetaElement.index;\n    if (Array.isArray(element)) {\n      element.push(obj);\n    } else if (lastElementIndex === stack.length - 2) { // obj with key+value\n      var key = stack.pop();\n      element[key] = obj;\n    } else {\n      stack.push(obj); // obj with key only\n    }\n  }\n}\n\nfunction parseIndexableString(str) {\n  var stack = [];\n  var metaStack = []; // stack for arrays and objects\n  var i = 0;\n\n  /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n  while (true) {\n    var collationIndex = str[i++];\n    if (collationIndex === '\\u0000') {\n      if (stack.length === 1) {\n        return stack.pop();\n      } else {\n        pop(stack, metaStack);\n        continue;\n      }\n    }\n    switch (collationIndex) {\n      case '1':\n        stack.push(null);\n        break;\n      case '2':\n        stack.push(str[i] === '1');\n        i++;\n        break;\n      case '3':\n        var parsedNum = parseNumber(str, i);\n        stack.push(parsedNum.num);\n        i += parsedNum.length;\n        break;\n      case '4':\n        var parsedStr = '';\n        /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n        while (true) {\n          var ch = str[i];\n          if (ch === '\\u0000') {\n            break;\n          }\n          parsedStr += ch;\n          i++;\n        }\n        // perform the reverse of the order-preserving replacement\n        // algorithm (see above)\n        /* eslint-disable no-control-regex */\n        parsedStr = parsedStr.replace(/\\u0001\\u0001/g, '\\u0000')\n          .replace(/\\u0001\\u0002/g, '\\u0001')\n          .replace(/\\u0002\\u0002/g, '\\u0002');\n        /* eslint-enable no-control-regex */\n        stack.push(parsedStr);\n        break;\n      case '5':\n        var arrayElement = { element: [], index: stack.length };\n        stack.push(arrayElement.element);\n        metaStack.push(arrayElement);\n        break;\n      case '6':\n        var objElement = { element: {}, index: stack.length };\n        stack.push(objElement.element);\n        metaStack.push(objElement);\n        break;\n      /* istanbul ignore next */\n      default:\n        throw new Error(\n          'bad collationIndex or unexpectedly reached end of input: ' +\n            collationIndex);\n    }\n  }\n}\n\nfunction arrayCollate(a, b) {\n  var len = Math.min(a.length, b.length);\n  for (var i = 0; i < len; i++) {\n    var sort = collate(a[i], b[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n  }\n  return (a.length === b.length) ? 0 :\n    (a.length > b.length) ? 1 : -1;\n}\nfunction stringCollate(a, b) {\n  // See: https://github.com/daleharvey/pouchdb/issues/40\n  // This is incompatible with the CouchDB implementation, but its the\n  // best we can do for now\n  return (a === b) ? 0 : ((a > b) ? 1 : -1);\n}\nfunction objectCollate(a, b) {\n  var ak = Object.keys(a), bk = Object.keys(b);\n  var len = Math.min(ak.length, bk.length);\n  for (var i = 0; i < len; i++) {\n    // First sort the keys\n    var sort = collate(ak[i], bk[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n    // if the keys are equal sort the values\n    sort = collate(a[ak[i]], b[bk[i]]);\n    if (sort !== 0) {\n      return sort;\n    }\n\n  }\n  return (ak.length === bk.length) ? 0 :\n    (ak.length > bk.length) ? 1 : -1;\n}\n// The collation is defined by erlangs ordered terms\n// the atoms null, true, false come first, then numbers, strings,\n// arrays, then objects\n// null/undefined/NaN/Infinity/-Infinity are all considered null\nfunction collationIndex(x) {\n  var id = ['boolean', 'number', 'string', 'object'];\n  var idx = id.indexOf(typeof x);\n  //false if -1 otherwise true, but fast!!!!1\n  if (~idx) {\n    if (x === null) {\n      return 1;\n    }\n    if (Array.isArray(x)) {\n      return 5;\n    }\n    return idx < 3 ? (idx + 2) : (idx + 3);\n  }\n  /* istanbul ignore next */\n  if (Array.isArray(x)) {\n    return 5;\n  }\n}\n\n// conversion:\n// x yyy zz...zz\n// x = 0 for negative, 1 for 0, 2 for positive\n// y = exponent (for negative numbers negated) moved so that it's >= 0\n// z = mantisse\nfunction numToIndexableString(num) {\n\n  if (num === 0) {\n    return '1';\n  }\n\n  // convert number to exponential format for easier and\n  // more succinct string sorting\n  var expFormat = num.toExponential().split(/e\\+?/);\n  var magnitude = parseInt(expFormat[1], 10);\n\n  var neg = num < 0;\n\n  var result = neg ? '0' : '2';\n\n  // first sort by magnitude\n  // it's easier if all magnitudes are positive\n  var magForComparison = ((neg ? -magnitude : magnitude) - MIN_MAGNITUDE);\n  var magString = padLeft((magForComparison).toString(), '0', MAGNITUDE_DIGITS);\n\n  result += SEP + magString;\n\n  // then sort by the factor\n  var factor = Math.abs(parseFloat(expFormat[0])); // [1..10)\n  /* istanbul ignore next */\n  if (neg) { // for negative reverse ordering\n    factor = 10 - factor;\n  }\n\n  var factorStr = factor.toFixed(20);\n\n  // strip zeros from the end\n  factorStr = factorStr.replace(/\\.?0+$/, '');\n\n  result += SEP + factorStr;\n\n  return result;\n}\n\nexport { collate, normalizeKey, toIndexableString, parseIndexableString };\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inheritsLoose from \"@babel/runtime/helpers/inheritsLoose\";\n/**\n * This plugin adds RxCollection.inMemory()\n * Which replicates the collection into an in-memory-collection\n * So you can do faster queries and also query over encrypted fields.\n * Writes will still run on the original collection\n */\n\nimport { Subject, fromEvent as ObservableFromEvent } from 'rxjs';\nimport { filter, map, mergeMap, first, delay } from 'rxjs/operators';\nimport { RxCollectionBase } from '../rx-collection';\nimport { clone, randomCouchString } from '../util';\nimport { addRxPlugin } from '../core';\nimport { createCrypter } from '../crypter';\nimport { createChangeEventBuffer } from '../change-event-buffer';\nimport { createRxSchema } from '../rx-schema';\nimport { PouchDB } from '../pouch-db';\nimport { newRxError } from '../rx-error';\nimport { getRxStoragePouchDb } from '../rx-storage-pouchdb'; // add the watch-for-changes-plugin\n\nimport { RxDBWatchForChangesPlugin } from '../plugins/watch-for-changes';\naddRxPlugin(RxDBWatchForChangesPlugin);\nvar collectionCacheMap = new WeakMap();\nvar collectionPromiseCacheMap = new WeakMap();\nvar BULK_DOC_OPTIONS = {\n  new_edits: true\n};\nvar BULK_DOC_OPTIONS_FALSE = {\n  new_edits: false\n};\nexport var InMemoryRxCollection =\n/*#__PURE__*/\nfunction (_RxCollectionBase) {\n  _inheritsLoose(InMemoryRxCollection, _RxCollectionBase);\n\n  function InMemoryRxCollection(parentCollection) {\n    var _this;\n\n    var pouchSettings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _this = _RxCollectionBase.call(this, parentCollection.database, parentCollection.name, toCleanSchema(parentCollection.schema), pouchSettings, // pouchSettings\n    {}, parentCollection._methods) || this;\n    _this._eventCounter = 0;\n    _this._isInMemory = true;\n    _this._parentCollection = parentCollection;\n\n    _this._parentCollection.onDestroy.then(function () {\n      return _this.destroy();\n    });\n\n    _this._crypter = createCrypter(_this.database.password, _this.schema);\n    _this._changeStreams = [];\n    /**\n     * runs on parentCollection.destroy()\n     * Cleans up everything to free up memory\n     */\n\n    _this.onDestroy.then(function () {\n      _this._changeStreams.forEach(function (stream) {\n        return stream.cancel();\n      });\n\n      _this.pouch.destroy();\n    }); // add orm functions and options from parent\n\n\n    _this.options = parentCollection.options;\n    Object.entries(parentCollection.statics).forEach(function (_ref) {\n      var funName = _ref[0],\n          fun = _ref[1];\n      Object.defineProperty(_assertThisInitialized(_this), funName, {\n        get: function get() {\n          return fun.bind(_assertThisInitialized(_this));\n        }\n      });\n    });\n    var storage = getRxStoragePouchDb('memory');\n    _this.pouch = storage.createStorageInstance('rxdb-in-memory', randomCouchString(10), 0);\n    _this._observable$ = new Subject();\n    _this._changeEventBuffer = createChangeEventBuffer(_assertThisInitialized(_this));\n    var parentProto = Object.getPrototypeOf(parentCollection);\n    _this._oldPouchPut = parentProto._pouchPut.bind(_assertThisInitialized(_this));\n    _this._nonPersistentRevisions = new Set();\n    _this._nonPersistentRevisionsSubject = new Subject(); // emits Set.size() when Set is changed\n\n    return _this;\n  }\n\n  var _proto = InMemoryRxCollection.prototype;\n\n  _proto.prepareChild = function prepareChild() {\n    var _this2 = this;\n\n    return setIndexes(this.schema, this.pouch).then(function () {\n      _this2._subs.push(_this2._observable$.subscribe(function (cE) {\n        // when data changes, send it to RxDocument in docCache\n        var doc = _this2._docCache.get(cE.documentId);\n\n        if (doc) doc._handleChangeEvent(cE);\n      }));\n    }) // initial sync parent's docs to own\n    .then(function () {\n      return replicateExistingDocuments(_this2._parentCollection, _this2);\n    }).then(function () {\n      /**\n       * call watchForChanges() on both sides,\n       * to ensure none-rxdb-changes like replication\n       * will fire into the change-event-stream\n       */\n      _this2._parentCollection.watchForChanges();\n\n      _this2.watchForChanges();\n      /**\n       * create an ongoing replications between both sides\n       */\n\n\n      var thisToParentSub = streamChangedDocuments(_this2).pipe(mergeMap(function (doc) {\n        return applyChangedDocumentToPouch(_this2._parentCollection, doc).then(function () {\n          return doc['_rev'];\n        });\n      })).subscribe(function (changeRev) {\n        _this2._nonPersistentRevisions[\"delete\"](changeRev);\n\n        _this2._nonPersistentRevisionsSubject.next(_this2._nonPersistentRevisions.size);\n      });\n\n      _this2._subs.push(thisToParentSub);\n\n      var parentToThisSub = streamChangedDocuments(_this2._parentCollection).subscribe(function (doc) {\n        return applyChangedDocumentToPouch(_this2, doc);\n      });\n\n      _this2._subs.push(parentToThisSub);\n    });\n  }\n  /**\n   * waits until all writes are persistent\n   * in the parent collection\n   */\n  ;\n\n  _proto.awaitPersistence = function awaitPersistence() {\n    var _this3 = this;\n\n    if (this._nonPersistentRevisions.size === 0) return Promise.resolve();\n    return this._nonPersistentRevisionsSubject.pipe(filter(function () {\n      return _this3._nonPersistentRevisions.size === 0;\n    }), first()).toPromise();\n  }\n  /**\n   * To know which events are replicated and which are not,\n   * the _pouchPut is wrapped\n   * @overwrite\n   */\n  ;\n\n  _proto._pouchPut = function _pouchPut(obj, overwrite) {\n    var _this4 = this;\n\n    return this._oldPouchPut(obj, overwrite).then(function (ret) {\n      _this4._nonPersistentRevisions.add(ret.rev);\n\n      return ret;\n    });\n  };\n\n  _proto.$emit = function $emit(changeEvent) {\n    if (this._changeEventBuffer.hasChangeWithRevision(changeEvent.documentData && changeEvent.documentData._rev)) {\n      return;\n    }\n\n    this._observable$.next(changeEvent); // run compaction each 10 events\n\n\n    this._eventCounter++;\n\n    if (this._eventCounter === 10) {\n      this._eventCounter = 0;\n      this.pouch.compact();\n    }\n  }\n  /**\n   * @overwrite\n   * Replication on the inMemory is dangerous,\n   * replicate with it's parent instead\n   */\n  ;\n\n  _proto.sync = function sync() {\n    throw newRxError('IM2');\n  };\n\n  return InMemoryRxCollection;\n}(RxCollectionBase);\n/**\n * returns a version of the schema that:\n * - disabled the keyCompression\n * - has no encryption\n * - has no attachments\n */\n\nfunction toCleanSchema(rxSchema) {\n  var newSchemaJson = clone(rxSchema.jsonSchema);\n  newSchemaJson.keyCompression = false;\n  delete newSchemaJson.properties._id;\n  delete newSchemaJson.properties._rev;\n  delete newSchemaJson.properties._attachments;\n\n  var removeEncryption = function removeEncryption(schema, complete) {\n    delete schema.encrypted;\n    Object.values(schema).filter(function (val) {\n      return typeof val === 'object';\n    }).forEach(function (val) {\n      return removeEncryption(val, complete);\n    });\n  };\n\n  removeEncryption(newSchemaJson, newSchemaJson);\n  return createRxSchema(newSchemaJson);\n}\n/**\n * replicates all documents from the parent to the inMemoryCollection\n * @return Promise that resolves with an array of the docs data\n */\n\n\nexport function replicateExistingDocuments(fromCollection, toCollection) {\n  return fromCollection.pouch.allDocs({\n    attachments: false,\n    include_docs: true\n  }).then(function (allRows) {\n    var docs = allRows.rows.map(function (row) {\n      return row.doc;\n    }).filter(function (doc) {\n      return !doc.language;\n    }) // do not replicate design-docs\n    .map(function (doc) {\n      return fromCollection._handleFromPouch(doc);\n    }) // swap back primary because keyCompression:false\n    .map(function (doc) {\n      return fromCollection.schema.swapPrimaryToId(doc);\n    });\n    if (docs.length === 0) return Promise.resolve([]); // nothing to replicate\n    else {\n        return toCollection.pouch.bulkDocs({\n          docs: docs\n        }, BULK_DOC_OPTIONS_FALSE).then(function () {\n          return docs;\n        });\n      }\n  });\n}\n/**\n * sets the indexes from the schema at the pouchdb\n */\n\nexport function setIndexes(schema, pouch) {\n  return Promise.all(schema.indexes.map(function (indexAr) {\n    var indexName = 'idx-rxdb-' + indexAr.join(',');\n    return pouch.createIndex({\n      ddoc: indexName,\n      name: indexName,\n      index: {\n        fields: indexAr\n      }\n    });\n  }));\n}\n/**\n * returns an observable that streams all changes\n * as plain documents that have no encryption or keyCompression.\n * We use this to replicate changes from one collection to the other\n * @param prevFilter can be used to filter changes before doing anything\n * @return observable that emits document-data\n */\n\nexport function streamChangedDocuments(rxCollection) {\n  var prevFilter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (_i) {\n    return true;\n  };\n  if (!rxCollection._doNotEmitSet) rxCollection._doNotEmitSet = new Set();\n  var observable = ObservableFromEvent(rxCollection.pouch.changes({\n    since: 'now',\n    live: true,\n    include_docs: true\n  }), 'change').pipe(\n  /**\n   * we need this delay because with pouchdb 7.2.2\n   * it happened that _doNotEmitSet.add() from applyChangedDocumentToPouch()\n   * was called after the change was streamed downwards\n   * which then leads to a wrong detection\n   */\n  delay(0), map(function (changeAr) {\n    return changeAr[0];\n  }), // rxjs emits an array for whatever reason\n  filter(function (change) {\n    // changes on the doNotEmit-list shell not be fired\n    var emitFlag = change.id + ':' + change.doc._rev;\n    if (rxCollection._doNotEmitSet.has(emitFlag)) return false;else return true;\n  }), filter(function (change) {\n    return prevFilter(change);\n  }), map(function (change) {\n    return rxCollection._handleFromPouch(change.doc);\n  }));\n  return observable;\n}\n/**\n * writes the doc-data into the pouchdb of the collection\n * without changeing the revision\n */\n\nexport function applyChangedDocumentToPouch(rxCollection, docData) {\n  if (!rxCollection._doNotEmitSet) rxCollection._doNotEmitSet = new Set();\n\n  var transformedDoc = rxCollection._handleToPouch(docData);\n\n  return rxCollection.pouch.get(transformedDoc._id).then(function (oldDoc) {\n    return transformedDoc._rev = oldDoc._rev;\n  })[\"catch\"](function () {\n    // doc not found, do not use a revision\n    delete transformedDoc._rev;\n  }).then(function () {\n    return rxCollection.pouch.bulkDocs({\n      docs: [transformedDoc]\n    }, BULK_DOC_OPTIONS);\n  }).then(function (bulkRet) {\n    if (bulkRet.length > 0 && !bulkRet[0].ok) {\n      throw new Error(JSON.stringify(bulkRet[0]));\n    } // set the flag so this does not appear in the own event-stream again\n\n\n    var emitFlag = transformedDoc._id + ':' + bulkRet[0].rev;\n\n    rxCollection._doNotEmitSet.add(emitFlag); // remove from the list later to not have a memory-leak\n\n\n    setTimeout(function () {\n      return rxCollection._doNotEmitSet[\"delete\"](emitFlag);\n    }, 30 * 1000);\n    return transformedDoc;\n  });\n}\nvar INIT_DONE = false;\n/**\n * called in the proto of RxCollection\n */\n\nexport function spawnInMemory() {\n  var _this5 = this;\n\n  if (!INIT_DONE) {\n    INIT_DONE = true; // ensure memory-adapter is added\n\n    if (!PouchDB.adapters || !PouchDB.adapters.memory) throw newRxError('IM1');\n  }\n\n  if (collectionCacheMap.has(this)) {\n    // already exists for this collection -> wait until synced\n    return collectionPromiseCacheMap.get(this).then(function () {\n      return collectionCacheMap.get(_this5);\n    });\n  }\n\n  var col = new InMemoryRxCollection(this);\n  var preparePromise = col.prepareChild();\n  collectionCacheMap.set(this, col);\n  collectionPromiseCacheMap.set(this, preparePromise);\n  return preparePromise.then(function () {\n    return col;\n  });\n}\nexport var rxdb = true;\nexport var prototypes = {\n  RxCollection: function RxCollection(proto) {\n    proto.inMemory = spawnInMemory;\n  }\n};\nexport var RxDBInMemoryPlugin = {\n  name: 'in-memory',\n  rxdb: rxdb,\n  prototypes: prototypes\n};","map":{"version":3,"sources":["/Users/Hanzalah/Desktop/github/todo-offline/rxdb-hasura-demo/node_modules/rxdb/dist/es/plugins/in-memory.js"],"names":["_assertThisInitialized","_inheritsLoose","Subject","fromEvent","ObservableFromEvent","filter","map","mergeMap","first","delay","RxCollectionBase","clone","randomCouchString","addRxPlugin","createCrypter","createChangeEventBuffer","createRxSchema","PouchDB","newRxError","getRxStoragePouchDb","RxDBWatchForChangesPlugin","collectionCacheMap","WeakMap","collectionPromiseCacheMap","BULK_DOC_OPTIONS","new_edits","BULK_DOC_OPTIONS_FALSE","InMemoryRxCollection","_RxCollectionBase","parentCollection","_this","pouchSettings","arguments","length","undefined","call","database","name","toCleanSchema","schema","_methods","_eventCounter","_isInMemory","_parentCollection","onDestroy","then","destroy","_crypter","password","_changeStreams","forEach","stream","cancel","pouch","options","Object","entries","statics","_ref","funName","fun","defineProperty","get","bind","storage","createStorageInstance","_observable$","_changeEventBuffer","parentProto","getPrototypeOf","_oldPouchPut","_pouchPut","_nonPersistentRevisions","Set","_nonPersistentRevisionsSubject","_proto","prototype","prepareChild","_this2","setIndexes","_subs","push","subscribe","cE","doc","_docCache","documentId","_handleChangeEvent","replicateExistingDocuments","watchForChanges","thisToParentSub","streamChangedDocuments","pipe","applyChangedDocumentToPouch","changeRev","next","size","parentToThisSub","awaitPersistence","_this3","Promise","resolve","toPromise","obj","overwrite","_this4","ret","add","rev","$emit","changeEvent","hasChangeWithRevision","documentData","_rev","compact","sync","rxSchema","newSchemaJson","jsonSchema","keyCompression","properties","_id","_attachments","removeEncryption","complete","encrypted","values","val","fromCollection","toCollection","allDocs","attachments","include_docs","allRows","docs","rows","row","language","_handleFromPouch","swapPrimaryToId","bulkDocs","all","indexes","indexAr","indexName","join","createIndex","ddoc","index","fields","rxCollection","prevFilter","_i","_doNotEmitSet","observable","changes","since","live","changeAr","change","emitFlag","id","has","docData","transformedDoc","_handleToPouch","oldDoc","bulkRet","ok","Error","JSON","stringify","setTimeout","INIT_DONE","spawnInMemory","_this5","adapters","memory","col","preparePromise","set","rxdb","prototypes","RxCollection","proto","inMemory","RxDBInMemoryPlugin"],"mappings":"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","sourcesContent":["import _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inheritsLoose from \"@babel/runtime/helpers/inheritsLoose\";\n\n/**\n * This plugin adds RxCollection.inMemory()\n * Which replicates the collection into an in-memory-collection\n * So you can do faster queries and also query over encrypted fields.\n * Writes will still run on the original collection\n */\nimport { Subject, fromEvent as ObservableFromEvent } from 'rxjs';\nimport { filter, map, mergeMap, first, delay } from 'rxjs/operators';\nimport { RxCollectionBase } from '../rx-collection';\nimport { clone, randomCouchString } from '../util';\nimport { addRxPlugin } from '../core';\nimport { createCrypter } from '../crypter';\nimport { createChangeEventBuffer } from '../change-event-buffer';\nimport { createRxSchema } from '../rx-schema';\nimport { PouchDB } from '../pouch-db';\nimport { newRxError } from '../rx-error';\nimport { getRxStoragePouchDb } from '../rx-storage-pouchdb'; // add the watch-for-changes-plugin\n\nimport { RxDBWatchForChangesPlugin } from '../plugins/watch-for-changes';\naddRxPlugin(RxDBWatchForChangesPlugin);\nvar collectionCacheMap = new WeakMap();\nvar collectionPromiseCacheMap = new WeakMap();\nvar BULK_DOC_OPTIONS = {\n  new_edits: true\n};\nvar BULK_DOC_OPTIONS_FALSE = {\n  new_edits: false\n};\nexport var InMemoryRxCollection = /*#__PURE__*/function (_RxCollectionBase) {\n  _inheritsLoose(InMemoryRxCollection, _RxCollectionBase);\n\n  function InMemoryRxCollection(parentCollection) {\n    var _this;\n\n    var pouchSettings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _this = _RxCollectionBase.call(this, parentCollection.database, parentCollection.name, toCleanSchema(parentCollection.schema), pouchSettings, // pouchSettings\n    {}, parentCollection._methods) || this;\n    _this._eventCounter = 0;\n    _this._isInMemory = true;\n    _this._parentCollection = parentCollection;\n\n    _this._parentCollection.onDestroy.then(function () {\n      return _this.destroy();\n    });\n\n    _this._crypter = createCrypter(_this.database.password, _this.schema);\n    _this._changeStreams = [];\n    /**\n     * runs on parentCollection.destroy()\n     * Cleans up everything to free up memory\n     */\n\n    _this.onDestroy.then(function () {\n      _this._changeStreams.forEach(function (stream) {\n        return stream.cancel();\n      });\n\n      _this.pouch.destroy();\n    }); // add orm functions and options from parent\n\n\n    _this.options = parentCollection.options;\n    Object.entries(parentCollection.statics).forEach(function (_ref) {\n      var funName = _ref[0],\n          fun = _ref[1];\n      Object.defineProperty(_assertThisInitialized(_this), funName, {\n        get: function get() {\n          return fun.bind(_assertThisInitialized(_this));\n        }\n      });\n    });\n    var storage = getRxStoragePouchDb('memory');\n    _this.pouch = storage.createStorageInstance('rxdb-in-memory', randomCouchString(10), 0);\n    _this._observable$ = new Subject();\n    _this._changeEventBuffer = createChangeEventBuffer(_assertThisInitialized(_this));\n    var parentProto = Object.getPrototypeOf(parentCollection);\n    _this._oldPouchPut = parentProto._pouchPut.bind(_assertThisInitialized(_this));\n    _this._nonPersistentRevisions = new Set();\n    _this._nonPersistentRevisionsSubject = new Subject(); // emits Set.size() when Set is changed\n\n    return _this;\n  }\n\n  var _proto = InMemoryRxCollection.prototype;\n\n  _proto.prepareChild = function prepareChild() {\n    var _this2 = this;\n\n    return setIndexes(this.schema, this.pouch).then(function () {\n      _this2._subs.push(_this2._observable$.subscribe(function (cE) {\n        // when data changes, send it to RxDocument in docCache\n        var doc = _this2._docCache.get(cE.documentId);\n\n        if (doc) doc._handleChangeEvent(cE);\n      }));\n    }) // initial sync parent's docs to own\n    .then(function () {\n      return replicateExistingDocuments(_this2._parentCollection, _this2);\n    }).then(function () {\n      /**\n       * call watchForChanges() on both sides,\n       * to ensure none-rxdb-changes like replication\n       * will fire into the change-event-stream\n       */\n      _this2._parentCollection.watchForChanges();\n\n      _this2.watchForChanges();\n      /**\n       * create an ongoing replications between both sides\n       */\n\n\n      var thisToParentSub = streamChangedDocuments(_this2).pipe(mergeMap(function (doc) {\n        return applyChangedDocumentToPouch(_this2._parentCollection, doc).then(function () {\n          return doc['_rev'];\n        });\n      })).subscribe(function (changeRev) {\n        _this2._nonPersistentRevisions[\"delete\"](changeRev);\n\n        _this2._nonPersistentRevisionsSubject.next(_this2._nonPersistentRevisions.size);\n      });\n\n      _this2._subs.push(thisToParentSub);\n\n      var parentToThisSub = streamChangedDocuments(_this2._parentCollection).subscribe(function (doc) {\n        return applyChangedDocumentToPouch(_this2, doc);\n      });\n\n      _this2._subs.push(parentToThisSub);\n    });\n  }\n  /**\n   * waits until all writes are persistent\n   * in the parent collection\n   */\n  ;\n\n  _proto.awaitPersistence = function awaitPersistence() {\n    var _this3 = this;\n\n    if (this._nonPersistentRevisions.size === 0) return Promise.resolve();\n    return this._nonPersistentRevisionsSubject.pipe(filter(function () {\n      return _this3._nonPersistentRevisions.size === 0;\n    }), first()).toPromise();\n  }\n  /**\n   * To know which events are replicated and which are not,\n   * the _pouchPut is wrapped\n   * @overwrite\n   */\n  ;\n\n  _proto._pouchPut = function _pouchPut(obj, overwrite) {\n    var _this4 = this;\n\n    return this._oldPouchPut(obj, overwrite).then(function (ret) {\n      _this4._nonPersistentRevisions.add(ret.rev);\n\n      return ret;\n    });\n  };\n\n  _proto.$emit = function $emit(changeEvent) {\n    if (this._changeEventBuffer.hasChangeWithRevision(changeEvent.documentData && changeEvent.documentData._rev)) {\n      return;\n    }\n\n    this._observable$.next(changeEvent); // run compaction each 10 events\n\n\n    this._eventCounter++;\n\n    if (this._eventCounter === 10) {\n      this._eventCounter = 0;\n      this.pouch.compact();\n    }\n  }\n  /**\n   * @overwrite\n   * Replication on the inMemory is dangerous,\n   * replicate with it's parent instead\n   */\n  ;\n\n  _proto.sync = function sync() {\n    throw newRxError('IM2');\n  };\n\n  return InMemoryRxCollection;\n}(RxCollectionBase);\n/**\n * returns a version of the schema that:\n * - disabled the keyCompression\n * - has no encryption\n * - has no attachments\n */\n\nfunction toCleanSchema(rxSchema) {\n  var newSchemaJson = clone(rxSchema.jsonSchema);\n  newSchemaJson.keyCompression = false;\n  delete newSchemaJson.properties._id;\n  delete newSchemaJson.properties._rev;\n  delete newSchemaJson.properties._attachments;\n\n  var removeEncryption = function removeEncryption(schema, complete) {\n    delete schema.encrypted;\n    Object.values(schema).filter(function (val) {\n      return typeof val === 'object';\n    }).forEach(function (val) {\n      return removeEncryption(val, complete);\n    });\n  };\n\n  removeEncryption(newSchemaJson, newSchemaJson);\n  return createRxSchema(newSchemaJson);\n}\n/**\n * replicates all documents from the parent to the inMemoryCollection\n * @return Promise that resolves with an array of the docs data\n */\n\n\nexport function replicateExistingDocuments(fromCollection, toCollection) {\n  return fromCollection.pouch.allDocs({\n    attachments: false,\n    include_docs: true\n  }).then(function (allRows) {\n    var docs = allRows.rows.map(function (row) {\n      return row.doc;\n    }).filter(function (doc) {\n      return !doc.language;\n    }) // do not replicate design-docs\n    .map(function (doc) {\n      return fromCollection._handleFromPouch(doc);\n    }) // swap back primary because keyCompression:false\n    .map(function (doc) {\n      return fromCollection.schema.swapPrimaryToId(doc);\n    });\n    if (docs.length === 0) return Promise.resolve([]); // nothing to replicate\n    else {\n        return toCollection.pouch.bulkDocs({\n          docs: docs\n        }, BULK_DOC_OPTIONS_FALSE).then(function () {\n          return docs;\n        });\n      }\n  });\n}\n/**\n * sets the indexes from the schema at the pouchdb\n */\n\nexport function setIndexes(schema, pouch) {\n  return Promise.all(schema.indexes.map(function (indexAr) {\n    var indexName = 'idx-rxdb-' + indexAr.join(',');\n    return pouch.createIndex({\n      ddoc: indexName,\n      name: indexName,\n      index: {\n        fields: indexAr\n      }\n    });\n  }));\n}\n/**\n * returns an observable that streams all changes\n * as plain documents that have no encryption or keyCompression.\n * We use this to replicate changes from one collection to the other\n * @param prevFilter can be used to filter changes before doing anything\n * @return observable that emits document-data\n */\n\nexport function streamChangedDocuments(rxCollection) {\n  var prevFilter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (_i) {\n    return true;\n  };\n  if (!rxCollection._doNotEmitSet) rxCollection._doNotEmitSet = new Set();\n  var observable = ObservableFromEvent(rxCollection.pouch.changes({\n    since: 'now',\n    live: true,\n    include_docs: true\n  }), 'change').pipe(\n  /**\n   * we need this delay because with pouchdb 7.2.2\n   * it happened that _doNotEmitSet.add() from applyChangedDocumentToPouch()\n   * was called after the change was streamed downwards\n   * which then leads to a wrong detection\n   */\n  delay(0), map(function (changeAr) {\n    return changeAr[0];\n  }), // rxjs emits an array for whatever reason\n  filter(function (change) {\n    // changes on the doNotEmit-list shell not be fired\n    var emitFlag = change.id + ':' + change.doc._rev;\n    if (rxCollection._doNotEmitSet.has(emitFlag)) return false;else return true;\n  }), filter(function (change) {\n    return prevFilter(change);\n  }), map(function (change) {\n    return rxCollection._handleFromPouch(change.doc);\n  }));\n  return observable;\n}\n/**\n * writes the doc-data into the pouchdb of the collection\n * without changeing the revision\n */\n\nexport function applyChangedDocumentToPouch(rxCollection, docData) {\n  if (!rxCollection._doNotEmitSet) rxCollection._doNotEmitSet = new Set();\n\n  var transformedDoc = rxCollection._handleToPouch(docData);\n\n  return rxCollection.pouch.get(transformedDoc._id).then(function (oldDoc) {\n    return transformedDoc._rev = oldDoc._rev;\n  })[\"catch\"](function () {\n    // doc not found, do not use a revision\n    delete transformedDoc._rev;\n  }).then(function () {\n    return rxCollection.pouch.bulkDocs({\n      docs: [transformedDoc]\n    }, BULK_DOC_OPTIONS);\n  }).then(function (bulkRet) {\n    if (bulkRet.length > 0 && !bulkRet[0].ok) {\n      throw new Error(JSON.stringify(bulkRet[0]));\n    } // set the flag so this does not appear in the own event-stream again\n\n\n    var emitFlag = transformedDoc._id + ':' + bulkRet[0].rev;\n\n    rxCollection._doNotEmitSet.add(emitFlag); // remove from the list later to not have a memory-leak\n\n\n    setTimeout(function () {\n      return rxCollection._doNotEmitSet[\"delete\"](emitFlag);\n    }, 30 * 1000);\n    return transformedDoc;\n  });\n}\nvar INIT_DONE = false;\n/**\n * called in the proto of RxCollection\n */\n\nexport function spawnInMemory() {\n  var _this5 = this;\n\n  if (!INIT_DONE) {\n    INIT_DONE = true; // ensure memory-adapter is added\n\n    if (!PouchDB.adapters || !PouchDB.adapters.memory) throw newRxError('IM1');\n  }\n\n  if (collectionCacheMap.has(this)) {\n    // already exists for this collection -> wait until synced\n    return collectionPromiseCacheMap.get(this).then(function () {\n      return collectionCacheMap.get(_this5);\n    });\n  }\n\n  var col = new InMemoryRxCollection(this);\n  var preparePromise = col.prepareChild();\n  collectionCacheMap.set(this, col);\n  collectionPromiseCacheMap.set(this, preparePromise);\n  return preparePromise.then(function () {\n    return col;\n  });\n}\nexport var rxdb = true;\nexport var prototypes = {\n  RxCollection: function RxCollection(proto) {\n    proto.inMemory = spawnInMemory;\n  }\n};\nexport var RxDBInMemoryPlugin = {\n  name: 'in-memory',\n  rxdb: rxdb,\n  prototypes: prototypes\n};\n//# sourceMappingURL=in-memory.js.map"]},"metadata":{},"sourceType":"module"}
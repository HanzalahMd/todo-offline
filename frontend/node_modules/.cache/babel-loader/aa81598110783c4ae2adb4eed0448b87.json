{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function next() {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nimport { AbstractNode } from './abstract-node';\nimport { Branches } from './branches';\nimport { lastOfArray, booleanToBooleanString } from './util';\nimport { bddToSimpleBdd } from './minimal-string';\n\nvar RootNode =\n/** @class */\nfunction (_super) {\n  __extends(RootNode, _super);\n\n  function RootNode() {\n    var _this = _super.call(this, 0, null, 'RootNode') || this;\n\n    _this.branches = new Branches(_this);\n    _this.levels = [];\n    _this.nodesByLevel = new Map();\n\n    _this.levels.push(0);\n\n    var level0Set = new Set();\n    level0Set.add(_this);\n\n    _this.nodesByLevel.set(0, level0Set);\n\n    return _this;\n  }\n\n  RootNode.prototype.addNode = function (node) {\n    var level = node.level;\n\n    if (!this.levels.includes(level)) {\n      this.levels.push(level);\n    }\n\n    this.ensureLevelSetExists(level);\n    var set = this.nodesByLevel.get(level);\n    set === null || set === void 0 ? void 0 : set.add(node);\n  };\n\n  RootNode.prototype.removeNode = function (node) {\n    var set = this.nodesByLevel.get(node.level);\n\n    if (!set.has(node)) {\n      throw new Error('removed non-existing node ' + node.id);\n    }\n\n    set.delete(node);\n  };\n\n  RootNode.prototype.ensureLevelSetExists = function (level) {\n    if (!this.nodesByLevel.has(level)) {\n      this.nodesByLevel.set(level, new Set());\n    }\n  };\n\n  RootNode.prototype.getLevels = function () {\n    return Array.from(this.levels).sort(function (a, b) {\n      return a - b;\n    });\n  };\n\n  RootNode.prototype.getNodesOfLevel = function (level) {\n    this.ensureLevelSetExists(level);\n    var set = this.nodesByLevel.get(level);\n    return Array.from(set);\n  };\n\n  RootNode.prototype.countNodes = function () {\n    var _this = this;\n\n    var ret = 0;\n    this.getLevels().forEach(function (level) {\n      var nodesAmount = _this.getNodesOfLevel(level).length;\n\n      ret = ret + nodesAmount;\n    });\n    return ret;\n  };\n  /**\n   * applies the reduction rules to the whole bdd\n   */\n\n\n  RootNode.prototype.minimize = function (logState) {\n    var e_1, _a;\n\n    if (logState === void 0) {\n      logState = false;\n    } // console.log('minimize(): START ###############');\n\n\n    var done = false;\n\n    while (!done) {\n      if (logState) {\n        console.log('minimize() itterate once');\n      }\n\n      var successCount = 0;\n      var lastLevel = lastOfArray(this.getLevels());\n\n      while (lastLevel > 0) {\n        var nodes = this.getNodesOfLevel(lastLevel);\n\n        if (logState) {\n          console.log('minimize() run for level ' + lastLevel + ' with ' + nodes.length + ' nodes'); // console.dir(nodes);\n        }\n\n        var nodeCount = 0;\n\n        try {\n          for (var nodes_1 = (e_1 = void 0, __values(nodes)), nodes_1_1 = nodes_1.next(); !nodes_1_1.done; nodes_1_1 = nodes_1.next()) {\n            var node = nodes_1_1.value;\n            nodeCount++; // do not run that often because it is expensive\n\n            if (logState && nodeCount % 4000 === 0) {\n              console.log('minimize() node #' + node.id);\n            }\n\n            if (node.isLeafNode()) {\n              // console.log('have leaf node ' + node.id);\n              var reductionDone = node.asLeafNode().applyEliminationRule();\n\n              if (reductionDone) {\n                successCount++;\n              }\n            }\n\n            if (!node.deleted && node.isInternalNode()) {\n              var useNode = node;\n              var reductionDone = useNode.applyReductionRule();\n              var eliminationDone = false;\n\n              if (!useNode.deleted) {\n                // not might now be deleted from reduction-rule\n                eliminationDone = useNode.applyEliminationRule(nodes);\n              }\n\n              if (reductionDone || eliminationDone) {\n                successCount++;\n              }\n            }\n          }\n        } catch (e_1_1) {\n          e_1 = {\n            error: e_1_1\n          };\n        } finally {\n          try {\n            if (nodes_1_1 && !nodes_1_1.done && (_a = nodes_1.return)) _a.call(nodes_1);\n          } finally {\n            if (e_1) throw e_1.error;\n          }\n        }\n\n        lastLevel--;\n      }\n\n      if (successCount === 0) {\n        // could do no more optimisations\n        done = true;\n      } else {\n        if (logState) {\n          console.log('minimize() itteration done with ' + successCount + ' minimisations');\n        }\n      }\n    }\n  };\n\n  RootNode.prototype.getLeafNodes = function () {\n    var lastLevel = lastOfArray(this.getLevels());\n    var leafNodes = this.getNodesOfLevel(lastLevel).reverse();\n    return leafNodes;\n  };\n  /**\n   * strips all leaf-nodes\n   * with the given value\n   */\n\n\n  RootNode.prototype.removeIrrelevantLeafNodes = function (leafNodeValue) {\n    var e_2, _a;\n\n    var done = false;\n\n    while (!done) {\n      var countRemoved = 0;\n      var leafNodes = this.getLeafNodes();\n\n      try {\n        for (var leafNodes_1 = (e_2 = void 0, __values(leafNodes)), leafNodes_1_1 = leafNodes_1.next(); !leafNodes_1_1.done; leafNodes_1_1 = leafNodes_1.next()) {\n          var leafNode = leafNodes_1_1.value;\n          var removed = leafNode.removeIfValueEquals(leafNodeValue);\n\n          if (removed) {\n            countRemoved++;\n          }\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (leafNodes_1_1 && !leafNodes_1_1.done && (_a = leafNodes_1.return)) _a.call(leafNodes_1);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n\n      this.minimize();\n\n      if (countRemoved === 0) {\n        done = true;\n      }\n    }\n  };\n\n  RootNode.prototype.resolve = function (fns, booleanFunctionInput) {\n    var currentNode = this;\n\n    while (true) {\n      var booleanResult = fns[currentNode.level](booleanFunctionInput);\n      var branchKey = booleanToBooleanString(booleanResult);\n      currentNode = currentNode.branches.getBranch(branchKey);\n\n      if (currentNode.isLeafNode()) {\n        return currentNode.asLeafNode().value;\n      }\n    }\n  };\n\n  RootNode.prototype.toSimpleBdd = function () {\n    return bddToSimpleBdd(this);\n  };\n\n  return RootNode;\n}(AbstractNode);\n\nexport { RootNode };","map":{"version":3,"sources":["../../src/root-node.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nimport { AbstractNode } from './abstract-node';\nimport { Branches } from './branches';\nimport { lastOfArray, booleanToBooleanString } from './util';\nimport { bddToSimpleBdd } from './minimal-string';\nvar RootNode = /** @class */ (function (_super) {\n    __extends(RootNode, _super);\n    function RootNode() {\n        var _this = _super.call(this, 0, null, 'RootNode') || this;\n        _this.branches = new Branches(_this);\n        _this.levels = [];\n        _this.nodesByLevel = new Map();\n        _this.levels.push(0);\n        var level0Set = new Set();\n        level0Set.add(_this);\n        _this.nodesByLevel.set(0, level0Set);\n        return _this;\n    }\n    RootNode.prototype.addNode = function (node) {\n        var level = node.level;\n        if (!this.levels.includes(level)) {\n            this.levels.push(level);\n        }\n        this.ensureLevelSetExists(level);\n        var set = this.nodesByLevel.get(level);\n        set === null || set === void 0 ? void 0 : set.add(node);\n    };\n    RootNode.prototype.removeNode = function (node) {\n        var set = this.nodesByLevel.get(node.level);\n        if (!set.has(node)) {\n            throw new Error('removed non-existing node ' + node.id);\n        }\n        set.delete(node);\n    };\n    RootNode.prototype.ensureLevelSetExists = function (level) {\n        if (!this.nodesByLevel.has(level)) {\n            this.nodesByLevel.set(level, new Set());\n        }\n    };\n    RootNode.prototype.getLevels = function () {\n        return Array.from(this.levels).sort(function (a, b) { return a - b; });\n    };\n    RootNode.prototype.getNodesOfLevel = function (level) {\n        this.ensureLevelSetExists(level);\n        var set = this.nodesByLevel.get(level);\n        return Array.from(set);\n    };\n    RootNode.prototype.countNodes = function () {\n        var _this = this;\n        var ret = 0;\n        this.getLevels().forEach(function (level) {\n            var nodesAmount = _this.getNodesOfLevel(level).length;\n            ret = ret + nodesAmount;\n        });\n        return ret;\n    };\n    /**\n     * applies the reduction rules to the whole bdd\n     */\n    RootNode.prototype.minimize = function (logState) {\n        var e_1, _a;\n        if (logState === void 0) { logState = false; }\n        // console.log('minimize(): START ###############');\n        var done = false;\n        while (!done) {\n            if (logState) {\n                console.log('minimize() itterate once');\n            }\n            var successCount = 0;\n            var lastLevel = lastOfArray(this.getLevels());\n            while (lastLevel > 0) {\n                var nodes = this.getNodesOfLevel(lastLevel);\n                if (logState) {\n                    console.log('minimize() run for level ' + lastLevel +\n                        ' with ' + nodes.length + ' nodes');\n                    // console.dir(nodes);\n                }\n                var nodeCount = 0;\n                try {\n                    for (var nodes_1 = (e_1 = void 0, __values(nodes)), nodes_1_1 = nodes_1.next(); !nodes_1_1.done; nodes_1_1 = nodes_1.next()) {\n                        var node = nodes_1_1.value;\n                        nodeCount++;\n                        // do not run that often because it is expensive\n                        if (logState && nodeCount % 4000 === 0) {\n                            console.log('minimize() node #' + node.id);\n                        }\n                        if (node.isLeafNode()) {\n                            // console.log('have leaf node ' + node.id);\n                            var reductionDone = node.asLeafNode().applyEliminationRule();\n                            if (reductionDone) {\n                                successCount++;\n                            }\n                        }\n                        if (!node.deleted && node.isInternalNode()) {\n                            var useNode = node;\n                            var reductionDone = useNode.applyReductionRule();\n                            var eliminationDone = false;\n                            if (!useNode.deleted) {\n                                // not might now be deleted from reduction-rule\n                                eliminationDone = useNode.applyEliminationRule(nodes);\n                            }\n                            if (reductionDone || eliminationDone) {\n                                successCount++;\n                            }\n                        }\n                    }\n                }\n                catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                finally {\n                    try {\n                        if (nodes_1_1 && !nodes_1_1.done && (_a = nodes_1.return)) _a.call(nodes_1);\n                    }\n                    finally { if (e_1) throw e_1.error; }\n                }\n                lastLevel--;\n            }\n            if (successCount === 0) {\n                // could do no more optimisations\n                done = true;\n            }\n            else {\n                if (logState) {\n                    console.log('minimize() itteration done with ' +\n                        successCount + ' minimisations');\n                }\n            }\n        }\n    };\n    RootNode.prototype.getLeafNodes = function () {\n        var lastLevel = lastOfArray(this.getLevels());\n        var leafNodes = this.getNodesOfLevel(lastLevel).reverse();\n        return leafNodes;\n    };\n    /**\n     * strips all leaf-nodes\n     * with the given value\n     */\n    RootNode.prototype.removeIrrelevantLeafNodes = function (leafNodeValue) {\n        var e_2, _a;\n        var done = false;\n        while (!done) {\n            var countRemoved = 0;\n            var leafNodes = this.getLeafNodes();\n            try {\n                for (var leafNodes_1 = (e_2 = void 0, __values(leafNodes)), leafNodes_1_1 = leafNodes_1.next(); !leafNodes_1_1.done; leafNodes_1_1 = leafNodes_1.next()) {\n                    var leafNode = leafNodes_1_1.value;\n                    var removed = leafNode.removeIfValueEquals(leafNodeValue);\n                    if (removed) {\n                        countRemoved++;\n                    }\n                }\n            }\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\n            finally {\n                try {\n                    if (leafNodes_1_1 && !leafNodes_1_1.done && (_a = leafNodes_1.return)) _a.call(leafNodes_1);\n                }\n                finally { if (e_2) throw e_2.error; }\n            }\n            this.minimize();\n            if (countRemoved === 0) {\n                done = true;\n            }\n        }\n    };\n    RootNode.prototype.resolve = function (fns, booleanFunctionInput) {\n        var currentNode = this;\n        while (true) {\n            var booleanResult = fns[currentNode.level](booleanFunctionInput);\n            var branchKey = booleanToBooleanString(booleanResult);\n            currentNode = currentNode.branches.getBranch(branchKey);\n            if (currentNode.isLeafNode()) {\n                return currentNode.asLeafNode().value;\n            }\n        }\n    };\n    RootNode.prototype.toSimpleBdd = function () {\n        return bddToSimpleBdd(this);\n    };\n    return RootNode;\n}(AbstractNode));\nexport { RootNode };\n//# sourceMappingURL=root-node.js.map"]},"metadata":{},"sourceType":"module"}
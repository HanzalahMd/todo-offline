{"ast":null,"code":"/**\n * does additional checks over the schema-json\n * to ensure nothing is broken or not supported\n */\nimport objectPath from 'object-path';\nimport { newRxError } from '../../rx-error';\nimport { flattenObject, trimDots } from '../../util';\nimport { rxDocumentProperties } from './entity-properties';\n/**\n * checks if the fieldname is allowed\n * this makes sure that the fieldnames can be transformed into javascript-vars\n * and does not conquer the observe$ and populate_ fields\n * @throws {Error}\n */\n\nexport function checkFieldNameRegex(fieldName) {\n  if (fieldName === '') return;\n  if (fieldName === '_id') return;\n\n  if (['properties', 'language'].includes(fieldName)) {\n    throw newRxError('SC23', {\n      fieldName: fieldName\n    });\n  }\n\n  var regexStr = '^[a-zA-Z](?:[[a-zA-Z0-9_]*]?[a-zA-Z0-9])?$';\n  var regex = new RegExp(regexStr);\n\n  if (!fieldName.match(regex)) {\n    throw newRxError('SC1', {\n      regex: regexStr,\n      fieldName: fieldName\n    });\n  }\n}\n/**\n * validate that all schema-related things are ok\n */\n\nexport function validateFieldsDeep(jsonSchema) {\n  function checkField(fieldName, schemaObj, path) {\n    if (typeof fieldName === 'string' && typeof schemaObj === 'object' && !Array.isArray(schemaObj)) checkFieldNameRegex(fieldName); // 'item' only allowed it type=='array'\n\n    if (schemaObj.hasOwnProperty('item') && schemaObj.type !== 'array') {\n      throw newRxError('SC2', {\n        fieldName: fieldName\n      });\n    }\n    /**\n     * required fields cannot be set via 'required: true',\n     * but must be set via required: []\n     */\n\n\n    if (schemaObj.hasOwnProperty('required') && typeof schemaObj.required === 'boolean') {\n      throw newRxError('SC24', {\n        fieldName: fieldName\n      });\n    } // if ref given, must be type=='string', type=='array' with string-items or type==['string','null']\n\n\n    if (schemaObj.hasOwnProperty('ref')) {\n      if (Array.isArray(schemaObj.type)) {\n        if (schemaObj.type.length > 2 || !schemaObj.type.includes('string') || !schemaObj.type.includes('null')) {\n          throw newRxError('SC4', {\n            fieldName: fieldName\n          });\n        }\n      } else {\n        switch (schemaObj.type) {\n          case 'string':\n            break;\n\n          case 'array':\n            if (!schemaObj.items || !schemaObj.items.type || schemaObj.items.type !== 'string') {\n              throw newRxError('SC3', {\n                fieldName: fieldName\n              });\n            }\n\n            break;\n\n          default:\n            throw newRxError('SC4', {\n              fieldName: fieldName\n            });\n        }\n      }\n    }\n\n    var isNested = path.split('.').length >= 2; // nested only\n\n    if (isNested) {\n      if (schemaObj.primary) {\n        throw newRxError('SC6', {\n          path: path,\n          primary: schemaObj.primary\n        });\n      }\n\n      if (schemaObj[\"default\"]) {\n        throw newRxError('SC7', {\n          path: path\n        });\n      }\n    } // first level\n\n\n    if (!isNested) {\n      // check underscore fields\n      if (fieldName.charAt(0) === '_') {\n        if (fieldName === '_id' && schemaObj.primary) {\n          return;\n        }\n\n        throw newRxError('SC8', {\n          fieldName: fieldName\n        });\n      }\n    }\n  }\n\n  function traverse(currentObj, currentPath) {\n    if (typeof currentObj !== 'object') return;\n    Object.keys(currentObj).forEach(function (attributeName) {\n      if (!currentObj.properties) {\n        checkField(attributeName, currentObj[attributeName], currentPath);\n      }\n\n      var nextPath = currentPath;\n      if (attributeName !== 'properties') nextPath = nextPath + '.' + attributeName;\n      traverse(currentObj[attributeName], nextPath);\n    });\n  }\n\n  traverse(jsonSchema, '');\n  return true;\n}\n/**\n * computes real path of the object path in the collection schema\n */\n\nfunction getSchemaPropertyRealPath(shortPath) {\n  var pathParts = shortPath.split('.');\n  var realPath = '';\n\n  for (var i = 0; i < pathParts.length; i += 1) {\n    if (pathParts[i] !== '[]') {\n      realPath = realPath.concat('.properties.'.concat(pathParts[i]));\n    } else {\n      realPath = realPath.concat('.items');\n    }\n  }\n\n  return trimDots(realPath);\n}\n/**\n * does the checking\n * @throws {Error} if something is not ok\n */\n\n\nexport function checkSchema(jsonSchema) {\n  if (!jsonSchema.hasOwnProperty('properties')) {\n    throw newRxError('SC29', {\n      schema: jsonSchema\n    });\n  } // _rev MUST NOT exist, it is added by RxDB\n\n\n  if (jsonSchema.properties._rev) {\n    throw newRxError('SC10', {\n      schema: jsonSchema\n    });\n  } // check version\n\n\n  if (!jsonSchema.hasOwnProperty('version') || typeof jsonSchema.version !== 'number' || jsonSchema.version < 0) {\n    throw newRxError('SC11', {\n      version: jsonSchema.version\n    });\n  }\n\n  validateFieldsDeep(jsonSchema);\n  var primaryPath;\n  Object.keys(jsonSchema.properties).forEach(function (key) {\n    var value = jsonSchema.properties[key]; // check primary\n\n    if (value.primary) {\n      if (primaryPath) {\n        throw newRxError('SC12', {\n          value: value\n        });\n      }\n\n      primaryPath = key;\n\n      if (value.index) {\n        throw newRxError('SC13', {\n          value: value\n        });\n      }\n\n      if (value.unique) {\n        throw newRxError('SC14', {\n          value: value\n        });\n      }\n\n      if (value.encrypted) {\n        throw newRxError('SC15', {\n          value: value\n        });\n      }\n\n      if (value.type !== 'string') {\n        throw newRxError('SC16', {\n          value: value\n        });\n      }\n    } // check if RxDocument-property\n\n\n    if (rxDocumentProperties().includes(key)) {\n      throw newRxError('SC17', {\n        key: key\n      });\n    }\n  }); // check format of jsonSchema.indexes\n\n  if (jsonSchema.indexes) {\n    // should be an array\n    if (!Array.isArray(jsonSchema.indexes)) {\n      throw newRxError('SC18', {\n        indexes: jsonSchema.indexes\n      });\n    }\n\n    jsonSchema.indexes.forEach(function (index) {\n      // should contain strings or array of strings\n      if (!(typeof index === 'string' || Array.isArray(index))) {\n        throw newRxError('SC19', {\n          index: index\n        });\n      } // if is a compound index it must contain strings\n\n\n      if (Array.isArray(index)) {\n        for (var i = 0; i < index.length; i += 1) {\n          if (typeof index[i] !== 'string') {\n            throw newRxError('SC20', {\n              index: index\n            });\n          }\n        }\n      }\n    });\n  }\n  /**\n   * TODO\n   * this check has to exist only in beta-version, to help developers migrate their schemas\n   */\n  // remove backward-compatibility for compoundIndexes\n\n\n  if (Object.keys(jsonSchema).includes('compoundIndexes')) {\n    throw newRxError('SC25');\n  } // remove backward-compatibility for index: true\n\n\n  Object.keys(flattenObject(jsonSchema)).map(function (key) {\n    // flattenObject returns only ending paths, we need all paths pointing to an object\n    var splitted = key.split('.');\n    splitted.pop(); // all but last\n\n    return splitted.join('.');\n  }).filter(function (key) {\n    return key !== '';\n  }).filter(function (elem, pos, arr) {\n    return arr.indexOf(elem) === pos;\n  }) // unique\n  .filter(function (key) {\n    // check if this path defines an index\n    var value = objectPath.get(jsonSchema, key);\n    return !!value.index;\n  }).forEach(function (key) {\n    // replace inner properties\n    key = key.replace('properties.', ''); // first\n\n    key = key.replace(/\\.properties\\./g, '.'); // middle\n\n    throw newRxError('SC26', {\n      index: trimDots(key)\n    });\n  });\n  /* check types of the indexes */\n\n  (jsonSchema.indexes || []).reduce(function (indexPaths, currentIndex) {\n    if (Array.isArray(currentIndex)) {\n      indexPaths.concat(currentIndex);\n    } else {\n      indexPaths.push(currentIndex);\n    }\n\n    return indexPaths;\n  }, []).filter(function (elem, pos, arr) {\n    return arr.indexOf(elem) === pos;\n  }) // from now on working only with unique indexes\n  .map(function (indexPath) {\n    var realPath = getSchemaPropertyRealPath(indexPath); // real path in the collection schema\n\n    var schemaObj = objectPath.get(jsonSchema, realPath); // get the schema of the indexed property\n\n    if (!schemaObj || typeof schemaObj !== 'object') {\n      throw newRxError('SC21', {\n        index: indexPath\n      });\n    }\n\n    return {\n      indexPath: indexPath,\n      schemaObj: schemaObj\n    };\n  }).filter(function (index) {\n    return index.schemaObj.type !== 'string' && index.schemaObj.type !== 'integer' && index.schemaObj.type !== 'number';\n  }).forEach(function (index) {\n    throw newRxError('SC22', {\n      key: index.indexPath,\n      type: index.schemaObj.type\n    });\n  });\n  /**\n   * TODO\n   * in 9.0.0 we changed the way encrypted fields are defined\n   * This check ensures people do not oversee the breaking change\n   * Remove this check in the future\n   */\n\n  Object.keys(flattenObject(jsonSchema)).map(function (key) {\n    // flattenObject returns only ending paths, we need all paths pointing to an object\n    var splitted = key.split('.');\n    splitted.pop(); // all but last\n\n    return splitted.join('.');\n  }).filter(function (key) {\n    return key !== '' && key !== 'attachments';\n  }).filter(function (elem, pos, arr) {\n    return arr.indexOf(elem) === pos;\n  }) // unique\n  .filter(function (key) {\n    // check if this path defines an encrypted field\n    var value = objectPath.get(jsonSchema, key);\n    return !!value.encrypted;\n  }).forEach(function (key) {\n    // replace inner properties\n    key = key.replace('properties.', ''); // first\n\n    key = key.replace(/\\.properties\\./g, '.'); // middle\n\n    throw newRxError('SC27', {\n      index: trimDots(key)\n    });\n  });\n  /* ensure encrypted fields exist in the schema */\n\n  if (jsonSchema.encrypted) {\n    jsonSchema.encrypted.forEach(function (propPath) {\n      // real path in the collection schema\n      var realPath = getSchemaPropertyRealPath(propPath); // get the schema of the indexed property\n\n      var schemaObj = objectPath.get(jsonSchema, realPath);\n\n      if (!schemaObj || typeof schemaObj !== 'object') {\n        throw newRxError('SC28', {\n          field: propPath\n        });\n      }\n    });\n  }\n}","map":{"version":3,"sources":["/Users/Hanzalah/Desktop/github/todo-offline/rxdb-hasura-demo/node_modules/rxdb/dist/es/plugins/dev-mode/check-schema.js"],"names":["objectPath","newRxError","flattenObject","trimDots","rxDocumentProperties","checkFieldNameRegex","fieldName","includes","regexStr","regex","RegExp","match","validateFieldsDeep","jsonSchema","checkField","schemaObj","path","Array","isArray","hasOwnProperty","type","required","length","items","isNested","split","primary","charAt","traverse","currentObj","currentPath","Object","keys","forEach","attributeName","properties","nextPath","getSchemaPropertyRealPath","shortPath","pathParts","realPath","i","concat","checkSchema","schema","_rev","version","primaryPath","key","value","index","unique","encrypted","indexes","map","splitted","pop","join","filter","elem","pos","arr","indexOf","get","replace","reduce","indexPaths","currentIndex","push","indexPath","propPath","field"],"mappings":"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","sourcesContent":["/**\n * does additional checks over the schema-json\n * to ensure nothing is broken or not supported\n */\nimport objectPath from 'object-path';\nimport { newRxError } from '../../rx-error';\nimport { flattenObject, trimDots } from '../../util';\nimport { rxDocumentProperties } from './entity-properties';\n/**\n * checks if the fieldname is allowed\n * this makes sure that the fieldnames can be transformed into javascript-vars\n * and does not conquer the observe$ and populate_ fields\n * @throws {Error}\n */\n\nexport function checkFieldNameRegex(fieldName) {\n  if (fieldName === '') return;\n  if (fieldName === '_id') return;\n\n  if (['properties', 'language'].includes(fieldName)) {\n    throw newRxError('SC23', {\n      fieldName: fieldName\n    });\n  }\n\n  var regexStr = '^[a-zA-Z](?:[[a-zA-Z0-9_]*]?[a-zA-Z0-9])?$';\n  var regex = new RegExp(regexStr);\n\n  if (!fieldName.match(regex)) {\n    throw newRxError('SC1', {\n      regex: regexStr,\n      fieldName: fieldName\n    });\n  }\n}\n/**\n * validate that all schema-related things are ok\n */\n\nexport function validateFieldsDeep(jsonSchema) {\n  function checkField(fieldName, schemaObj, path) {\n    if (typeof fieldName === 'string' && typeof schemaObj === 'object' && !Array.isArray(schemaObj)) checkFieldNameRegex(fieldName); // 'item' only allowed it type=='array'\n\n    if (schemaObj.hasOwnProperty('item') && schemaObj.type !== 'array') {\n      throw newRxError('SC2', {\n        fieldName: fieldName\n      });\n    }\n    /**\n     * required fields cannot be set via 'required: true',\n     * but must be set via required: []\n     */\n\n\n    if (schemaObj.hasOwnProperty('required') && typeof schemaObj.required === 'boolean') {\n      throw newRxError('SC24', {\n        fieldName: fieldName\n      });\n    } // if ref given, must be type=='string', type=='array' with string-items or type==['string','null']\n\n\n    if (schemaObj.hasOwnProperty('ref')) {\n      if (Array.isArray(schemaObj.type)) {\n        if (schemaObj.type.length > 2 || !schemaObj.type.includes('string') || !schemaObj.type.includes('null')) {\n          throw newRxError('SC4', {\n            fieldName: fieldName\n          });\n        }\n      } else {\n        switch (schemaObj.type) {\n          case 'string':\n            break;\n\n          case 'array':\n            if (!schemaObj.items || !schemaObj.items.type || schemaObj.items.type !== 'string') {\n              throw newRxError('SC3', {\n                fieldName: fieldName\n              });\n            }\n\n            break;\n\n          default:\n            throw newRxError('SC4', {\n              fieldName: fieldName\n            });\n        }\n      }\n    }\n\n    var isNested = path.split('.').length >= 2; // nested only\n\n    if (isNested) {\n      if (schemaObj.primary) {\n        throw newRxError('SC6', {\n          path: path,\n          primary: schemaObj.primary\n        });\n      }\n\n      if (schemaObj[\"default\"]) {\n        throw newRxError('SC7', {\n          path: path\n        });\n      }\n    } // first level\n\n\n    if (!isNested) {\n      // check underscore fields\n      if (fieldName.charAt(0) === '_') {\n        if (fieldName === '_id' && schemaObj.primary) {\n          return;\n        }\n\n        throw newRxError('SC8', {\n          fieldName: fieldName\n        });\n      }\n    }\n  }\n\n  function traverse(currentObj, currentPath) {\n    if (typeof currentObj !== 'object') return;\n    Object.keys(currentObj).forEach(function (attributeName) {\n      if (!currentObj.properties) {\n        checkField(attributeName, currentObj[attributeName], currentPath);\n      }\n\n      var nextPath = currentPath;\n      if (attributeName !== 'properties') nextPath = nextPath + '.' + attributeName;\n      traverse(currentObj[attributeName], nextPath);\n    });\n  }\n\n  traverse(jsonSchema, '');\n  return true;\n}\n/**\n * computes real path of the object path in the collection schema\n */\n\nfunction getSchemaPropertyRealPath(shortPath) {\n  var pathParts = shortPath.split('.');\n  var realPath = '';\n\n  for (var i = 0; i < pathParts.length; i += 1) {\n    if (pathParts[i] !== '[]') {\n      realPath = realPath.concat('.properties.'.concat(pathParts[i]));\n    } else {\n      realPath = realPath.concat('.items');\n    }\n  }\n\n  return trimDots(realPath);\n}\n/**\n * does the checking\n * @throws {Error} if something is not ok\n */\n\n\nexport function checkSchema(jsonSchema) {\n  if (!jsonSchema.hasOwnProperty('properties')) {\n    throw newRxError('SC29', {\n      schema: jsonSchema\n    });\n  } // _rev MUST NOT exist, it is added by RxDB\n\n\n  if (jsonSchema.properties._rev) {\n    throw newRxError('SC10', {\n      schema: jsonSchema\n    });\n  } // check version\n\n\n  if (!jsonSchema.hasOwnProperty('version') || typeof jsonSchema.version !== 'number' || jsonSchema.version < 0) {\n    throw newRxError('SC11', {\n      version: jsonSchema.version\n    });\n  }\n\n  validateFieldsDeep(jsonSchema);\n  var primaryPath;\n  Object.keys(jsonSchema.properties).forEach(function (key) {\n    var value = jsonSchema.properties[key]; // check primary\n\n    if (value.primary) {\n      if (primaryPath) {\n        throw newRxError('SC12', {\n          value: value\n        });\n      }\n\n      primaryPath = key;\n\n      if (value.index) {\n        throw newRxError('SC13', {\n          value: value\n        });\n      }\n\n      if (value.unique) {\n        throw newRxError('SC14', {\n          value: value\n        });\n      }\n\n      if (value.encrypted) {\n        throw newRxError('SC15', {\n          value: value\n        });\n      }\n\n      if (value.type !== 'string') {\n        throw newRxError('SC16', {\n          value: value\n        });\n      }\n    } // check if RxDocument-property\n\n\n    if (rxDocumentProperties().includes(key)) {\n      throw newRxError('SC17', {\n        key: key\n      });\n    }\n  }); // check format of jsonSchema.indexes\n\n  if (jsonSchema.indexes) {\n    // should be an array\n    if (!Array.isArray(jsonSchema.indexes)) {\n      throw newRxError('SC18', {\n        indexes: jsonSchema.indexes\n      });\n    }\n\n    jsonSchema.indexes.forEach(function (index) {\n      // should contain strings or array of strings\n      if (!(typeof index === 'string' || Array.isArray(index))) {\n        throw newRxError('SC19', {\n          index: index\n        });\n      } // if is a compound index it must contain strings\n\n\n      if (Array.isArray(index)) {\n        for (var i = 0; i < index.length; i += 1) {\n          if (typeof index[i] !== 'string') {\n            throw newRxError('SC20', {\n              index: index\n            });\n          }\n        }\n      }\n    });\n  }\n  /**\n   * TODO\n   * this check has to exist only in beta-version, to help developers migrate their schemas\n   */\n  // remove backward-compatibility for compoundIndexes\n\n\n  if (Object.keys(jsonSchema).includes('compoundIndexes')) {\n    throw newRxError('SC25');\n  } // remove backward-compatibility for index: true\n\n\n  Object.keys(flattenObject(jsonSchema)).map(function (key) {\n    // flattenObject returns only ending paths, we need all paths pointing to an object\n    var splitted = key.split('.');\n    splitted.pop(); // all but last\n\n    return splitted.join('.');\n  }).filter(function (key) {\n    return key !== '';\n  }).filter(function (elem, pos, arr) {\n    return arr.indexOf(elem) === pos;\n  }) // unique\n  .filter(function (key) {\n    // check if this path defines an index\n    var value = objectPath.get(jsonSchema, key);\n    return !!value.index;\n  }).forEach(function (key) {\n    // replace inner properties\n    key = key.replace('properties.', ''); // first\n\n    key = key.replace(/\\.properties\\./g, '.'); // middle\n\n    throw newRxError('SC26', {\n      index: trimDots(key)\n    });\n  });\n  /* check types of the indexes */\n\n  (jsonSchema.indexes || []).reduce(function (indexPaths, currentIndex) {\n    if (Array.isArray(currentIndex)) {\n      indexPaths.concat(currentIndex);\n    } else {\n      indexPaths.push(currentIndex);\n    }\n\n    return indexPaths;\n  }, []).filter(function (elem, pos, arr) {\n    return arr.indexOf(elem) === pos;\n  }) // from now on working only with unique indexes\n  .map(function (indexPath) {\n    var realPath = getSchemaPropertyRealPath(indexPath); // real path in the collection schema\n\n    var schemaObj = objectPath.get(jsonSchema, realPath); // get the schema of the indexed property\n\n    if (!schemaObj || typeof schemaObj !== 'object') {\n      throw newRxError('SC21', {\n        index: indexPath\n      });\n    }\n\n    return {\n      indexPath: indexPath,\n      schemaObj: schemaObj\n    };\n  }).filter(function (index) {\n    return index.schemaObj.type !== 'string' && index.schemaObj.type !== 'integer' && index.schemaObj.type !== 'number';\n  }).forEach(function (index) {\n    throw newRxError('SC22', {\n      key: index.indexPath,\n      type: index.schemaObj.type\n    });\n  });\n  /**\n   * TODO\n   * in 9.0.0 we changed the way encrypted fields are defined\n   * This check ensures people do not oversee the breaking change\n   * Remove this check in the future\n   */\n\n  Object.keys(flattenObject(jsonSchema)).map(function (key) {\n    // flattenObject returns only ending paths, we need all paths pointing to an object\n    var splitted = key.split('.');\n    splitted.pop(); // all but last\n\n    return splitted.join('.');\n  }).filter(function (key) {\n    return key !== '' && key !== 'attachments';\n  }).filter(function (elem, pos, arr) {\n    return arr.indexOf(elem) === pos;\n  }) // unique\n  .filter(function (key) {\n    // check if this path defines an encrypted field\n    var value = objectPath.get(jsonSchema, key);\n    return !!value.encrypted;\n  }).forEach(function (key) {\n    // replace inner properties\n    key = key.replace('properties.', ''); // first\n\n    key = key.replace(/\\.properties\\./g, '.'); // middle\n\n    throw newRxError('SC27', {\n      index: trimDots(key)\n    });\n  });\n  /* ensure encrypted fields exist in the schema */\n\n  if (jsonSchema.encrypted) {\n    jsonSchema.encrypted.forEach(function (propPath) {\n      // real path in the collection schema\n      var realPath = getSchemaPropertyRealPath(propPath); // get the schema of the indexed property\n\n      var schemaObj = objectPath.get(jsonSchema, realPath);\n\n      if (!schemaObj || typeof schemaObj !== 'object') {\n        throw newRxError('SC28', {\n          field: propPath\n        });\n      }\n    });\n  }\n}\n//# sourceMappingURL=check-schema.js.map"]},"metadata":{},"sourceType":"module"}
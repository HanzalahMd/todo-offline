{"ast":null,"code":"/**\n * a buffer-cache which holds the last X changeEvents of the collection\n */\nexport var ChangeEventBuffer =\n/*#__PURE__*/\nfunction () {\n  /**\n   * array with changeEvents\n   * starts with oldest known event, ends with newest\n   */\n  function ChangeEventBuffer(collection) {\n    var _this = this;\n\n    this.subs = [];\n    this.limit = 100;\n    this.counter = 0;\n    this.eventCounterMap = new WeakMap();\n    this.buffer = [];\n    this.collection = collection;\n    this.subs.push(this.collection.$.subscribe(function (cE) {\n      return _this._handleChangeEvent(cE);\n    }));\n  }\n\n  var _proto = ChangeEventBuffer.prototype;\n\n  _proto._handleChangeEvent = function _handleChangeEvent(changeEvent) {\n    // console.log('changeEventBuffer()._handleChangeEvent()');\n    this.counter++;\n    this.buffer.push(changeEvent);\n    this.eventCounterMap.set(changeEvent, this.counter);\n\n    while (this.buffer.length > this.limit) {\n      this.buffer.shift();\n    }\n  }\n  /**\n   * gets the array-index for the given pointer\n   * @return arrayIndex which can be used to itterate from there. If null, pointer is out of lower bound\n   */\n  ;\n\n  _proto.getArrayIndexByPointer = function getArrayIndexByPointer(pointer) {\n    var oldestEvent = this.buffer[0];\n    var oldestCounter = this.eventCounterMap.get(oldestEvent);\n    if (pointer < oldestCounter) return null; // out of bounds\n\n    var rest = pointer - oldestCounter;\n    return rest;\n  }\n  /**\n   * get all changeEvents which came in later than the pointer-event\n   * @return array with change-events. Iif null, pointer out of bounds\n   */\n  ;\n\n  _proto.getFrom = function getFrom(pointer) {\n    var ret = [];\n    var currentIndex = this.getArrayIndexByPointer(pointer);\n    if (currentIndex === null) // out of bounds\n      return null;\n\n    while (true) {\n      var nextEvent = this.buffer[currentIndex];\n      currentIndex++;\n      if (!nextEvent) return ret;else ret.push(nextEvent);\n    }\n  };\n\n  _proto.runFrom = function runFrom(pointer, fn) {\n    var ret = this.getFrom(pointer);\n\n    if (ret === null) {\n      throw new Error('out of bounds');\n    } else {\n      ret.forEach(function (cE) {\n        return fn(cE);\n      });\n    }\n  }\n  /**\n   * no matter how many operations are done on one document,\n   * only the last operation has to be checked to calculate the new state\n   * this function reduces the events to the last ChangeEvent of each doc\n   */\n  ;\n\n  _proto.reduceByLastOfDoc = function reduceByLastOfDoc(changeEvents) {\n    return changeEvents.slice(0); // TODO the old implementation was wrong\n    // because it did not correctly reassigned the previousData of the changeevents\n    // this should be added to the event-reduce library and not be done in RxDB\n\n    var docEventMap = {};\n    changeEvents.forEach(function (changeEvent) {\n      docEventMap[changeEvent.documentId] = changeEvent;\n    });\n    return Object.values(docEventMap);\n  }\n  /**\n   * use this to check if a change has already been handled\n   * @returns true if change with revision exists\n   *\n   */\n  ;\n\n  _proto.hasChangeWithRevision = function hasChangeWithRevision(revision) {\n    // we loop from behind because its more likely that the searched event is at the end\n    var t = this.buffer.length;\n\n    while (t > 0) {\n      t--;\n      var cE = this.buffer[t];\n      if (cE.documentData && cE.documentData._rev === revision) return true;\n    }\n\n    return false;\n  };\n\n  _proto.destroy = function destroy() {\n    this.subs.forEach(function (sub) {\n      return sub.unsubscribe();\n    });\n  };\n\n  return ChangeEventBuffer;\n}();\nexport function createChangeEventBuffer(collection) {\n  return new ChangeEventBuffer(collection);\n}","map":{"version":3,"sources":["/Users/Hanzalah/Desktop/github/todo-offline/rxdb-hasura-demo/node_modules/rxdb/dist/es/change-event-buffer.js"],"names":["ChangeEventBuffer","collection","_this","subs","limit","counter","eventCounterMap","WeakMap","buffer","push","$","subscribe","cE","_handleChangeEvent","_proto","prototype","changeEvent","set","length","shift","getArrayIndexByPointer","pointer","oldestEvent","oldestCounter","get","rest","getFrom","ret","currentIndex","nextEvent","runFrom","fn","Error","forEach","reduceByLastOfDoc","changeEvents","slice","docEventMap","documentId","Object","values","hasChangeWithRevision","revision","t","documentData","_rev","destroy","sub","unsubscribe","createChangeEventBuffer"],"mappings":"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","sourcesContent":["/**\n * a buffer-cache which holds the last X changeEvents of the collection\n */\nexport var ChangeEventBuffer = /*#__PURE__*/function () {\n  /**\n   * array with changeEvents\n   * starts with oldest known event, ends with newest\n   */\n  function ChangeEventBuffer(collection) {\n    var _this = this;\n\n    this.subs = [];\n    this.limit = 100;\n    this.counter = 0;\n    this.eventCounterMap = new WeakMap();\n    this.buffer = [];\n    this.collection = collection;\n    this.subs.push(this.collection.$.subscribe(function (cE) {\n      return _this._handleChangeEvent(cE);\n    }));\n  }\n\n  var _proto = ChangeEventBuffer.prototype;\n\n  _proto._handleChangeEvent = function _handleChangeEvent(changeEvent) {\n    // console.log('changeEventBuffer()._handleChangeEvent()');\n    this.counter++;\n    this.buffer.push(changeEvent);\n    this.eventCounterMap.set(changeEvent, this.counter);\n\n    while (this.buffer.length > this.limit) {\n      this.buffer.shift();\n    }\n  }\n  /**\n   * gets the array-index for the given pointer\n   * @return arrayIndex which can be used to itterate from there. If null, pointer is out of lower bound\n   */\n  ;\n\n  _proto.getArrayIndexByPointer = function getArrayIndexByPointer(pointer) {\n    var oldestEvent = this.buffer[0];\n    var oldestCounter = this.eventCounterMap.get(oldestEvent);\n    if (pointer < oldestCounter) return null; // out of bounds\n\n    var rest = pointer - oldestCounter;\n    return rest;\n  }\n  /**\n   * get all changeEvents which came in later than the pointer-event\n   * @return array with change-events. Iif null, pointer out of bounds\n   */\n  ;\n\n  _proto.getFrom = function getFrom(pointer) {\n    var ret = [];\n    var currentIndex = this.getArrayIndexByPointer(pointer);\n    if (currentIndex === null) // out of bounds\n      return null;\n\n    while (true) {\n      var nextEvent = this.buffer[currentIndex];\n      currentIndex++;\n      if (!nextEvent) return ret;else ret.push(nextEvent);\n    }\n  };\n\n  _proto.runFrom = function runFrom(pointer, fn) {\n    var ret = this.getFrom(pointer);\n\n    if (ret === null) {\n      throw new Error('out of bounds');\n    } else {\n      ret.forEach(function (cE) {\n        return fn(cE);\n      });\n    }\n  }\n  /**\n   * no matter how many operations are done on one document,\n   * only the last operation has to be checked to calculate the new state\n   * this function reduces the events to the last ChangeEvent of each doc\n   */\n  ;\n\n  _proto.reduceByLastOfDoc = function reduceByLastOfDoc(changeEvents) {\n    return changeEvents.slice(0); // TODO the old implementation was wrong\n    // because it did not correctly reassigned the previousData of the changeevents\n    // this should be added to the event-reduce library and not be done in RxDB\n\n    var docEventMap = {};\n    changeEvents.forEach(function (changeEvent) {\n      docEventMap[changeEvent.documentId] = changeEvent;\n    });\n    return Object.values(docEventMap);\n  }\n  /**\n   * use this to check if a change has already been handled\n   * @returns true if change with revision exists\n   *\n   */\n  ;\n\n  _proto.hasChangeWithRevision = function hasChangeWithRevision(revision) {\n    // we loop from behind because its more likely that the searched event is at the end\n    var t = this.buffer.length;\n\n    while (t > 0) {\n      t--;\n      var cE = this.buffer[t];\n      if (cE.documentData && cE.documentData._rev === revision) return true;\n    }\n\n    return false;\n  };\n\n  _proto.destroy = function destroy() {\n    this.subs.forEach(function (sub) {\n      return sub.unsubscribe();\n    });\n  };\n\n  return ChangeEventBuffer;\n}();\nexport function createChangeEventBuffer(collection) {\n  return new ChangeEventBuffer(collection);\n}\n//# sourceMappingURL=change-event-buffer.js.map"]},"metadata":{},"sourceType":"module"}
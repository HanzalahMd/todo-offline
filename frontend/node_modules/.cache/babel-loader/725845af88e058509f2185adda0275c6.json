{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport { filter, startWith, mergeMap, map, shareReplay } from 'rxjs/operators';\nimport { ucfirst, nextTick, flatClone, promiseSeries, pluginMissing, now } from './util';\nimport { validateCouchDBString } from './pouch-db';\nimport { _handleToPouch as _handleToPouch2, _handleFromPouch as _handleFromPouch2, fillObjectDataBeforeInsert } from './rx-collection-helper';\nimport { createRxQuery, _getDefaultQuery } from './rx-query';\nimport { isInstanceOf as isInstanceOfRxSchema, createRxSchema } from './rx-schema';\nimport { createInsertEvent } from './rx-change-event';\nimport { newRxError, newRxTypeError } from './rx-error';\nimport { createCrypter } from './crypter';\nimport { createDocCache } from './doc-cache';\nimport { createQueryCache, defaultCacheReplacementPolicy } from './query-cache';\nimport { createChangeEventBuffer } from './change-event-buffer';\nimport { overwritable } from './overwritable';\nimport { runPluginHooks } from './hooks';\nimport { createWithConstructor as createRxDocumentWithConstructor, isInstanceOf as isRxDocument } from './rx-document';\nimport { createRxDocument, getRxDocumentConstructor } from './rx-document-prototype-merge';\nvar HOOKS_WHEN = ['pre', 'post'];\nvar HOOKS_KEYS = ['insert', 'save', 'remove', 'create'];\nvar hooksApplied = false;\nexport var RxCollectionBase =\n/*#__PURE__*/\nfunction () {\n  function RxCollectionBase(database, name, schema) {\n    var pouchSettings = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    var migrationStrategies = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    var methods = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    var attachments = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};\n    var options = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : {};\n    var cacheReplacementPolicy = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : defaultCacheReplacementPolicy;\n    var statics = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : {};\n    this._isInMemory = false;\n    this.destroyed = false;\n    this._atomicUpsertQueues = new Map();\n    this.synced = false;\n    this.hooks = {};\n    this._subs = [];\n    this._repStates = [];\n    this.pouch = {};\n    this._docCache = createDocCache();\n    this._queryCache = createQueryCache();\n    this._crypter = {};\n    this._changeEventBuffer = {};\n    this.database = database;\n    this.name = name;\n    this.schema = schema;\n    this.pouchSettings = pouchSettings;\n    this.migrationStrategies = migrationStrategies;\n    this.methods = methods;\n    this.attachments = attachments;\n    this.options = options;\n    this.cacheReplacementPolicy = cacheReplacementPolicy;\n    this.statics = statics;\n\n    _applyHookFunctions(this.asRxCollection);\n  }\n  /**\n   * returns observable\n   */\n\n\n  var _proto = RxCollectionBase.prototype;\n\n  _proto.prepare = function prepare(\n  /**\n   * set to true if the collection data already exists on this storage adapter\n   */\n  wasCreatedBefore) {\n    var _this = this;\n\n    this.pouch = this.database._spawnPouchDB(this.name, this.schema.version, this.pouchSettings);\n\n    if (this.schema.doKeyCompression()) {\n      this._keyCompressor = overwritable.createKeyCompressor(this.schema);\n    } // we trigger the non-blocking things first and await them later so we can do stuff in the mean time\n\n    /**\n     * Sometimes pouchdb emits before the instance is useable.\n     * To prevent random errors, we wait until the .info() call resolved\n     */\n\n\n    var spawnedPouchPromise = wasCreatedBefore ? Promise.resolve() : this.pouch.info();\n    /**\n     * if wasCreatedBefore we can assume that the indexes already exist\n     * because changing them anyway requires a schema-version change\n     */\n\n    var createIndexesPromise = wasCreatedBefore ? Promise.resolve() : _prepareCreateIndexes(this.asRxCollection, spawnedPouchPromise);\n    this._crypter = createCrypter(this.database.password, this.schema);\n    this._observable$ = this.database.$.pipe(filter(function (event) {\n      return event.collectionName === _this.name;\n    }));\n    this._changeEventBuffer = createChangeEventBuffer(this.asRxCollection);\n\n    this._subs.push(this._observable$.pipe(filter(function (cE) {\n      return !cE.isLocal;\n    })).subscribe(function (cE) {\n      // when data changes, send it to RxDocument in docCache\n      var doc = _this._docCache.get(cE.documentId);\n\n      if (doc) doc._handleChangeEvent(cE);\n    }));\n\n    return Promise.all([spawnedPouchPromise, createIndexesPromise]);\n  } // overwritte by migration-plugin\n  ;\n\n  _proto.migrationNeeded = function migrationNeeded() {\n    if (this.schema.version === 0) {\n      return Promise.resolve(false);\n    }\n\n    throw pluginMissing('migration');\n  };\n\n  _proto.getDataMigrator = function getDataMigrator() {\n    throw pluginMissing('migration');\n  };\n\n  _proto.migrate = function migrate() {\n    var batchSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n    return this.getDataMigrator().migrate(batchSize);\n  };\n\n  _proto.migratePromise = function migratePromise() {\n    var batchSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n    return this.getDataMigrator().migratePromise(batchSize);\n  }\n  /**\n   * wrappers for Pouch.put/get to handle keycompression etc\n   */\n  ;\n\n  _proto._handleToPouch = function _handleToPouch(docData) {\n    return _handleToPouch2(this, docData);\n  };\n\n  _proto._handleFromPouch = function _handleFromPouch(docData) {\n    var noDecrypt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return _handleFromPouch2(this, docData, noDecrypt);\n  }\n  /**\n   * every write on the pouchdb\n   * is tunneld throught this function\n   */\n  ;\n\n  _proto._pouchPut = function _pouchPut(obj) {\n    var _this2 = this;\n\n    var overwrite = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    obj = this._handleToPouch(obj);\n    return this.database.lockedRun(function () {\n      return _this2.pouch.put(obj);\n    })[\"catch\"](function (err) {\n      if (overwrite && err.status === 409) {\n        return _this2.database.lockedRun(function () {\n          return _this2.pouch.get(obj._id);\n        }).then(function (exist) {\n          obj._rev = exist._rev;\n          return _this2.database.lockedRun(function () {\n            return _this2.pouch.put(obj);\n          });\n        });\n      } else if (err.status === 409) {\n        throw newRxError('COL19', {\n          id: obj._id,\n          pouchDbError: err,\n          data: obj\n        });\n      } else throw err;\n    });\n  }\n  /**\n   * get document from pouchdb by its _id\n   */\n  ;\n\n  _proto._pouchGet = function _pouchGet(key) {\n    var _this3 = this;\n\n    return this.pouch.get(key).then(function (doc) {\n      return _this3._handleFromPouch(doc);\n    });\n  }\n  /**\n   * wrapps pouch-find\n   */\n  ;\n\n  _proto._pouchFind = function _pouchFind(rxQuery, limit) {\n    var _this4 = this;\n\n    var noDecrypt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var compressedQueryJSON = rxQuery.keyCompress();\n\n    if (limit) {\n      compressedQueryJSON['limit'] = limit;\n    }\n\n    return this.database.lockedRun(function () {\n      return _this4.pouch.find(compressedQueryJSON);\n    }).then(function (docsCompressed) {\n      var docs = docsCompressed.docs.map(function (doc) {\n        return _this4._handleFromPouch(doc, noDecrypt);\n      });\n      return docs;\n    });\n  };\n\n  _proto.$emit = function $emit(changeEvent) {\n    return this.database.$emit(changeEvent);\n  };\n\n  _proto.insert = function insert(json) {\n    var _this5 = this; // inserting a temporary-document\n\n\n    var tempDoc = null;\n\n    if (isRxDocument(json)) {\n      tempDoc = json;\n\n      if (!tempDoc._isTemporary) {\n        throw newRxError('COL1', {\n          data: json\n        });\n      }\n\n      json = tempDoc.toJSON();\n    }\n\n    var useJson = fillObjectDataBeforeInsert(this, json);\n    var newDoc = tempDoc;\n    var startTime;\n    var endTime;\n    return this._runHooks('pre', 'insert', useJson).then(function () {\n      _this5.schema.validate(useJson);\n\n      startTime = now();\n      return _this5._pouchPut(useJson);\n    }).then(function (insertResult) {\n      endTime = now();\n      useJson[_this5.schema.primaryPath] = insertResult.id;\n      useJson._rev = insertResult.rev;\n\n      if (tempDoc) {\n        tempDoc._dataSync$.next(useJson);\n      } else newDoc = createRxDocument(_this5, useJson);\n\n      return _this5._runHooks('post', 'insert', useJson, newDoc);\n    }).then(function () {\n      // event\n      var emitEvent = createInsertEvent(_this5, useJson, startTime, endTime, newDoc);\n\n      _this5.$emit(emitEvent);\n\n      return newDoc;\n    });\n  };\n\n  _proto.bulkInsert = function bulkInsert(docsData) {\n    var _this6 = this;\n\n    var useDocs = docsData.map(function (docData) {\n      var useDocData = fillObjectDataBeforeInsert(_this6, docData);\n      return useDocData;\n    });\n    return Promise.all(useDocs.map(function (doc) {\n      return _this6._runHooks('pre', 'insert', doc).then(function () {\n        _this6.schema.validate(doc);\n\n        return doc;\n      });\n    })).then(function (docs) {\n      var insertDocs = docs.map(function (d) {\n        return _this6._handleToPouch(d);\n      });\n      var docsMap = new Map();\n      docs.forEach(function (d) {\n        docsMap.set(d[_this6.schema.primaryPath], d);\n      });\n      return _this6.database.lockedRun(function () {\n        var startTime = now();\n        return _this6.pouch.bulkDocs(insertDocs).then(function (results) {\n          var okResults = results.filter(function (r) {\n            return r.ok;\n          }); // create documents\n\n          var rxDocuments = okResults.map(function (r) {\n            var docData = docsMap.get(r.id);\n            docData._rev = r.rev;\n            var doc = createRxDocument(_this6, docData);\n            return doc;\n          });\n          return Promise.all(rxDocuments.map(function (doc) {\n            return _this6._runHooks('post', 'insert', docsMap.get(doc.primary), doc);\n          })).then(function () {\n            return {\n              rxDocuments: rxDocuments,\n              errorResults: results.filter(function (r) {\n                return !r.ok;\n              })\n            };\n          });\n        }).then(function (_ref) {\n          var rxDocuments = _ref.rxDocuments,\n              errorResults = _ref.errorResults;\n          var endTime = now(); // emit events\n\n          rxDocuments.forEach(function (doc) {\n            var emitEvent = createInsertEvent(_this6, doc.toJSON(true), startTime, endTime, doc);\n\n            _this6.$emit(emitEvent);\n          });\n          return {\n            success: rxDocuments,\n            error: errorResults\n          };\n        });\n      });\n    });\n  }\n  /**\n   * same as insert but overwrites existing document with same primary\n   */\n  ;\n\n  _proto.upsert = function upsert(json) {\n    var _this7 = this;\n\n    var useJson = flatClone(json);\n    var primary = useJson[this.schema.primaryPath];\n\n    if (!primary) {\n      throw newRxError('COL3', {\n        primaryPath: this.schema.primaryPath,\n        data: useJson\n      });\n    }\n\n    return this.findOne(primary).exec().then(function (existing) {\n      if (existing) {\n        useJson._rev = existing['_rev'];\n        return existing.atomicUpdate(function () {\n          return useJson;\n        }).then(function () {\n          return existing;\n        });\n      } else {\n        return _this7.insert(json);\n      }\n    });\n  }\n  /**\n   * upserts to a RxDocument, uses atomicUpdate if document already exists\n   */\n  ;\n\n  _proto.atomicUpsert = function atomicUpsert(json) {\n    var _this8 = this;\n\n    var primary = json[this.schema.primaryPath];\n\n    if (!primary) {\n      throw newRxError('COL4', {\n        data: json\n      });\n    } // ensure that it wont try 2 parallel runs\n\n\n    var queue;\n\n    if (!this._atomicUpsertQueues.has(primary)) {\n      queue = Promise.resolve();\n    } else {\n      queue = this._atomicUpsertQueues.get(primary);\n    }\n\n    queue = queue.then(function () {\n      return _atomicUpsertEnsureRxDocumentExists(_this8, primary, json);\n    }).then(function (wasInserted) {\n      if (!wasInserted.inserted) {\n        return _atomicUpsertUpdate(wasInserted.doc, json).then(function () {\n          return nextTick();\n        }) // tick here so the event can propagate\n        .then(function () {\n          return wasInserted.doc;\n        });\n      } else return wasInserted.doc;\n    });\n\n    this._atomicUpsertQueues.set(primary, queue);\n\n    return queue;\n  };\n\n  _proto.find = function find(queryObj) {\n    if (typeof queryObj === 'string') {\n      throw newRxError('COL5', {\n        queryObj: queryObj\n      });\n    }\n\n    if (!queryObj) {\n      queryObj = _getDefaultQuery(this);\n    }\n\n    var query = createRxQuery('find', queryObj, this);\n    return query;\n  };\n\n  _proto.findOne = function findOne(queryObj) {\n    var query;\n\n    if (typeof queryObj === 'string') {\n      query = createRxQuery('findOne', {\n        selector: {\n          _id: queryObj\n        }\n      }, this);\n    } else {\n      if (!queryObj) {\n        queryObj = _getDefaultQuery(this);\n      } // cannot have limit on findOne queries\n\n\n      if (queryObj.limit) {\n        throw newRxError('QU6');\n      }\n\n      query = createRxQuery('findOne', queryObj, this);\n    }\n\n    if (typeof queryObj === 'number' || Array.isArray(queryObj)) {\n      throw newRxTypeError('COL6', {\n        queryObj: queryObj\n      });\n    }\n\n    return query;\n  }\n  /**\n   * find a list documents by their primary key\n   * has way better performance then running multiple findOne() or a find() with a complex $or-selected\n   */\n  ;\n\n  _proto.findByIds =\n  /*#__PURE__*/\n  function () {\n    var _findByIds = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee(ids) {\n      var _this9 = this;\n\n      var ret, mustBeQueried, result;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              ret = new Map();\n              mustBeQueried = []; // first try to fill from docCache\n\n              ids.forEach(function (id) {\n                var doc = _this9._docCache.get(id);\n\n                if (doc) {\n                  ret.set(id, doc);\n                } else {\n                  mustBeQueried.push(id);\n                }\n              }); // find everything which was not in docCache\n\n              if (!(mustBeQueried.length > 0)) {\n                _context.next = 8;\n                break;\n              }\n\n              _context.next = 6;\n              return this.pouch.allDocs({\n                include_docs: true,\n                keys: mustBeQueried\n              });\n\n            case 6:\n              result = _context.sent;\n              result.rows.forEach(function (row) {\n                if (!row.doc) {\n                  // not found\n                  return;\n                }\n\n                var plainData = _this9._handleFromPouch(row.doc);\n\n                var doc = createRxDocument(_this9, plainData);\n                ret.set(doc.primary, doc);\n              });\n\n            case 8:\n              return _context.abrupt(\"return\", ret);\n\n            case 9:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, this);\n    }));\n\n    function findByIds(_x) {\n      return _findByIds.apply(this, arguments);\n    }\n\n    return findByIds;\n  }()\n  /**\n   * like this.findByIds but returns an observable\n   * that always emitts the current state\n   */\n  ;\n\n  _proto.findByIds$ = function findByIds$(ids) {\n    var _this10 = this;\n\n    var currentValue = null;\n    var initialPromise = this.findByIds(ids).then(function (docsMap) {\n      currentValue = docsMap;\n    });\n    return this.$.pipe(startWith(null), mergeMap(function (ev) {\n      return initialPromise.then(function () {\n        return ev;\n      });\n    }), map(function (ev) {\n      if (!currentValue) {\n        throw new Error('should not happen');\n      }\n\n      if (!ev) {\n        return currentValue;\n      }\n\n      if (!ids.includes(ev.documentId)) {\n        return null;\n      }\n\n      var op = ev.operation;\n\n      if (op === 'INSERT' || op === 'UPDATE') {\n        currentValue.set(ev.documentId, _this10._docCache.get(ev.documentId));\n      } else {\n        currentValue[\"delete\"](ev.documentId);\n      }\n\n      return currentValue;\n    }), filter(function (x) {\n      return !!x;\n    }), shareReplay(1));\n  }\n  /**\n   * Export collection to a JSON friendly format.\n   * @param _decrypted\n   * When true, all encrypted values will be decrypted.\n   * When false or omitted and an interface or type is loaded in this collection,\n   * all base properties of the type are typed as `any` since data could be encrypted.\n   */\n  ;\n\n  _proto.dump = function dump() {\n    var _decrypted = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    throw pluginMissing('json-dump');\n  }\n  /**\n   * Import the parsed JSON export into the collection.\n   * @param _exportedJSON The previously exported data from the `<collection>.dump()` method.\n   */\n  ;\n\n  _proto.importDump = function importDump(_exportedJSON) {\n    throw pluginMissing('json-dump');\n  }\n  /**\n   * waits for external changes to the database\n   * and ensures they are emitted to the internal RxChangeEvent-Stream\n   * TODO this can be removed by listening to the pull-change-events of the RxReplicationState\n   */\n  ;\n\n  _proto.watchForChanges = function watchForChanges() {\n    throw pluginMissing('watch-for-changes');\n  }\n  /**\n   * sync with another database\n   */\n  ;\n\n  _proto.sync = function sync(_syncOptions) {\n    throw pluginMissing('replication');\n  }\n  /**\n   * sync with a GraphQL endpoint\n   */\n  ;\n\n  _proto.syncGraphQL = function syncGraphQL(options) {\n    throw pluginMissing('replication-graphql');\n  }\n  /**\n   * Create a replicated in-memory-collection\n   */\n  ;\n\n  _proto.inMemory = function inMemory() {\n    throw pluginMissing('in-memory');\n  }\n  /**\n   * HOOKS\n   */\n  ;\n\n  _proto.addHook = function addHook(when, key, fun) {\n    var parallel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n    if (typeof fun !== 'function') {\n      throw newRxTypeError('COL7', {\n        key: key,\n        when: when\n      });\n    }\n\n    if (!HOOKS_WHEN.includes(when)) {\n      throw newRxTypeError('COL8', {\n        key: key,\n        when: when\n      });\n    }\n\n    if (!HOOKS_KEYS.includes(key)) {\n      throw newRxError('COL9', {\n        key: key\n      });\n    }\n\n    if (when === 'post' && key === 'create' && parallel === true) {\n      throw newRxError('COL10', {\n        when: when,\n        key: key,\n        parallel: parallel\n      });\n    } // bind this-scope to hook-function\n\n\n    var boundFun = fun.bind(this);\n    var runName = parallel ? 'parallel' : 'series';\n    this.hooks[key] = this.hooks[key] || {};\n    this.hooks[key][when] = this.hooks[key][when] || {\n      series: [],\n      parallel: []\n    };\n    this.hooks[key][when][runName].push(boundFun);\n  };\n\n  _proto.getHooks = function getHooks(when, key) {\n    try {\n      return this.hooks[key][when];\n    } catch (e) {\n      return {\n        series: [],\n        parallel: []\n      };\n    }\n  };\n\n  _proto._runHooks = function _runHooks(when, key, data, instance) {\n    var hooks = this.getHooks(when, key);\n    if (!hooks) return Promise.resolve(); // run parallel: false\n\n    var tasks = hooks.series.map(function (hook) {\n      return function () {\n        return hook(data, instance);\n      };\n    });\n    return promiseSeries(tasks) // run parallel: true\n    .then(function () {\n      return Promise.all(hooks.parallel.map(function (hook) {\n        return hook(data, instance);\n      }));\n    });\n  }\n  /**\n   * does the same as ._runHooks() but with non-async-functions\n   */\n  ;\n\n  _proto._runHooksSync = function _runHooksSync(when, key, data, instance) {\n    var hooks = this.getHooks(when, key);\n    if (!hooks) return;\n    hooks.series.forEach(function (hook) {\n      return hook(data, instance);\n    });\n  }\n  /**\n   * creates a temporaryDocument which can be saved later\n   */\n  ;\n\n  _proto.newDocument = function newDocument() {\n    var docData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    docData = this.schema.fillObjectWithDefaults(docData);\n    var doc = createRxDocumentWithConstructor(getRxDocumentConstructor(this), this, docData);\n    doc._isTemporary = true;\n\n    this._runHooksSync('post', 'create', docData, doc);\n\n    return doc;\n  };\n\n  _proto.destroy = function destroy() {\n    if (this.destroyed) return Promise.resolve(false);\n\n    if (this._onDestroyCall) {\n      this._onDestroyCall();\n    }\n\n    this._subs.forEach(function (sub) {\n      return sub.unsubscribe();\n    });\n\n    if (this._changeEventBuffer) {\n      this._changeEventBuffer.destroy();\n    }\n\n    this._repStates.forEach(function (sync) {\n      return sync.cancel();\n    });\n\n    delete this.database.collections[this.name];\n    this.destroyed = true;\n    return Promise.resolve(true);\n  }\n  /**\n   * remove all data of the collection\n   */\n  ;\n\n  _proto.remove = function remove() {\n    return this.database.removeCollection(this.name);\n  };\n\n  _createClass(RxCollectionBase, [{\n    key: \"$\",\n    get: function get() {\n      return this._observable$;\n    }\n  }, {\n    key: \"insert$\",\n    get: function get() {\n      return this.$.pipe(filter(function (cE) {\n        return cE.operation === 'INSERT';\n      }));\n    }\n  }, {\n    key: \"update$\",\n    get: function get() {\n      return this.$.pipe(filter(function (cE) {\n        return cE.operation === 'UPDATE';\n      }));\n    }\n  }, {\n    key: \"remove$\",\n    get: function get() {\n      return this.$.pipe(filter(function (cE) {\n        return cE.operation === 'DELETE';\n      }));\n    }\n  }, {\n    key: \"onDestroy\",\n    get: function get() {\n      var _this11 = this;\n\n      if (!this._onDestroy) {\n        this._onDestroy = new Promise(function (res) {\n          return _this11._onDestroyCall = res;\n        });\n      }\n\n      return this._onDestroy;\n    }\n  }, {\n    key: \"asRxCollection\",\n    get: function get() {\n      return this;\n    }\n  }]);\n\n  return RxCollectionBase;\n}();\n/**\n * adds the hook-functions to the collections prototype\n * this runs only once\n */\n\nfunction _applyHookFunctions(collection) {\n  if (hooksApplied) return; // already run\n\n  hooksApplied = true;\n  var colProto = Object.getPrototypeOf(collection);\n  HOOKS_KEYS.forEach(function (key) {\n    HOOKS_WHEN.map(function (when) {\n      var fnName = when + ucfirst(key);\n\n      colProto[fnName] = function (fun, parallel) {\n        return this.addHook(when, key, fun, parallel);\n      };\n    });\n  });\n}\n\nfunction _atomicUpsertUpdate(doc, json) {\n  return doc.atomicUpdate(function (innerDoc) {\n    json._rev = innerDoc._rev;\n    innerDoc._data = json;\n    return innerDoc._data;\n  }).then(function () {\n    return doc;\n  });\n}\n/**\n * ensures that the given document exists\n * @return promise that resolves with new doc and flag if inserted\n */\n\n\nfunction _atomicUpsertEnsureRxDocumentExists(rxCollection, primary, json) {\n  return rxCollection.findOne(primary).exec().then(function (doc) {\n    if (!doc) {\n      return rxCollection.insert(json).then(function (newDoc) {\n        return {\n          doc: newDoc,\n          inserted: true\n        };\n      });\n    } else {\n      return {\n        doc: doc,\n        inserted: false\n      };\n    }\n  });\n}\n/**\n * creates the indexes in the pouchdb\n */\n\n\nfunction _prepareCreateIndexes(rxCollection, spawnedPouchPromise) {\n  /**\n   * pouchdb does no check on already existing indexes\n   * which makes collection re-creation really slow on page reloads\n   * So we have to manually check if the index already exists\n   */\n  return spawnedPouchPromise.then(function () {\n    return rxCollection.pouch.getIndexes();\n  }).then(function (indexResult) {\n    var existingIndexes = new Set();\n    indexResult.indexes.forEach(function (idx) {\n      return existingIndexes.add(idx.name);\n    });\n    return existingIndexes;\n  }).then(function (existingIndexes) {\n    return Promise.all(rxCollection.schema.indexes.map(function (indexAr) {\n      var compressedIdx = indexAr.map(function (key) {\n        var primPath = rxCollection.schema.primaryPath;\n        var useKey = key === primPath ? '_id' : key;\n\n        if (!rxCollection.schema.doKeyCompression()) {\n          return useKey;\n        } else {\n          var indexKey = rxCollection._keyCompressor.transformKey(useKey);\n\n          return indexKey;\n        }\n      });\n      var indexName = 'idx-rxdb-index-' + compressedIdx.join(',');\n\n      if (existingIndexes.has(indexName)) {\n        // index already exists\n        return;\n      }\n      /**\n       * TODO\n       * we might have even better performance by doing a bulkDocs\n       * on index creation\n       */\n\n\n      return spawnedPouchPromise.then(function () {\n        return rxCollection.pouch.createIndex({\n          name: indexName,\n          ddoc: indexName,\n          index: {\n            fields: compressedIdx\n          }\n        });\n      });\n    }));\n  });\n}\n/**\n * creates and prepares a new collection\n */\n\n\nexport function create(_ref2, wasCreatedBefore) {\n  var database = _ref2.database,\n      name = _ref2.name,\n      schema = _ref2.schema,\n      _ref2$pouchSettings = _ref2.pouchSettings,\n      pouchSettings = _ref2$pouchSettings === void 0 ? {} : _ref2$pouchSettings,\n      _ref2$migrationStrate = _ref2.migrationStrategies,\n      migrationStrategies = _ref2$migrationStrate === void 0 ? {} : _ref2$migrationStrate,\n      _ref2$autoMigrate = _ref2.autoMigrate,\n      autoMigrate = _ref2$autoMigrate === void 0 ? true : _ref2$autoMigrate,\n      _ref2$statics = _ref2.statics,\n      statics = _ref2$statics === void 0 ? {} : _ref2$statics,\n      _ref2$methods = _ref2.methods,\n      methods = _ref2$methods === void 0 ? {} : _ref2$methods,\n      _ref2$attachments = _ref2.attachments,\n      attachments = _ref2$attachments === void 0 ? {} : _ref2$attachments,\n      _ref2$options = _ref2.options,\n      options = _ref2$options === void 0 ? {} : _ref2$options,\n      _ref2$cacheReplacemen = _ref2.cacheReplacementPolicy,\n      cacheReplacementPolicy = _ref2$cacheReplacemen === void 0 ? defaultCacheReplacementPolicy : _ref2$cacheReplacemen;\n  validateCouchDBString(name); // ensure it is a schema-object\n\n  if (!isInstanceOfRxSchema(schema)) {\n    schema = createRxSchema(schema);\n  }\n\n  Object.keys(methods).filter(function (funName) {\n    return schema.topLevelFields.includes(funName);\n  }).forEach(function (funName) {\n    throw newRxError('COL18', {\n      funName: funName\n    });\n  });\n  var collection = new RxCollectionBase(database, name, schema, pouchSettings, migrationStrategies, methods, attachments, options, cacheReplacementPolicy, statics);\n  return collection.prepare(wasCreatedBefore).then(function () {\n    // ORM add statics\n    Object.entries(statics).forEach(function (_ref3) {\n      var funName = _ref3[0],\n          fun = _ref3[1];\n      Object.defineProperty(collection, funName, {\n        get: function get() {\n          return fun.bind(collection);\n        }\n      });\n    });\n    var ret = Promise.resolve();\n\n    if (autoMigrate && collection.schema.version !== 0) {\n      ret = collection.migratePromise();\n    }\n\n    return ret;\n  }).then(function () {\n    runPluginHooks('createRxCollection', collection);\n    return collection;\n  });\n}\nexport function isInstanceOf(obj) {\n  return obj instanceof RxCollectionBase;\n}\nexport default {\n  create: create,\n  isInstanceOf: isInstanceOf,\n  RxCollectionBase: RxCollectionBase\n};","map":{"version":3,"sources":["/Users/Hanzalah/Desktop/github/todo-offline/rxdb-hasura-demo/node_modules/rxdb/dist/es/rx-collection.js"],"names":["_regeneratorRuntime","_asyncToGenerator","_createClass","filter","startWith","mergeMap","map","shareReplay","ucfirst","nextTick","flatClone","promiseSeries","pluginMissing","now","validateCouchDBString","_handleToPouch","_handleToPouch2","_handleFromPouch","_handleFromPouch2","fillObjectDataBeforeInsert","createRxQuery","_getDefaultQuery","isInstanceOf","isInstanceOfRxSchema","createRxSchema","createInsertEvent","newRxError","newRxTypeError","createCrypter","createDocCache","createQueryCache","defaultCacheReplacementPolicy","createChangeEventBuffer","overwritable","runPluginHooks","createWithConstructor","createRxDocumentWithConstructor","isRxDocument","createRxDocument","getRxDocumentConstructor","HOOKS_WHEN","HOOKS_KEYS","hooksApplied","RxCollectionBase","database","name","schema","pouchSettings","arguments","length","undefined","migrationStrategies","methods","attachments","options","cacheReplacementPolicy","statics","_isInMemory","destroyed","_atomicUpsertQueues","Map","synced","hooks","_subs","_repStates","pouch","_docCache","_queryCache","_crypter","_changeEventBuffer","_applyHookFunctions","asRxCollection","_proto","prototype","prepare","wasCreatedBefore","_this","_spawnPouchDB","version","doKeyCompression","_keyCompressor","createKeyCompressor","spawnedPouchPromise","Promise","resolve","info","createIndexesPromise","_prepareCreateIndexes","password","_observable$","$","pipe","event","collectionName","push","cE","isLocal","subscribe","doc","get","documentId","_handleChangeEvent","all","migrationNeeded","getDataMigrator","migrate","batchSize","migratePromise","docData","noDecrypt","_pouchPut","obj","_this2","overwrite","lockedRun","put","err","status","_id","then","exist","_rev","id","pouchDbError","data","_pouchGet","key","_this3","_pouchFind","rxQuery","limit","_this4","compressedQueryJSON","keyCompress","find","docsCompressed","docs","$emit","changeEvent","insert","json","_this5","tempDoc","_isTemporary","toJSON","useJson","newDoc","startTime","endTime","_runHooks","validate","insertResult","primaryPath","rev","_dataSync$","next","emitEvent","bulkInsert","docsData","_this6","useDocs","useDocData","insertDocs","d","docsMap","forEach","set","bulkDocs","results","okResults","r","ok","rxDocuments","primary","errorResults","_ref","success","error","upsert","_this7","findOne","exec","existing","atomicUpdate","atomicUpsert","_this8","queue","has","_atomicUpsertEnsureRxDocumentExists","wasInserted","inserted","_atomicUpsertUpdate","queryObj","query","selector","Array","isArray","findByIds","_findByIds","mark","_callee","ids","_this9","ret","mustBeQueried","result","wrap","_callee$","_context","prev","allDocs","include_docs","keys","sent","rows","row","plainData","abrupt","stop","_x","apply","findByIds$","_this10","currentValue","initialPromise","ev","Error","includes","op","operation","x","dump","_decrypted","importDump","_exportedJSON","watchForChanges","sync","_syncOptions","syncGraphQL","inMemory","addHook","when","fun","parallel","boundFun","bind","runName","series","getHooks","e","instance","tasks","hook","_runHooksSync","newDocument","fillObjectWithDefaults","destroy","_onDestroyCall","sub","unsubscribe","cancel","collections","remove","removeCollection","_this11","_onDestroy","res","collection","colProto","Object","getPrototypeOf","fnName","innerDoc","_data","rxCollection","getIndexes","indexResult","existingIndexes","Set","indexes","idx","add","indexAr","compressedIdx","primPath","useKey","indexKey","transformKey","indexName","join","createIndex","ddoc","index","fields","create","_ref2","_ref2$pouchSettings","_ref2$migrationStrate","_ref2$autoMigrate","autoMigrate","_ref2$statics","_ref2$methods","_ref2$attachments","_ref2$options","_ref2$cacheReplacemen","funName","topLevelFields","entries","_ref3","defineProperty"],"mappings":"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","sourcesContent":["import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport { filter, startWith, mergeMap, map, shareReplay } from 'rxjs/operators';\nimport { ucfirst, nextTick, flatClone, promiseSeries, pluginMissing, now } from './util';\nimport { validateCouchDBString } from './pouch-db';\nimport { _handleToPouch as _handleToPouch2, _handleFromPouch as _handleFromPouch2, fillObjectDataBeforeInsert } from './rx-collection-helper';\nimport { createRxQuery, _getDefaultQuery } from './rx-query';\nimport { isInstanceOf as isInstanceOfRxSchema, createRxSchema } from './rx-schema';\nimport { createInsertEvent } from './rx-change-event';\nimport { newRxError, newRxTypeError } from './rx-error';\nimport { createCrypter } from './crypter';\nimport { createDocCache } from './doc-cache';\nimport { createQueryCache, defaultCacheReplacementPolicy } from './query-cache';\nimport { createChangeEventBuffer } from './change-event-buffer';\nimport { overwritable } from './overwritable';\nimport { runPluginHooks } from './hooks';\nimport { createWithConstructor as createRxDocumentWithConstructor, isInstanceOf as isRxDocument } from './rx-document';\nimport { createRxDocument, getRxDocumentConstructor } from './rx-document-prototype-merge';\nvar HOOKS_WHEN = ['pre', 'post'];\nvar HOOKS_KEYS = ['insert', 'save', 'remove', 'create'];\nvar hooksApplied = false;\nexport var RxCollectionBase = /*#__PURE__*/function () {\n  function RxCollectionBase(database, name, schema) {\n    var pouchSettings = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    var migrationStrategies = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    var methods = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    var attachments = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};\n    var options = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : {};\n    var cacheReplacementPolicy = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : defaultCacheReplacementPolicy;\n    var statics = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : {};\n    this._isInMemory = false;\n    this.destroyed = false;\n    this._atomicUpsertQueues = new Map();\n    this.synced = false;\n    this.hooks = {};\n    this._subs = [];\n    this._repStates = [];\n    this.pouch = {};\n    this._docCache = createDocCache();\n    this._queryCache = createQueryCache();\n    this._crypter = {};\n    this._changeEventBuffer = {};\n    this.database = database;\n    this.name = name;\n    this.schema = schema;\n    this.pouchSettings = pouchSettings;\n    this.migrationStrategies = migrationStrategies;\n    this.methods = methods;\n    this.attachments = attachments;\n    this.options = options;\n    this.cacheReplacementPolicy = cacheReplacementPolicy;\n    this.statics = statics;\n\n    _applyHookFunctions(this.asRxCollection);\n  }\n  /**\n   * returns observable\n   */\n\n\n  var _proto = RxCollectionBase.prototype;\n\n  _proto.prepare = function prepare(\n  /**\n   * set to true if the collection data already exists on this storage adapter\n   */\n  wasCreatedBefore) {\n    var _this = this;\n\n    this.pouch = this.database._spawnPouchDB(this.name, this.schema.version, this.pouchSettings);\n\n    if (this.schema.doKeyCompression()) {\n      this._keyCompressor = overwritable.createKeyCompressor(this.schema);\n    } // we trigger the non-blocking things first and await them later so we can do stuff in the mean time\n\n    /**\n     * Sometimes pouchdb emits before the instance is useable.\n     * To prevent random errors, we wait until the .info() call resolved\n     */\n\n\n    var spawnedPouchPromise = wasCreatedBefore ? Promise.resolve() : this.pouch.info();\n    /**\n     * if wasCreatedBefore we can assume that the indexes already exist\n     * because changing them anyway requires a schema-version change\n     */\n\n    var createIndexesPromise = wasCreatedBefore ? Promise.resolve() : _prepareCreateIndexes(this.asRxCollection, spawnedPouchPromise);\n    this._crypter = createCrypter(this.database.password, this.schema);\n    this._observable$ = this.database.$.pipe(filter(function (event) {\n      return event.collectionName === _this.name;\n    }));\n    this._changeEventBuffer = createChangeEventBuffer(this.asRxCollection);\n\n    this._subs.push(this._observable$.pipe(filter(function (cE) {\n      return !cE.isLocal;\n    })).subscribe(function (cE) {\n      // when data changes, send it to RxDocument in docCache\n      var doc = _this._docCache.get(cE.documentId);\n\n      if (doc) doc._handleChangeEvent(cE);\n    }));\n\n    return Promise.all([spawnedPouchPromise, createIndexesPromise]);\n  } // overwritte by migration-plugin\n  ;\n\n  _proto.migrationNeeded = function migrationNeeded() {\n    if (this.schema.version === 0) {\n      return Promise.resolve(false);\n    }\n\n    throw pluginMissing('migration');\n  };\n\n  _proto.getDataMigrator = function getDataMigrator() {\n    throw pluginMissing('migration');\n  };\n\n  _proto.migrate = function migrate() {\n    var batchSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n    return this.getDataMigrator().migrate(batchSize);\n  };\n\n  _proto.migratePromise = function migratePromise() {\n    var batchSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n    return this.getDataMigrator().migratePromise(batchSize);\n  }\n  /**\n   * wrappers for Pouch.put/get to handle keycompression etc\n   */\n  ;\n\n  _proto._handleToPouch = function _handleToPouch(docData) {\n    return _handleToPouch2(this, docData);\n  };\n\n  _proto._handleFromPouch = function _handleFromPouch(docData) {\n    var noDecrypt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return _handleFromPouch2(this, docData, noDecrypt);\n  }\n  /**\n   * every write on the pouchdb\n   * is tunneld throught this function\n   */\n  ;\n\n  _proto._pouchPut = function _pouchPut(obj) {\n    var _this2 = this;\n\n    var overwrite = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    obj = this._handleToPouch(obj);\n    return this.database.lockedRun(function () {\n      return _this2.pouch.put(obj);\n    })[\"catch\"](function (err) {\n      if (overwrite && err.status === 409) {\n        return _this2.database.lockedRun(function () {\n          return _this2.pouch.get(obj._id);\n        }).then(function (exist) {\n          obj._rev = exist._rev;\n          return _this2.database.lockedRun(function () {\n            return _this2.pouch.put(obj);\n          });\n        });\n      } else if (err.status === 409) {\n        throw newRxError('COL19', {\n          id: obj._id,\n          pouchDbError: err,\n          data: obj\n        });\n      } else throw err;\n    });\n  }\n  /**\n   * get document from pouchdb by its _id\n   */\n  ;\n\n  _proto._pouchGet = function _pouchGet(key) {\n    var _this3 = this;\n\n    return this.pouch.get(key).then(function (doc) {\n      return _this3._handleFromPouch(doc);\n    });\n  }\n  /**\n   * wrapps pouch-find\n   */\n  ;\n\n  _proto._pouchFind = function _pouchFind(rxQuery, limit) {\n    var _this4 = this;\n\n    var noDecrypt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var compressedQueryJSON = rxQuery.keyCompress();\n\n    if (limit) {\n      compressedQueryJSON['limit'] = limit;\n    }\n\n    return this.database.lockedRun(function () {\n      return _this4.pouch.find(compressedQueryJSON);\n    }).then(function (docsCompressed) {\n      var docs = docsCompressed.docs.map(function (doc) {\n        return _this4._handleFromPouch(doc, noDecrypt);\n      });\n      return docs;\n    });\n  };\n\n  _proto.$emit = function $emit(changeEvent) {\n    return this.database.$emit(changeEvent);\n  };\n\n  _proto.insert = function insert(json) {\n    var _this5 = this;\n\n    // inserting a temporary-document\n    var tempDoc = null;\n\n    if (isRxDocument(json)) {\n      tempDoc = json;\n\n      if (!tempDoc._isTemporary) {\n        throw newRxError('COL1', {\n          data: json\n        });\n      }\n\n      json = tempDoc.toJSON();\n    }\n\n    var useJson = fillObjectDataBeforeInsert(this, json);\n    var newDoc = tempDoc;\n    var startTime;\n    var endTime;\n    return this._runHooks('pre', 'insert', useJson).then(function () {\n      _this5.schema.validate(useJson);\n\n      startTime = now();\n      return _this5._pouchPut(useJson);\n    }).then(function (insertResult) {\n      endTime = now();\n      useJson[_this5.schema.primaryPath] = insertResult.id;\n      useJson._rev = insertResult.rev;\n\n      if (tempDoc) {\n        tempDoc._dataSync$.next(useJson);\n      } else newDoc = createRxDocument(_this5, useJson);\n\n      return _this5._runHooks('post', 'insert', useJson, newDoc);\n    }).then(function () {\n      // event\n      var emitEvent = createInsertEvent(_this5, useJson, startTime, endTime, newDoc);\n\n      _this5.$emit(emitEvent);\n\n      return newDoc;\n    });\n  };\n\n  _proto.bulkInsert = function bulkInsert(docsData) {\n    var _this6 = this;\n\n    var useDocs = docsData.map(function (docData) {\n      var useDocData = fillObjectDataBeforeInsert(_this6, docData);\n      return useDocData;\n    });\n    return Promise.all(useDocs.map(function (doc) {\n      return _this6._runHooks('pre', 'insert', doc).then(function () {\n        _this6.schema.validate(doc);\n\n        return doc;\n      });\n    })).then(function (docs) {\n      var insertDocs = docs.map(function (d) {\n        return _this6._handleToPouch(d);\n      });\n      var docsMap = new Map();\n      docs.forEach(function (d) {\n        docsMap.set(d[_this6.schema.primaryPath], d);\n      });\n      return _this6.database.lockedRun(function () {\n        var startTime = now();\n        return _this6.pouch.bulkDocs(insertDocs).then(function (results) {\n          var okResults = results.filter(function (r) {\n            return r.ok;\n          }); // create documents\n\n          var rxDocuments = okResults.map(function (r) {\n            var docData = docsMap.get(r.id);\n            docData._rev = r.rev;\n            var doc = createRxDocument(_this6, docData);\n            return doc;\n          });\n          return Promise.all(rxDocuments.map(function (doc) {\n            return _this6._runHooks('post', 'insert', docsMap.get(doc.primary), doc);\n          })).then(function () {\n            return {\n              rxDocuments: rxDocuments,\n              errorResults: results.filter(function (r) {\n                return !r.ok;\n              })\n            };\n          });\n        }).then(function (_ref) {\n          var rxDocuments = _ref.rxDocuments,\n              errorResults = _ref.errorResults;\n          var endTime = now(); // emit events\n\n          rxDocuments.forEach(function (doc) {\n            var emitEvent = createInsertEvent(_this6, doc.toJSON(true), startTime, endTime, doc);\n\n            _this6.$emit(emitEvent);\n          });\n          return {\n            success: rxDocuments,\n            error: errorResults\n          };\n        });\n      });\n    });\n  }\n  /**\n   * same as insert but overwrites existing document with same primary\n   */\n  ;\n\n  _proto.upsert = function upsert(json) {\n    var _this7 = this;\n\n    var useJson = flatClone(json);\n    var primary = useJson[this.schema.primaryPath];\n\n    if (!primary) {\n      throw newRxError('COL3', {\n        primaryPath: this.schema.primaryPath,\n        data: useJson\n      });\n    }\n\n    return this.findOne(primary).exec().then(function (existing) {\n      if (existing) {\n        useJson._rev = existing['_rev'];\n        return existing.atomicUpdate(function () {\n          return useJson;\n        }).then(function () {\n          return existing;\n        });\n      } else {\n        return _this7.insert(json);\n      }\n    });\n  }\n  /**\n   * upserts to a RxDocument, uses atomicUpdate if document already exists\n   */\n  ;\n\n  _proto.atomicUpsert = function atomicUpsert(json) {\n    var _this8 = this;\n\n    var primary = json[this.schema.primaryPath];\n\n    if (!primary) {\n      throw newRxError('COL4', {\n        data: json\n      });\n    } // ensure that it wont try 2 parallel runs\n\n\n    var queue;\n\n    if (!this._atomicUpsertQueues.has(primary)) {\n      queue = Promise.resolve();\n    } else {\n      queue = this._atomicUpsertQueues.get(primary);\n    }\n\n    queue = queue.then(function () {\n      return _atomicUpsertEnsureRxDocumentExists(_this8, primary, json);\n    }).then(function (wasInserted) {\n      if (!wasInserted.inserted) {\n        return _atomicUpsertUpdate(wasInserted.doc, json).then(function () {\n          return nextTick();\n        }) // tick here so the event can propagate\n        .then(function () {\n          return wasInserted.doc;\n        });\n      } else return wasInserted.doc;\n    });\n\n    this._atomicUpsertQueues.set(primary, queue);\n\n    return queue;\n  };\n\n  _proto.find = function find(queryObj) {\n    if (typeof queryObj === 'string') {\n      throw newRxError('COL5', {\n        queryObj: queryObj\n      });\n    }\n\n    if (!queryObj) {\n      queryObj = _getDefaultQuery(this);\n    }\n\n    var query = createRxQuery('find', queryObj, this);\n    return query;\n  };\n\n  _proto.findOne = function findOne(queryObj) {\n    var query;\n\n    if (typeof queryObj === 'string') {\n      query = createRxQuery('findOne', {\n        selector: {\n          _id: queryObj\n        }\n      }, this);\n    } else {\n      if (!queryObj) {\n        queryObj = _getDefaultQuery(this);\n      } // cannot have limit on findOne queries\n\n\n      if (queryObj.limit) {\n        throw newRxError('QU6');\n      }\n\n      query = createRxQuery('findOne', queryObj, this);\n    }\n\n    if (typeof queryObj === 'number' || Array.isArray(queryObj)) {\n      throw newRxTypeError('COL6', {\n        queryObj: queryObj\n      });\n    }\n\n    return query;\n  }\n  /**\n   * find a list documents by their primary key\n   * has way better performance then running multiple findOne() or a find() with a complex $or-selected\n   */\n  ;\n\n  _proto.findByIds =\n  /*#__PURE__*/\n  function () {\n    var _findByIds = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(ids) {\n      var _this9 = this;\n\n      var ret, mustBeQueried, result;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              ret = new Map();\n              mustBeQueried = []; // first try to fill from docCache\n\n              ids.forEach(function (id) {\n                var doc = _this9._docCache.get(id);\n\n                if (doc) {\n                  ret.set(id, doc);\n                } else {\n                  mustBeQueried.push(id);\n                }\n              }); // find everything which was not in docCache\n\n              if (!(mustBeQueried.length > 0)) {\n                _context.next = 8;\n                break;\n              }\n\n              _context.next = 6;\n              return this.pouch.allDocs({\n                include_docs: true,\n                keys: mustBeQueried\n              });\n\n            case 6:\n              result = _context.sent;\n              result.rows.forEach(function (row) {\n                if (!row.doc) {\n                  // not found\n                  return;\n                }\n\n                var plainData = _this9._handleFromPouch(row.doc);\n\n                var doc = createRxDocument(_this9, plainData);\n                ret.set(doc.primary, doc);\n              });\n\n            case 8:\n              return _context.abrupt(\"return\", ret);\n\n            case 9:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, this);\n    }));\n\n    function findByIds(_x) {\n      return _findByIds.apply(this, arguments);\n    }\n\n    return findByIds;\n  }()\n  /**\n   * like this.findByIds but returns an observable\n   * that always emitts the current state\n   */\n  ;\n\n  _proto.findByIds$ = function findByIds$(ids) {\n    var _this10 = this;\n\n    var currentValue = null;\n    var initialPromise = this.findByIds(ids).then(function (docsMap) {\n      currentValue = docsMap;\n    });\n    return this.$.pipe(startWith(null), mergeMap(function (ev) {\n      return initialPromise.then(function () {\n        return ev;\n      });\n    }), map(function (ev) {\n      if (!currentValue) {\n        throw new Error('should not happen');\n      }\n\n      if (!ev) {\n        return currentValue;\n      }\n\n      if (!ids.includes(ev.documentId)) {\n        return null;\n      }\n\n      var op = ev.operation;\n\n      if (op === 'INSERT' || op === 'UPDATE') {\n        currentValue.set(ev.documentId, _this10._docCache.get(ev.documentId));\n      } else {\n        currentValue[\"delete\"](ev.documentId);\n      }\n\n      return currentValue;\n    }), filter(function (x) {\n      return !!x;\n    }), shareReplay(1));\n  }\n  /**\n   * Export collection to a JSON friendly format.\n   * @param _decrypted\n   * When true, all encrypted values will be decrypted.\n   * When false or omitted and an interface or type is loaded in this collection,\n   * all base properties of the type are typed as `any` since data could be encrypted.\n   */\n  ;\n\n  _proto.dump = function dump() {\n    var _decrypted = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    throw pluginMissing('json-dump');\n  }\n  /**\n   * Import the parsed JSON export into the collection.\n   * @param _exportedJSON The previously exported data from the `<collection>.dump()` method.\n   */\n  ;\n\n  _proto.importDump = function importDump(_exportedJSON) {\n    throw pluginMissing('json-dump');\n  }\n  /**\n   * waits for external changes to the database\n   * and ensures they are emitted to the internal RxChangeEvent-Stream\n   * TODO this can be removed by listening to the pull-change-events of the RxReplicationState\n   */\n  ;\n\n  _proto.watchForChanges = function watchForChanges() {\n    throw pluginMissing('watch-for-changes');\n  }\n  /**\n   * sync with another database\n   */\n  ;\n\n  _proto.sync = function sync(_syncOptions) {\n    throw pluginMissing('replication');\n  }\n  /**\n   * sync with a GraphQL endpoint\n   */\n  ;\n\n  _proto.syncGraphQL = function syncGraphQL(options) {\n    throw pluginMissing('replication-graphql');\n  }\n  /**\n   * Create a replicated in-memory-collection\n   */\n  ;\n\n  _proto.inMemory = function inMemory() {\n    throw pluginMissing('in-memory');\n  }\n  /**\n   * HOOKS\n   */\n  ;\n\n  _proto.addHook = function addHook(when, key, fun) {\n    var parallel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n    if (typeof fun !== 'function') {\n      throw newRxTypeError('COL7', {\n        key: key,\n        when: when\n      });\n    }\n\n    if (!HOOKS_WHEN.includes(when)) {\n      throw newRxTypeError('COL8', {\n        key: key,\n        when: when\n      });\n    }\n\n    if (!HOOKS_KEYS.includes(key)) {\n      throw newRxError('COL9', {\n        key: key\n      });\n    }\n\n    if (when === 'post' && key === 'create' && parallel === true) {\n      throw newRxError('COL10', {\n        when: when,\n        key: key,\n        parallel: parallel\n      });\n    } // bind this-scope to hook-function\n\n\n    var boundFun = fun.bind(this);\n    var runName = parallel ? 'parallel' : 'series';\n    this.hooks[key] = this.hooks[key] || {};\n    this.hooks[key][when] = this.hooks[key][when] || {\n      series: [],\n      parallel: []\n    };\n    this.hooks[key][when][runName].push(boundFun);\n  };\n\n  _proto.getHooks = function getHooks(when, key) {\n    try {\n      return this.hooks[key][when];\n    } catch (e) {\n      return {\n        series: [],\n        parallel: []\n      };\n    }\n  };\n\n  _proto._runHooks = function _runHooks(when, key, data, instance) {\n    var hooks = this.getHooks(when, key);\n    if (!hooks) return Promise.resolve(); // run parallel: false\n\n    var tasks = hooks.series.map(function (hook) {\n      return function () {\n        return hook(data, instance);\n      };\n    });\n    return promiseSeries(tasks) // run parallel: true\n    .then(function () {\n      return Promise.all(hooks.parallel.map(function (hook) {\n        return hook(data, instance);\n      }));\n    });\n  }\n  /**\n   * does the same as ._runHooks() but with non-async-functions\n   */\n  ;\n\n  _proto._runHooksSync = function _runHooksSync(when, key, data, instance) {\n    var hooks = this.getHooks(when, key);\n    if (!hooks) return;\n    hooks.series.forEach(function (hook) {\n      return hook(data, instance);\n    });\n  }\n  /**\n   * creates a temporaryDocument which can be saved later\n   */\n  ;\n\n  _proto.newDocument = function newDocument() {\n    var docData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    docData = this.schema.fillObjectWithDefaults(docData);\n    var doc = createRxDocumentWithConstructor(getRxDocumentConstructor(this), this, docData);\n    doc._isTemporary = true;\n\n    this._runHooksSync('post', 'create', docData, doc);\n\n    return doc;\n  };\n\n  _proto.destroy = function destroy() {\n    if (this.destroyed) return Promise.resolve(false);\n\n    if (this._onDestroyCall) {\n      this._onDestroyCall();\n    }\n\n    this._subs.forEach(function (sub) {\n      return sub.unsubscribe();\n    });\n\n    if (this._changeEventBuffer) {\n      this._changeEventBuffer.destroy();\n    }\n\n    this._repStates.forEach(function (sync) {\n      return sync.cancel();\n    });\n\n    delete this.database.collections[this.name];\n    this.destroyed = true;\n    return Promise.resolve(true);\n  }\n  /**\n   * remove all data of the collection\n   */\n  ;\n\n  _proto.remove = function remove() {\n    return this.database.removeCollection(this.name);\n  };\n\n  _createClass(RxCollectionBase, [{\n    key: \"$\",\n    get: function get() {\n      return this._observable$;\n    }\n  }, {\n    key: \"insert$\",\n    get: function get() {\n      return this.$.pipe(filter(function (cE) {\n        return cE.operation === 'INSERT';\n      }));\n    }\n  }, {\n    key: \"update$\",\n    get: function get() {\n      return this.$.pipe(filter(function (cE) {\n        return cE.operation === 'UPDATE';\n      }));\n    }\n  }, {\n    key: \"remove$\",\n    get: function get() {\n      return this.$.pipe(filter(function (cE) {\n        return cE.operation === 'DELETE';\n      }));\n    }\n  }, {\n    key: \"onDestroy\",\n    get: function get() {\n      var _this11 = this;\n\n      if (!this._onDestroy) {\n        this._onDestroy = new Promise(function (res) {\n          return _this11._onDestroyCall = res;\n        });\n      }\n\n      return this._onDestroy;\n    }\n  }, {\n    key: \"asRxCollection\",\n    get: function get() {\n      return this;\n    }\n  }]);\n\n  return RxCollectionBase;\n}();\n/**\n * adds the hook-functions to the collections prototype\n * this runs only once\n */\n\nfunction _applyHookFunctions(collection) {\n  if (hooksApplied) return; // already run\n\n  hooksApplied = true;\n  var colProto = Object.getPrototypeOf(collection);\n  HOOKS_KEYS.forEach(function (key) {\n    HOOKS_WHEN.map(function (when) {\n      var fnName = when + ucfirst(key);\n\n      colProto[fnName] = function (fun, parallel) {\n        return this.addHook(when, key, fun, parallel);\n      };\n    });\n  });\n}\n\nfunction _atomicUpsertUpdate(doc, json) {\n  return doc.atomicUpdate(function (innerDoc) {\n    json._rev = innerDoc._rev;\n    innerDoc._data = json;\n    return innerDoc._data;\n  }).then(function () {\n    return doc;\n  });\n}\n/**\n * ensures that the given document exists\n * @return promise that resolves with new doc and flag if inserted\n */\n\n\nfunction _atomicUpsertEnsureRxDocumentExists(rxCollection, primary, json) {\n  return rxCollection.findOne(primary).exec().then(function (doc) {\n    if (!doc) {\n      return rxCollection.insert(json).then(function (newDoc) {\n        return {\n          doc: newDoc,\n          inserted: true\n        };\n      });\n    } else {\n      return {\n        doc: doc,\n        inserted: false\n      };\n    }\n  });\n}\n/**\n * creates the indexes in the pouchdb\n */\n\n\nfunction _prepareCreateIndexes(rxCollection, spawnedPouchPromise) {\n  /**\n   * pouchdb does no check on already existing indexes\n   * which makes collection re-creation really slow on page reloads\n   * So we have to manually check if the index already exists\n   */\n  return spawnedPouchPromise.then(function () {\n    return rxCollection.pouch.getIndexes();\n  }).then(function (indexResult) {\n    var existingIndexes = new Set();\n    indexResult.indexes.forEach(function (idx) {\n      return existingIndexes.add(idx.name);\n    });\n    return existingIndexes;\n  }).then(function (existingIndexes) {\n    return Promise.all(rxCollection.schema.indexes.map(function (indexAr) {\n      var compressedIdx = indexAr.map(function (key) {\n        var primPath = rxCollection.schema.primaryPath;\n        var useKey = key === primPath ? '_id' : key;\n\n        if (!rxCollection.schema.doKeyCompression()) {\n          return useKey;\n        } else {\n          var indexKey = rxCollection._keyCompressor.transformKey(useKey);\n\n          return indexKey;\n        }\n      });\n      var indexName = 'idx-rxdb-index-' + compressedIdx.join(',');\n\n      if (existingIndexes.has(indexName)) {\n        // index already exists\n        return;\n      }\n      /**\n       * TODO\n       * we might have even better performance by doing a bulkDocs\n       * on index creation\n       */\n\n\n      return spawnedPouchPromise.then(function () {\n        return rxCollection.pouch.createIndex({\n          name: indexName,\n          ddoc: indexName,\n          index: {\n            fields: compressedIdx\n          }\n        });\n      });\n    }));\n  });\n}\n/**\n * creates and prepares a new collection\n */\n\n\nexport function create(_ref2, wasCreatedBefore) {\n  var database = _ref2.database,\n      name = _ref2.name,\n      schema = _ref2.schema,\n      _ref2$pouchSettings = _ref2.pouchSettings,\n      pouchSettings = _ref2$pouchSettings === void 0 ? {} : _ref2$pouchSettings,\n      _ref2$migrationStrate = _ref2.migrationStrategies,\n      migrationStrategies = _ref2$migrationStrate === void 0 ? {} : _ref2$migrationStrate,\n      _ref2$autoMigrate = _ref2.autoMigrate,\n      autoMigrate = _ref2$autoMigrate === void 0 ? true : _ref2$autoMigrate,\n      _ref2$statics = _ref2.statics,\n      statics = _ref2$statics === void 0 ? {} : _ref2$statics,\n      _ref2$methods = _ref2.methods,\n      methods = _ref2$methods === void 0 ? {} : _ref2$methods,\n      _ref2$attachments = _ref2.attachments,\n      attachments = _ref2$attachments === void 0 ? {} : _ref2$attachments,\n      _ref2$options = _ref2.options,\n      options = _ref2$options === void 0 ? {} : _ref2$options,\n      _ref2$cacheReplacemen = _ref2.cacheReplacementPolicy,\n      cacheReplacementPolicy = _ref2$cacheReplacemen === void 0 ? defaultCacheReplacementPolicy : _ref2$cacheReplacemen;\n  validateCouchDBString(name); // ensure it is a schema-object\n\n  if (!isInstanceOfRxSchema(schema)) {\n    schema = createRxSchema(schema);\n  }\n\n  Object.keys(methods).filter(function (funName) {\n    return schema.topLevelFields.includes(funName);\n  }).forEach(function (funName) {\n    throw newRxError('COL18', {\n      funName: funName\n    });\n  });\n  var collection = new RxCollectionBase(database, name, schema, pouchSettings, migrationStrategies, methods, attachments, options, cacheReplacementPolicy, statics);\n  return collection.prepare(wasCreatedBefore).then(function () {\n    // ORM add statics\n    Object.entries(statics).forEach(function (_ref3) {\n      var funName = _ref3[0],\n          fun = _ref3[1];\n      Object.defineProperty(collection, funName, {\n        get: function get() {\n          return fun.bind(collection);\n        }\n      });\n    });\n    var ret = Promise.resolve();\n\n    if (autoMigrate && collection.schema.version !== 0) {\n      ret = collection.migratePromise();\n    }\n\n    return ret;\n  }).then(function () {\n    runPluginHooks('createRxCollection', collection);\n    return collection;\n  });\n}\nexport function isInstanceOf(obj) {\n  return obj instanceof RxCollectionBase;\n}\nexport default {\n  create: create,\n  isInstanceOf: isInstanceOf,\n  RxCollectionBase: RxCollectionBase\n};\n//# sourceMappingURL=rx-collection.js.map"]},"metadata":{},"sourceType":"module"}
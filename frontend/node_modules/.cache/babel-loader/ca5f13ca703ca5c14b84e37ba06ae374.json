{"ast":null,"code":"import { fromEvent } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport { promiseWait, nextTick } from '../util';\nimport { changeEventfromPouchChange } from '../rx-change-event';\n/**\n * listens to changes of the internal pouchdb\n * and ensures they are emitted to the internal RxChangeEvent-Stream\n */\n\nexport function watchForChanges() {\n  var _this = this; // do not call twice on same collection\n\n\n  if (this.synced) return;\n  this.synced = true;\n  this._watchForChangesUnhandled = new Set();\n  /**\n   * this will grap the changes and publish them to the rx-stream\n   * this is to ensure that changes from 'synced' dbs will be published\n   */\n\n  var pouch$ = fromEvent(this.pouch.changes({\n    since: 'now',\n    live: true,\n    include_docs: true\n  }), 'change').pipe(map(function (ar) {\n    return ar[0];\n  }) // rxjs6.x fires an array for whatever reason\n  ).subscribe(function (change) {\n    var resPromise = _handleSingleChange(_this, change); // add and remove to the Set so RxReplicationState.complete$ can know when all events where handled\n\n\n    _this._watchForChangesUnhandled.add(resPromise);\n\n    resPromise.then(function () {\n      _this._watchForChangesUnhandled[\"delete\"](resPromise);\n    });\n  });\n\n  this._subs.push(pouch$);\n}\n/**\n * handles a single change-event\n * and ensures that it is not already handled\n */\n\nfunction _handleSingleChange(collection, change) {\n  if (change.id.charAt(0) === '_') return Promise.resolve(false); // do not handle changes of internal docs\n  // wait 2 ticks and 20 ms to give the internal event-handling time to run\n\n  return promiseWait(20).then(function () {\n    return nextTick();\n  }).then(function () {\n    return nextTick();\n  }).then(function () {\n    var docData = change.doc; // already handled by internal event-stream\n\n    if (collection._changeEventBuffer.hasChangeWithRevision(docData._rev)) {\n      return false;\n    }\n\n    var cE = changeEventfromPouchChange(docData, collection);\n    collection.$emit(cE);\n    return true;\n  });\n}\n\nexport var rxdb = true;\nexport var prototypes = {\n  RxCollection: function RxCollection(proto) {\n    proto.watchForChanges = watchForChanges;\n  }\n};\nvar plugin = {\n  rxdb: rxdb,\n  prototypes: prototypes\n};\nexport default plugin;","map":{"version":3,"sources":["/Users/Hanzalah/Desktop/github/todo-offline/rxdb-hasura-demo/node_modules/rxdb/dist/es/plugins/watch-for-changes.js"],"names":["fromEvent","map","promiseWait","nextTick","changeEventfromPouchChange","watchForChanges","_this","synced","_watchForChangesUnhandled","Set","pouch$","pouch","changes","since","live","include_docs","pipe","ar","subscribe","change","resPromise","_handleSingleChange","add","then","_subs","push","collection","id","charAt","Promise","resolve","docData","doc","_changeEventBuffer","hasChangeWithRevision","_rev","cE","$emit","rxdb","prototypes","RxCollection","proto","plugin"],"mappings":"AAAA,SAASA,SAAT,QAA0B,MAA1B;AACA,SAASC,GAAT,QAAoB,gBAApB;AACA,SAASC,WAAT,EAAsBC,QAAtB,QAAsC,SAAtC;AACA,SAASC,0BAAT,QAA2C,oBAA3C;AAEA;;;;;AAIA,OAAO,SAASC,eAAT,GAA2B;AAChC,MAAIC,KAAK,GAAG,IAAZ,CADgC,CAGhC;;;AACA,MAAI,KAAKC,MAAT,EAAiB;AACjB,OAAKA,MAAL,GAAc,IAAd;AACA,OAAKC,yBAAL,GAAiC,IAAIC,GAAJ,EAAjC;AACA;;;;;AAKA,MAAIC,MAAM,GAAGV,SAAS,CAAC,KAAKW,KAAL,CAAWC,OAAX,CAAmB;AACxCC,IAAAA,KAAK,EAAE,KADiC;AAExCC,IAAAA,IAAI,EAAE,IAFkC;AAGxCC,IAAAA,YAAY,EAAE;AAH0B,GAAnB,CAAD,EAIlB,QAJkB,CAAT,CAICC,IAJD,CAIMf,GAAG,CAAC,UAAUgB,EAAV,EAAc;AACnC,WAAOA,EAAE,CAAC,CAAD,CAAT;AACD,GAFqB,CAJT,CAMV;AANU,IAOXC,SAPW,CAOD,UAAUC,MAAV,EAAkB;AAC5B,QAAIC,UAAU,GAAGC,mBAAmB,CAACf,KAAD,EAAQa,MAAR,CAApC,CAD4B,CACyB;;;AAGrDb,IAAAA,KAAK,CAACE,yBAAN,CAAgCc,GAAhC,CAAoCF,UAApC;;AAEAA,IAAAA,UAAU,CAACG,IAAX,CAAgB,YAAY;AAC1BjB,MAAAA,KAAK,CAACE,yBAAN,CAAgC,QAAhC,EAA0CY,UAA1C;AACD,KAFD;AAGD,GAhBY,CAAb;;AAkBA,OAAKI,KAAL,CAAWC,IAAX,CAAgBf,MAAhB;AACD;AACD;;;;;AAKA,SAASW,mBAAT,CAA6BK,UAA7B,EAAyCP,MAAzC,EAAiD;AAC/C,MAAIA,MAAM,CAACQ,EAAP,CAAUC,MAAV,CAAiB,CAAjB,MAAwB,GAA5B,EAAiC,OAAOC,OAAO,CAACC,OAAR,CAAgB,KAAhB,CAAP,CADc,CACiB;AAChE;;AAEA,SAAO5B,WAAW,CAAC,EAAD,CAAX,CAAgBqB,IAAhB,CAAqB,YAAY;AACtC,WAAOpB,QAAQ,EAAf;AACD,GAFM,EAEJoB,IAFI,CAEC,YAAY;AAClB,WAAOpB,QAAQ,EAAf;AACD,GAJM,EAIJoB,IAJI,CAIC,YAAY;AAClB,QAAIQ,OAAO,GAAGZ,MAAM,CAACa,GAArB,CADkB,CACQ;;AAE1B,QAAIN,UAAU,CAACO,kBAAX,CAA8BC,qBAA9B,CAAoDH,OAAO,CAACI,IAA5D,CAAJ,EAAuE;AACrE,aAAO,KAAP;AACD;;AAED,QAAIC,EAAE,GAAGhC,0BAA0B,CAAC2B,OAAD,EAAUL,UAAV,CAAnC;AACAA,IAAAA,UAAU,CAACW,KAAX,CAAiBD,EAAjB;AACA,WAAO,IAAP;AACD,GAdM,CAAP;AAeD;;AAED,OAAO,IAAIE,IAAI,GAAG,IAAX;AACP,OAAO,IAAIC,UAAU,GAAG;AACtBC,EAAAA,YAAY,EAAE,SAASA,YAAT,CAAsBC,KAAtB,EAA6B;AACzCA,IAAAA,KAAK,CAACpC,eAAN,GAAwBA,eAAxB;AACD;AAHqB,CAAjB;AAKP,IAAIqC,MAAM,GAAG;AACXJ,EAAAA,IAAI,EAAEA,IADK;AAEXC,EAAAA,UAAU,EAAEA;AAFD,CAAb;AAIA,eAAeG,MAAf","sourcesContent":["import { fromEvent } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport { promiseWait, nextTick } from '../util';\nimport { changeEventfromPouchChange } from '../rx-change-event';\n\n/**\n * listens to changes of the internal pouchdb\n * and ensures they are emitted to the internal RxChangeEvent-Stream\n */\nexport function watchForChanges() {\n  var _this = this;\n\n  // do not call twice on same collection\n  if (this.synced) return;\n  this.synced = true;\n  this._watchForChangesUnhandled = new Set();\n  /**\n   * this will grap the changes and publish them to the rx-stream\n   * this is to ensure that changes from 'synced' dbs will be published\n   */\n\n  var pouch$ = fromEvent(this.pouch.changes({\n    since: 'now',\n    live: true,\n    include_docs: true\n  }), 'change').pipe(map(function (ar) {\n    return ar[0];\n  }) // rxjs6.x fires an array for whatever reason\n  ).subscribe(function (change) {\n    var resPromise = _handleSingleChange(_this, change); // add and remove to the Set so RxReplicationState.complete$ can know when all events where handled\n\n\n    _this._watchForChangesUnhandled.add(resPromise);\n\n    resPromise.then(function () {\n      _this._watchForChangesUnhandled[\"delete\"](resPromise);\n    });\n  });\n\n  this._subs.push(pouch$);\n}\n/**\n * handles a single change-event\n * and ensures that it is not already handled\n */\n\nfunction _handleSingleChange(collection, change) {\n  if (change.id.charAt(0) === '_') return Promise.resolve(false); // do not handle changes of internal docs\n  // wait 2 ticks and 20 ms to give the internal event-handling time to run\n\n  return promiseWait(20).then(function () {\n    return nextTick();\n  }).then(function () {\n    return nextTick();\n  }).then(function () {\n    var docData = change.doc; // already handled by internal event-stream\n\n    if (collection._changeEventBuffer.hasChangeWithRevision(docData._rev)) {\n      return false;\n    }\n\n    var cE = changeEventfromPouchChange(docData, collection);\n    collection.$emit(cE);\n    return true;\n  });\n}\n\nexport var rxdb = true;\nexport var prototypes = {\n  RxCollection: function RxCollection(proto) {\n    proto.watchForChanges = watchForChanges;\n  }\n};\nvar plugin = {\n  rxdb: rxdb,\n  prototypes: prototypes\n};\nexport default plugin;\n//# sourceMappingURL=watch-for-changes.js.map"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"// We fetch all leafs of the revision tree, and sort them based on tree length\n// and whether they were deleted, undeleted documents with the longest revision\n// tree (most edits) win\n// The final sort algorithm is slightly documented in a sidebar here:\n// http://guide.couchdb.org/draft/conflicts.html\nfunction winningRev(metadata) {\n  var winningId;\n  var winningPos;\n  var winningDeleted;\n  var toVisit = metadata.rev_tree.slice();\n  var node;\n\n  while (node = toVisit.pop()) {\n    var tree = node.ids;\n    var branches = tree[2];\n    var pos = node.pos;\n\n    if (branches.length) {\n      // non-leaf\n      for (var i = 0, len = branches.length; i < len; i++) {\n        toVisit.push({\n          pos: pos + 1,\n          ids: branches[i]\n        });\n      }\n\n      continue;\n    }\n\n    var deleted = !!tree[1].deleted;\n    var id = tree[0]; // sort by deleted, then pos, then id\n\n    if (!winningId || (winningDeleted !== deleted ? winningDeleted : winningPos !== pos ? winningPos < pos : winningId < id)) {\n      winningId = id;\n      winningPos = pos;\n      winningDeleted = deleted;\n    }\n  }\n\n  return winningPos + '-' + winningId;\n} // Pretty much all below can be combined into a higher order function to\n// traverse revisions\n// The return value from the callback will be passed as context to all\n// children of that node\n\n\nfunction traverseRevTree(revs, callback) {\n  var toVisit = revs.slice();\n  var node;\n\n  while (node = toVisit.pop()) {\n    var pos = node.pos;\n    var tree = node.ids;\n    var branches = tree[2];\n    var newCtx = callback(branches.length === 0, pos, tree[0], node.ctx, tree[1]);\n\n    for (var i = 0, len = branches.length; i < len; i++) {\n      toVisit.push({\n        pos: pos + 1,\n        ids: branches[i],\n        ctx: newCtx\n      });\n    }\n  }\n}\n\nfunction sortByPos(a, b) {\n  return a.pos - b.pos;\n}\n\nfunction collectLeaves(revs) {\n  var leaves = [];\n  traverseRevTree(revs, function (isLeaf, pos, id, acc, opts) {\n    if (isLeaf) {\n      leaves.push({\n        rev: pos + \"-\" + id,\n        pos: pos,\n        opts: opts\n      });\n    }\n  });\n  leaves.sort(sortByPos).reverse();\n\n  for (var i = 0, len = leaves.length; i < len; i++) {\n    delete leaves[i].pos;\n  }\n\n  return leaves;\n} // returns revs of all conflicts that is leaves such that\n// 1. are not deleted and\n// 2. are different than winning revision\n\n\nfunction collectConflicts(metadata) {\n  var win = winningRev(metadata);\n  var leaves = collectLeaves(metadata.rev_tree);\n  var conflicts = [];\n\n  for (var i = 0, len = leaves.length; i < len; i++) {\n    var leaf = leaves[i];\n\n    if (leaf.rev !== win && !leaf.opts.deleted) {\n      conflicts.push(leaf.rev);\n    }\n  }\n\n  return conflicts;\n} // compact a tree by marking its non-leafs as missing,\n// and return a list of revs to delete\n\n\nfunction compactTree(metadata) {\n  var revs = [];\n  traverseRevTree(metadata.rev_tree, function (isLeaf, pos, revHash, ctx, opts) {\n    if (opts.status === 'available' && !isLeaf) {\n      revs.push(pos + '-' + revHash);\n      opts.status = 'missing';\n    }\n  });\n  return revs;\n} // build up a list of all the paths to the leafs in this revision tree\n\n\nfunction rootToLeaf(revs) {\n  var paths = [];\n  var toVisit = revs.slice();\n  var node;\n\n  while (node = toVisit.pop()) {\n    var pos = node.pos;\n    var tree = node.ids;\n    var id = tree[0];\n    var opts = tree[1];\n    var branches = tree[2];\n    var isLeaf = branches.length === 0;\n    var history = node.history ? node.history.slice() : [];\n    history.push({\n      id: id,\n      opts: opts\n    });\n\n    if (isLeaf) {\n      paths.push({\n        pos: pos + 1 - history.length,\n        ids: history\n      });\n    }\n\n    for (var i = 0, len = branches.length; i < len; i++) {\n      toVisit.push({\n        pos: pos + 1,\n        ids: branches[i],\n        history: history\n      });\n    }\n  }\n\n  return paths.reverse();\n} // for a better overview of what this is doing, read:\n\n\nfunction sortByPos$1(a, b) {\n  return a.pos - b.pos;\n} // classic binary search\n\n\nfunction binarySearch(arr, item, comparator) {\n  var low = 0;\n  var high = arr.length;\n  var mid;\n\n  while (low < high) {\n    mid = low + high >>> 1;\n\n    if (comparator(arr[mid], item) < 0) {\n      low = mid + 1;\n    } else {\n      high = mid;\n    }\n  }\n\n  return low;\n} // assuming the arr is sorted, insert the item in the proper place\n\n\nfunction insertSorted(arr, item, comparator) {\n  var idx = binarySearch(arr, item, comparator);\n  arr.splice(idx, 0, item);\n} // Turn a path as a flat array into a tree with a single branch.\n// If any should be stemmed from the beginning of the array, that's passed\n// in as the second argument\n\n\nfunction pathToTree(path, numStemmed) {\n  var root;\n  var leaf;\n\n  for (var i = numStemmed, len = path.length; i < len; i++) {\n    var node = path[i];\n    var currentLeaf = [node.id, node.opts, []];\n\n    if (leaf) {\n      leaf[2].push(currentLeaf);\n      leaf = currentLeaf;\n    } else {\n      root = leaf = currentLeaf;\n    }\n  }\n\n  return root;\n} // compare the IDs of two trees\n\n\nfunction compareTree(a, b) {\n  return a[0] < b[0] ? -1 : 1;\n} // Merge two trees together\n// The roots of tree1 and tree2 must be the same revision\n\n\nfunction mergeTree(in_tree1, in_tree2) {\n  var queue = [{\n    tree1: in_tree1,\n    tree2: in_tree2\n  }];\n  var conflicts = false;\n\n  while (queue.length > 0) {\n    var item = queue.pop();\n    var tree1 = item.tree1;\n    var tree2 = item.tree2;\n\n    if (tree1[1].status || tree2[1].status) {\n      tree1[1].status = tree1[1].status === 'available' || tree2[1].status === 'available' ? 'available' : 'missing';\n    }\n\n    for (var i = 0; i < tree2[2].length; i++) {\n      if (!tree1[2][0]) {\n        conflicts = 'new_leaf';\n        tree1[2][0] = tree2[2][i];\n        continue;\n      }\n\n      var merged = false;\n\n      for (var j = 0; j < tree1[2].length; j++) {\n        if (tree1[2][j][0] === tree2[2][i][0]) {\n          queue.push({\n            tree1: tree1[2][j],\n            tree2: tree2[2][i]\n          });\n          merged = true;\n        }\n      }\n\n      if (!merged) {\n        conflicts = 'new_branch';\n        insertSorted(tree1[2], tree2[2][i], compareTree);\n      }\n    }\n  }\n\n  return {\n    conflicts: conflicts,\n    tree: in_tree1\n  };\n}\n\nfunction doMerge(tree, path, dontExpand) {\n  var restree = [];\n  var conflicts = false;\n  var merged = false;\n  var res;\n\n  if (!tree.length) {\n    return {\n      tree: [path],\n      conflicts: 'new_leaf'\n    };\n  }\n\n  for (var i = 0, len = tree.length; i < len; i++) {\n    var branch = tree[i];\n\n    if (branch.pos === path.pos && branch.ids[0] === path.ids[0]) {\n      // Paths start at the same position and have the same root, so they need\n      // merged\n      res = mergeTree(branch.ids, path.ids);\n      restree.push({\n        pos: branch.pos,\n        ids: res.tree\n      });\n      conflicts = conflicts || res.conflicts;\n      merged = true;\n    } else if (dontExpand !== true) {\n      // The paths start at a different position, take the earliest path and\n      // traverse up until it as at the same point from root as the path we\n      // want to merge.  If the keys match we return the longer path with the\n      // other merged After stemming we dont want to expand the trees\n      var t1 = branch.pos < path.pos ? branch : path;\n      var t2 = branch.pos < path.pos ? path : branch;\n      var diff = t2.pos - t1.pos;\n      var candidateParents = [];\n      var trees = [];\n      trees.push({\n        ids: t1.ids,\n        diff: diff,\n        parent: null,\n        parentIdx: null\n      });\n\n      while (trees.length > 0) {\n        var item = trees.pop();\n\n        if (item.diff === 0) {\n          if (item.ids[0] === t2.ids[0]) {\n            candidateParents.push(item);\n          }\n\n          continue;\n        }\n\n        var elements = item.ids[2];\n\n        for (var j = 0, elementsLen = elements.length; j < elementsLen; j++) {\n          trees.push({\n            ids: elements[j],\n            diff: item.diff - 1,\n            parent: item.ids,\n            parentIdx: j\n          });\n        }\n      }\n\n      var el = candidateParents[0];\n\n      if (!el) {\n        restree.push(branch);\n      } else {\n        res = mergeTree(el.ids, t2.ids);\n        el.parent[2][el.parentIdx] = res.tree;\n        restree.push({\n          pos: t1.pos,\n          ids: t1.ids\n        });\n        conflicts = conflicts || res.conflicts;\n        merged = true;\n      }\n    } else {\n      restree.push(branch);\n    }\n  } // We didnt find\n\n\n  if (!merged) {\n    restree.push(path);\n  }\n\n  restree.sort(sortByPos$1);\n  return {\n    tree: restree,\n    conflicts: conflicts || 'internal_node'\n  };\n} // To ensure we dont grow the revision tree infinitely, we stem old revisions\n\n\nfunction stem(tree, depth) {\n  // First we break out the tree into a complete list of root to leaf paths\n  var paths = rootToLeaf(tree);\n  var stemmedRevs;\n  var result;\n\n  for (var i = 0, len = paths.length; i < len; i++) {\n    // Then for each path, we cut off the start of the path based on the\n    // `depth` to stem to, and generate a new set of flat trees\n    var path = paths[i];\n    var stemmed = path.ids;\n    var node;\n\n    if (stemmed.length > depth) {\n      // only do the stemming work if we actually need to stem\n      if (!stemmedRevs) {\n        stemmedRevs = {}; // avoid allocating this object unnecessarily\n      }\n\n      var numStemmed = stemmed.length - depth;\n      node = {\n        pos: path.pos + numStemmed,\n        ids: pathToTree(stemmed, numStemmed)\n      };\n\n      for (var s = 0; s < numStemmed; s++) {\n        var rev = path.pos + s + '-' + stemmed[s].id;\n        stemmedRevs[rev] = true;\n      }\n    } else {\n      // no need to actually stem\n      node = {\n        pos: path.pos,\n        ids: pathToTree(stemmed, 0)\n      };\n    } // Then we remerge all those flat trees together, ensuring that we dont\n    // connect trees that would go beyond the depth limit\n\n\n    if (result) {\n      result = doMerge(result, node, true).tree;\n    } else {\n      result = [node];\n    }\n  } // this is memory-heavy per Chrome profiler, avoid unless we actually stemmed\n\n\n  if (stemmedRevs) {\n    traverseRevTree(result, function (isLeaf, pos, revHash) {\n      // some revisions may have been removed in a branch but not in another\n      delete stemmedRevs[pos + '-' + revHash];\n    });\n  }\n\n  return {\n    tree: result,\n    revs: stemmedRevs ? Object.keys(stemmedRevs) : []\n  };\n}\n\nfunction merge(tree, path, depth) {\n  var newTree = doMerge(tree, path);\n  var stemmed = stem(newTree.tree, depth);\n  return {\n    tree: stemmed.tree,\n    stemmedRevs: stemmed.revs,\n    conflicts: newTree.conflicts\n  };\n} // return true if a rev exists in the rev tree, false otherwise\n\n\nfunction revExists(revs, rev) {\n  var toVisit = revs.slice();\n  var splitRev = rev.split('-');\n  var targetPos = parseInt(splitRev[0], 10);\n  var targetId = splitRev[1];\n  var node;\n\n  while (node = toVisit.pop()) {\n    if (node.pos === targetPos && node.ids[0] === targetId) {\n      return true;\n    }\n\n    var branches = node.ids[2];\n\n    for (var i = 0, len = branches.length; i < len; i++) {\n      toVisit.push({\n        pos: node.pos + 1,\n        ids: branches[i]\n      });\n    }\n  }\n\n  return false;\n}\n\nfunction getTrees(node) {\n  return node.ids;\n} // check if a specific revision of a doc has been deleted\n//  - metadata: the metadata object from the doc store\n//  - rev: (optional) the revision to check. defaults to winning revision\n\n\nfunction isDeleted(metadata, rev) {\n  if (!rev) {\n    rev = winningRev(metadata);\n  }\n\n  var id = rev.substring(rev.indexOf('-') + 1);\n  var toVisit = metadata.rev_tree.map(getTrees);\n  var tree;\n\n  while (tree = toVisit.pop()) {\n    if (tree[0] === id) {\n      return !!tree[1].deleted;\n    }\n\n    toVisit = toVisit.concat(tree[2]);\n  }\n}\n\nfunction isLocalId(id) {\n  return /^_local/.test(id);\n} // returns the current leaf node for a given revision\n\n\nfunction latest(rev, metadata) {\n  var toVisit = metadata.rev_tree.slice();\n  var node;\n\n  while (node = toVisit.pop()) {\n    var pos = node.pos;\n    var tree = node.ids;\n    var id = tree[0];\n    var opts = tree[1];\n    var branches = tree[2];\n    var isLeaf = branches.length === 0;\n    var history = node.history ? node.history.slice() : [];\n    history.push({\n      id: id,\n      pos: pos,\n      opts: opts\n    });\n\n    if (isLeaf) {\n      for (var i = 0, len = history.length; i < len; i++) {\n        var historyNode = history[i];\n        var historyRev = historyNode.pos + '-' + historyNode.id;\n\n        if (historyRev === rev) {\n          // return the rev of this leaf\n          return pos + '-' + id;\n        }\n      }\n    }\n\n    for (var j = 0, l = branches.length; j < l; j++) {\n      toVisit.push({\n        pos: pos + 1,\n        ids: branches[j],\n        history: history\n      });\n    }\n  }\n  /* istanbul ignore next */\n\n\n  throw new Error('Unable to resolve latest revision for id ' + metadata.id + ', rev ' + rev);\n}\n\nexport { collectConflicts, collectLeaves, compactTree, isDeleted, isLocalId, merge, revExists, rootToLeaf, traverseRevTree, winningRev, latest };","map":{"version":3,"sources":["/Users/Hanzalah/Desktop/github/todo-offline/rxdb-hasura-demo/node_modules/pouchdb-merge/lib/index.es.js"],"names":["winningRev","metadata","winningId","winningPos","winningDeleted","toVisit","rev_tree","slice","node","pop","tree","ids","branches","pos","length","i","len","push","deleted","id","traverseRevTree","revs","callback","newCtx","ctx","sortByPos","a","b","collectLeaves","leaves","isLeaf","acc","opts","rev","sort","reverse","collectConflicts","win","conflicts","leaf","compactTree","revHash","status","rootToLeaf","paths","history","sortByPos$1","binarySearch","arr","item","comparator","low","high","mid","insertSorted","idx","splice","pathToTree","path","numStemmed","root","currentLeaf","compareTree","mergeTree","in_tree1","in_tree2","queue","tree1","tree2","merged","j","doMerge","dontExpand","restree","res","branch","t1","t2","diff","candidateParents","trees","parent","parentIdx","elements","elementsLen","el","stem","depth","stemmedRevs","result","stemmed","s","Object","keys","merge","newTree","revExists","splitRev","split","targetPos","parseInt","targetId","getTrees","isDeleted","substring","indexOf","map","concat","isLocalId","test","latest","historyNode","historyRev","l","Error"],"mappings":"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","sourcesContent":["// We fetch all leafs of the revision tree, and sort them based on tree length\n// and whether they were deleted, undeleted documents with the longest revision\n// tree (most edits) win\n// The final sort algorithm is slightly documented in a sidebar here:\n// http://guide.couchdb.org/draft/conflicts.html\nfunction winningRev(metadata) {\n  var winningId;\n  var winningPos;\n  var winningDeleted;\n  var toVisit = metadata.rev_tree.slice();\n  var node;\n  while ((node = toVisit.pop())) {\n    var tree = node.ids;\n    var branches = tree[2];\n    var pos = node.pos;\n    if (branches.length) { // non-leaf\n      for (var i = 0, len = branches.length; i < len; i++) {\n        toVisit.push({pos: pos + 1, ids: branches[i]});\n      }\n      continue;\n    }\n    var deleted = !!tree[1].deleted;\n    var id = tree[0];\n    // sort by deleted, then pos, then id\n    if (!winningId || (winningDeleted !== deleted ? winningDeleted :\n        winningPos !== pos ? winningPos < pos : winningId < id)) {\n      winningId = id;\n      winningPos = pos;\n      winningDeleted = deleted;\n    }\n  }\n\n  return winningPos + '-' + winningId;\n}\n\n// Pretty much all below can be combined into a higher order function to\n// traverse revisions\n// The return value from the callback will be passed as context to all\n// children of that node\nfunction traverseRevTree(revs, callback) {\n  var toVisit = revs.slice();\n\n  var node;\n  while ((node = toVisit.pop())) {\n    var pos = node.pos;\n    var tree = node.ids;\n    var branches = tree[2];\n    var newCtx =\n      callback(branches.length === 0, pos, tree[0], node.ctx, tree[1]);\n    for (var i = 0, len = branches.length; i < len; i++) {\n      toVisit.push({pos: pos + 1, ids: branches[i], ctx: newCtx});\n    }\n  }\n}\n\nfunction sortByPos(a, b) {\n  return a.pos - b.pos;\n}\n\nfunction collectLeaves(revs) {\n  var leaves = [];\n  traverseRevTree(revs, function (isLeaf, pos, id, acc, opts) {\n    if (isLeaf) {\n      leaves.push({rev: pos + \"-\" + id, pos: pos, opts: opts});\n    }\n  });\n  leaves.sort(sortByPos).reverse();\n  for (var i = 0, len = leaves.length; i < len; i++) {\n    delete leaves[i].pos;\n  }\n  return leaves;\n}\n\n// returns revs of all conflicts that is leaves such that\n// 1. are not deleted and\n// 2. are different than winning revision\nfunction collectConflicts(metadata) {\n  var win = winningRev(metadata);\n  var leaves = collectLeaves(metadata.rev_tree);\n  var conflicts = [];\n  for (var i = 0, len = leaves.length; i < len; i++) {\n    var leaf = leaves[i];\n    if (leaf.rev !== win && !leaf.opts.deleted) {\n      conflicts.push(leaf.rev);\n    }\n  }\n  return conflicts;\n}\n\n// compact a tree by marking its non-leafs as missing,\n// and return a list of revs to delete\nfunction compactTree(metadata) {\n  var revs = [];\n  traverseRevTree(metadata.rev_tree, function (isLeaf, pos,\n                                               revHash, ctx, opts) {\n    if (opts.status === 'available' && !isLeaf) {\n      revs.push(pos + '-' + revHash);\n      opts.status = 'missing';\n    }\n  });\n  return revs;\n}\n\n// build up a list of all the paths to the leafs in this revision tree\nfunction rootToLeaf(revs) {\n  var paths = [];\n  var toVisit = revs.slice();\n  var node;\n  while ((node = toVisit.pop())) {\n    var pos = node.pos;\n    var tree = node.ids;\n    var id = tree[0];\n    var opts = tree[1];\n    var branches = tree[2];\n    var isLeaf = branches.length === 0;\n\n    var history = node.history ? node.history.slice() : [];\n    history.push({id: id, opts: opts});\n    if (isLeaf) {\n      paths.push({pos: (pos + 1 - history.length), ids: history});\n    }\n    for (var i = 0, len = branches.length; i < len; i++) {\n      toVisit.push({pos: pos + 1, ids: branches[i], history: history});\n    }\n  }\n  return paths.reverse();\n}\n\n// for a better overview of what this is doing, read:\n\nfunction sortByPos$1(a, b) {\n  return a.pos - b.pos;\n}\n\n// classic binary search\nfunction binarySearch(arr, item, comparator) {\n  var low = 0;\n  var high = arr.length;\n  var mid;\n  while (low < high) {\n    mid = (low + high) >>> 1;\n    if (comparator(arr[mid], item) < 0) {\n      low = mid + 1;\n    } else {\n      high = mid;\n    }\n  }\n  return low;\n}\n\n// assuming the arr is sorted, insert the item in the proper place\nfunction insertSorted(arr, item, comparator) {\n  var idx = binarySearch(arr, item, comparator);\n  arr.splice(idx, 0, item);\n}\n\n// Turn a path as a flat array into a tree with a single branch.\n// If any should be stemmed from the beginning of the array, that's passed\n// in as the second argument\nfunction pathToTree(path, numStemmed) {\n  var root;\n  var leaf;\n  for (var i = numStemmed, len = path.length; i < len; i++) {\n    var node = path[i];\n    var currentLeaf = [node.id, node.opts, []];\n    if (leaf) {\n      leaf[2].push(currentLeaf);\n      leaf = currentLeaf;\n    } else {\n      root = leaf = currentLeaf;\n    }\n  }\n  return root;\n}\n\n// compare the IDs of two trees\nfunction compareTree(a, b) {\n  return a[0] < b[0] ? -1 : 1;\n}\n\n// Merge two trees together\n// The roots of tree1 and tree2 must be the same revision\nfunction mergeTree(in_tree1, in_tree2) {\n  var queue = [{tree1: in_tree1, tree2: in_tree2}];\n  var conflicts = false;\n  while (queue.length > 0) {\n    var item = queue.pop();\n    var tree1 = item.tree1;\n    var tree2 = item.tree2;\n\n    if (tree1[1].status || tree2[1].status) {\n      tree1[1].status =\n        (tree1[1].status ===  'available' ||\n        tree2[1].status === 'available') ? 'available' : 'missing';\n    }\n\n    for (var i = 0; i < tree2[2].length; i++) {\n      if (!tree1[2][0]) {\n        conflicts = 'new_leaf';\n        tree1[2][0] = tree2[2][i];\n        continue;\n      }\n\n      var merged = false;\n      for (var j = 0; j < tree1[2].length; j++) {\n        if (tree1[2][j][0] === tree2[2][i][0]) {\n          queue.push({tree1: tree1[2][j], tree2: tree2[2][i]});\n          merged = true;\n        }\n      }\n      if (!merged) {\n        conflicts = 'new_branch';\n        insertSorted(tree1[2], tree2[2][i], compareTree);\n      }\n    }\n  }\n  return {conflicts: conflicts, tree: in_tree1};\n}\n\nfunction doMerge(tree, path, dontExpand) {\n  var restree = [];\n  var conflicts = false;\n  var merged = false;\n  var res;\n\n  if (!tree.length) {\n    return {tree: [path], conflicts: 'new_leaf'};\n  }\n\n  for (var i = 0, len = tree.length; i < len; i++) {\n    var branch = tree[i];\n    if (branch.pos === path.pos && branch.ids[0] === path.ids[0]) {\n      // Paths start at the same position and have the same root, so they need\n      // merged\n      res = mergeTree(branch.ids, path.ids);\n      restree.push({pos: branch.pos, ids: res.tree});\n      conflicts = conflicts || res.conflicts;\n      merged = true;\n    } else if (dontExpand !== true) {\n      // The paths start at a different position, take the earliest path and\n      // traverse up until it as at the same point from root as the path we\n      // want to merge.  If the keys match we return the longer path with the\n      // other merged After stemming we dont want to expand the trees\n\n      var t1 = branch.pos < path.pos ? branch : path;\n      var t2 = branch.pos < path.pos ? path : branch;\n      var diff = t2.pos - t1.pos;\n\n      var candidateParents = [];\n\n      var trees = [];\n      trees.push({ids: t1.ids, diff: diff, parent: null, parentIdx: null});\n      while (trees.length > 0) {\n        var item = trees.pop();\n        if (item.diff === 0) {\n          if (item.ids[0] === t2.ids[0]) {\n            candidateParents.push(item);\n          }\n          continue;\n        }\n        var elements = item.ids[2];\n        for (var j = 0, elementsLen = elements.length; j < elementsLen; j++) {\n          trees.push({\n            ids: elements[j],\n            diff: item.diff - 1,\n            parent: item.ids,\n            parentIdx: j\n          });\n        }\n      }\n\n      var el = candidateParents[0];\n\n      if (!el) {\n        restree.push(branch);\n      } else {\n        res = mergeTree(el.ids, t2.ids);\n        el.parent[2][el.parentIdx] = res.tree;\n        restree.push({pos: t1.pos, ids: t1.ids});\n        conflicts = conflicts || res.conflicts;\n        merged = true;\n      }\n    } else {\n      restree.push(branch);\n    }\n  }\n\n  // We didnt find\n  if (!merged) {\n    restree.push(path);\n  }\n\n  restree.sort(sortByPos$1);\n\n  return {\n    tree: restree,\n    conflicts: conflicts || 'internal_node'\n  };\n}\n\n// To ensure we dont grow the revision tree infinitely, we stem old revisions\nfunction stem(tree, depth) {\n  // First we break out the tree into a complete list of root to leaf paths\n  var paths = rootToLeaf(tree);\n  var stemmedRevs;\n\n  var result;\n  for (var i = 0, len = paths.length; i < len; i++) {\n    // Then for each path, we cut off the start of the path based on the\n    // `depth` to stem to, and generate a new set of flat trees\n    var path = paths[i];\n    var stemmed = path.ids;\n    var node;\n    if (stemmed.length > depth) {\n      // only do the stemming work if we actually need to stem\n      if (!stemmedRevs) {\n        stemmedRevs = {}; // avoid allocating this object unnecessarily\n      }\n      var numStemmed = stemmed.length - depth;\n      node = {\n        pos: path.pos + numStemmed,\n        ids: pathToTree(stemmed, numStemmed)\n      };\n\n      for (var s = 0; s < numStemmed; s++) {\n        var rev = (path.pos + s) + '-' + stemmed[s].id;\n        stemmedRevs[rev] = true;\n      }\n    } else { // no need to actually stem\n      node = {\n        pos: path.pos,\n        ids: pathToTree(stemmed, 0)\n      };\n    }\n\n    // Then we remerge all those flat trees together, ensuring that we dont\n    // connect trees that would go beyond the depth limit\n    if (result) {\n      result = doMerge(result, node, true).tree;\n    } else {\n      result = [node];\n    }\n  }\n\n  // this is memory-heavy per Chrome profiler, avoid unless we actually stemmed\n  if (stemmedRevs) {\n    traverseRevTree(result, function (isLeaf, pos, revHash) {\n      // some revisions may have been removed in a branch but not in another\n      delete stemmedRevs[pos + '-' + revHash];\n    });\n  }\n\n  return {\n    tree: result,\n    revs: stemmedRevs ? Object.keys(stemmedRevs) : []\n  };\n}\n\nfunction merge(tree, path, depth) {\n  var newTree = doMerge(tree, path);\n  var stemmed = stem(newTree.tree, depth);\n  return {\n    tree: stemmed.tree,\n    stemmedRevs: stemmed.revs,\n    conflicts: newTree.conflicts\n  };\n}\n\n// return true if a rev exists in the rev tree, false otherwise\nfunction revExists(revs, rev) {\n  var toVisit = revs.slice();\n  var splitRev = rev.split('-');\n  var targetPos = parseInt(splitRev[0], 10);\n  var targetId = splitRev[1];\n\n  var node;\n  while ((node = toVisit.pop())) {\n    if (node.pos === targetPos && node.ids[0] === targetId) {\n      return true;\n    }\n    var branches = node.ids[2];\n    for (var i = 0, len = branches.length; i < len; i++) {\n      toVisit.push({pos: node.pos + 1, ids: branches[i]});\n    }\n  }\n  return false;\n}\n\nfunction getTrees(node) {\n  return node.ids;\n}\n\n// check if a specific revision of a doc has been deleted\n//  - metadata: the metadata object from the doc store\n//  - rev: (optional) the revision to check. defaults to winning revision\nfunction isDeleted(metadata, rev) {\n  if (!rev) {\n    rev = winningRev(metadata);\n  }\n  var id = rev.substring(rev.indexOf('-') + 1);\n  var toVisit = metadata.rev_tree.map(getTrees);\n\n  var tree;\n  while ((tree = toVisit.pop())) {\n    if (tree[0] === id) {\n      return !!tree[1].deleted;\n    }\n    toVisit = toVisit.concat(tree[2]);\n  }\n}\n\nfunction isLocalId(id) {\n  return (/^_local/).test(id);\n}\n\n// returns the current leaf node for a given revision\nfunction latest(rev, metadata) {\n  var toVisit = metadata.rev_tree.slice();\n  var node;\n  while ((node = toVisit.pop())) {\n    var pos = node.pos;\n    var tree = node.ids;\n    var id = tree[0];\n    var opts = tree[1];\n    var branches = tree[2];\n    var isLeaf = branches.length === 0;\n\n    var history = node.history ? node.history.slice() : [];\n    history.push({id: id, pos: pos, opts: opts});\n\n    if (isLeaf) {\n      for (var i = 0, len = history.length; i < len; i++) {\n        var historyNode = history[i];\n        var historyRev = historyNode.pos + '-' + historyNode.id;\n\n        if (historyRev === rev) {\n          // return the rev of this leaf\n          return pos + '-' + id;\n        }\n      }\n    }\n\n    for (var j = 0, l = branches.length; j < l; j++) {\n      toVisit.push({pos: pos + 1, ids: branches[j], history: history});\n    }\n  }\n\n  /* istanbul ignore next */\n  throw new Error('Unable to resolve latest revision for id ' + metadata.id + ', rev ' + rev);\n}\n\nexport { collectConflicts, collectLeaves, compactTree, isDeleted, isLocalId, merge, revExists, rootToLeaf, traverseRevTree, winningRev, latest };\n"]},"metadata":{},"sourceType":"module"}
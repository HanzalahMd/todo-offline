{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n      ar.push(r.value);\n    }\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n/**\n * compress the keys of an object via the compression-table\n * @recursive\n */\n\n\nexport function compressObject(table, obj) {\n  if (typeof obj !== 'object' || obj === null) return obj;else if (Array.isArray(obj)) {\n    // array\n    return obj.map(function (item) {\n      return compressObject(table, item);\n    });\n  } else {\n    // object\n    var ret_1 = {};\n    Object.keys(obj).forEach(function (key) {\n      var compressedKey = compressedAndFlaggedKey(table, key);\n      var value = compressObject(table, obj[key]);\n      ret_1[compressedKey] = value;\n    });\n    return ret_1;\n  }\n}\n/**\n * transform an object-path\n * into its compressed version\n * e.g:\n * - input: 'names[1].firstName'\n * - ouput: '|a[1].|b'\n */\n\nexport function compressedPath(table, path) {\n  var splitted = path.split('.');\n  return splitted.map(function (subKey) {\n    var compressedKey = compressedAndFlaggedKey(table, subKey);\n    return compressedKey;\n  }).join('.');\n}\nexport function throwErrorIfCompressionFlagUsed(table, key) {\n  if (key.startsWith(table.compressionFlag)) {\n    throw new Error('cannot compress objects that start with the compression-flag: ' + table.compressionFlag + ' on key ' + key);\n  }\n}\nexport function compressedAndFlaggedKey(table, key) {\n  throwErrorIfCompressionFlagUsed(table, key);\n  /**\n   * keys could be array-accessors like myArray[4]\n   * we have to split and readd the squared brackets value\n   */\n\n  var splitSquaredBrackets = key.split('[');\n  key = splitSquaredBrackets.shift();\n  var compressedKey = table.compressedToUncompressed.get(key);\n\n  if (!compressedKey) {\n    return key;\n  } else {\n    var readdSquared = splitSquaredBrackets.length ? '[' + splitSquaredBrackets.join('[') : '';\n    return table.compressionFlag + compressedKey + readdSquared;\n  }\n}\n/**\n * compress a mango-query\n * so that it can be used to find documents\n * in a database where all documents are compressed\n */\n\nexport function compressQuery(table, query) {\n  var ret = {\n    selector: compressQuerySelector(table, query.selector)\n  };\n  if (query.skip) ret.skip = query.skip;\n  if (query.limit) ret.limit = query.limit;\n\n  if (query.fields) {\n    ret.fields = query.fields.map(function (field) {\n      return compressedPath(table, field);\n    });\n  }\n\n  if (query.sort) {\n    if (Array.isArray(query.sort)) {\n      ret.sort = query.sort.map(function (item) {\n        if (typeof item === 'string') {\n          var hasMinus = item.startsWith('-');\n\n          if (hasMinus) {\n            item = item.substr(1);\n          }\n\n          var compressedField = compressedPath(table, item);\n\n          if (hasMinus) {\n            compressedField = '-' + compressedField;\n          }\n\n          return compressedField;\n        } else {\n          return compressQuerySelector(table, item);\n        }\n      });\n    } else {\n      var compressedSort_1 = {};\n      Object.entries(query.sort).forEach(function (_a) {\n        var _b = __read(_a, 2),\n            key = _b[0],\n            direction = _b[1];\n\n        var compressedField = compressedPath(table, key);\n        compressedSort_1[compressedField] = direction;\n      });\n      ret.sort = compressedSort_1;\n    }\n  }\n\n  return ret;\n}\n/**\n * @recursive\n */\n\nexport function compressQuerySelector(table, selector) {\n  if (Array.isArray(selector)) {\n    return selector.map(function (item) {\n      return compressQuerySelector(table, item);\n    });\n  } else if (selector instanceof RegExp) {\n    return selector;\n  } else if (typeof selector === 'object' && selector !== null) {\n    var ret_2 = {};\n    Object.keys(selector).forEach(function (key) {\n      var useKey;\n\n      if (key.startsWith('$')) {\n        // operator\n        useKey = key;\n      } else {\n        // property path\n        useKey = compressedPath(table, key);\n      }\n\n      ret_2[useKey] = compressQuerySelector(table, selector[key]);\n    });\n    return ret_2;\n  } else {\n    return selector;\n  }\n}","map":{"version":3,"sources":["../../src/compress.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\n/**\n * compress the keys of an object via the compression-table\n * @recursive\n */\nexport function compressObject(table, obj) {\n    if (typeof obj !== 'object' || obj === null)\n        return obj;\n    else if (Array.isArray(obj)) {\n        // array\n        return obj\n            .map(function (item) { return compressObject(table, item); });\n    }\n    else {\n        // object\n        var ret_1 = {};\n        Object.keys(obj).forEach(function (key) {\n            var compressedKey = compressedAndFlaggedKey(table, key);\n            var value = compressObject(table, obj[key]);\n            ret_1[compressedKey] = value;\n        });\n        return ret_1;\n    }\n}\n/**\n * transform an object-path\n * into its compressed version\n * e.g:\n * - input: 'names[1].firstName'\n * - ouput: '|a[1].|b'\n */\nexport function compressedPath(table, path) {\n    var splitted = path.split('.');\n    return splitted\n        .map(function (subKey) {\n        var compressedKey = compressedAndFlaggedKey(table, subKey);\n        return compressedKey;\n    }).join('.');\n}\nexport function throwErrorIfCompressionFlagUsed(table, key) {\n    if (key.startsWith(table.compressionFlag)) {\n        throw new Error('cannot compress objects that start with the compression-flag: ' +\n            table.compressionFlag + ' on key ' + key);\n    }\n}\nexport function compressedAndFlaggedKey(table, key) {\n    throwErrorIfCompressionFlagUsed(table, key);\n    /**\n     * keys could be array-accessors like myArray[4]\n     * we have to split and readd the squared brackets value\n     */\n    var splitSquaredBrackets = key.split('[');\n    key = splitSquaredBrackets.shift();\n    var compressedKey = table.compressedToUncompressed.get(key);\n    if (!compressedKey) {\n        return key;\n    }\n    else {\n        var readdSquared = splitSquaredBrackets.length ? '[' + splitSquaredBrackets.join('[') : '';\n        return table.compressionFlag + compressedKey + readdSquared;\n    }\n}\n/**\n * compress a mango-query\n * so that it can be used to find documents\n * in a database where all documents are compressed\n */\nexport function compressQuery(table, query) {\n    var ret = {\n        selector: compressQuerySelector(table, query.selector)\n    };\n    if (query.skip)\n        ret.skip = query.skip;\n    if (query.limit)\n        ret.limit = query.limit;\n    if (query.fields) {\n        ret.fields = query.fields\n            .map(function (field) { return compressedPath(table, field); });\n    }\n    if (query.sort) {\n        if (Array.isArray(query.sort)) {\n            ret.sort = query.sort.map(function (item) {\n                if (typeof item === 'string') {\n                    var hasMinus = item.startsWith('-');\n                    if (hasMinus) {\n                        item = item.substr(1);\n                    }\n                    var compressedField = compressedPath(table, item);\n                    if (hasMinus) {\n                        compressedField = '-' + compressedField;\n                    }\n                    return compressedField;\n                }\n                else {\n                    return compressQuerySelector(table, item);\n                }\n            });\n        }\n        else {\n            var compressedSort_1 = {};\n            Object.entries(query.sort).forEach(function (_a) {\n                var _b = __read(_a, 2), key = _b[0], direction = _b[1];\n                var compressedField = compressedPath(table, key);\n                compressedSort_1[compressedField] = direction;\n            });\n            ret.sort = compressedSort_1;\n        }\n    }\n    return ret;\n}\n/**\n * @recursive\n */\nexport function compressQuerySelector(table, selector) {\n    if (Array.isArray(selector)) {\n        return selector.map(function (item) { return compressQuerySelector(table, item); });\n    }\n    else if (selector instanceof RegExp) {\n        return selector;\n    }\n    else if (typeof selector === 'object' && selector !== null) {\n        var ret_2 = {};\n        Object.keys(selector).forEach(function (key) {\n            var useKey;\n            if (key.startsWith('$')) {\n                // operator\n                useKey = key;\n            }\n            else {\n                // property path\n                useKey = compressedPath(table, key);\n            }\n            ret_2[useKey] = compressQuerySelector(table, selector[key]);\n        });\n        return ret_2;\n    }\n    else {\n        return selector;\n    }\n}\n//# sourceMappingURL=compress.js.map"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { clone, assign, nextTick, upsert, toPromise, isRemote } from 'pouchdb-utils';\nimport { generateErrorFromResponse } from 'pouchdb-errors';\nimport { Headers } from 'pouchdb-fetch';\nimport { getFieldFromDoc, setFieldInDoc, parseField, getKey, getValue, compare, massageSelector, filterInMemoryFields } from 'pouchdb-selector-core';\nimport abstractMapReduce from 'pouchdb-abstract-mapreduce';\nimport { collate } from 'pouchdb-collate';\nimport { stringMd5 } from 'pouchdb-md5'; // we restucture the supplied JSON considerably, because the official\n// Mango API is very particular about a lot of this stuff, but we like\n// to be liberal with what we accept in order to prevent mental\n// breakdowns in our users\n\nfunction massageCreateIndexRequest(requestDef) {\n  requestDef = clone(requestDef);\n\n  if (!requestDef.index) {\n    requestDef.index = {};\n  }\n\n  ['type', 'name', 'ddoc'].forEach(function (key) {\n    if (requestDef.index[key]) {\n      requestDef[key] = requestDef.index[key];\n      delete requestDef.index[key];\n    }\n  });\n\n  if (requestDef.fields) {\n    requestDef.index.fields = requestDef.fields;\n    delete requestDef.fields;\n  }\n\n  if (!requestDef.type) {\n    requestDef.type = 'json';\n  }\n\n  return requestDef;\n}\n\nfunction dbFetch(db, path, opts, callback) {\n  var status, ok;\n  opts.headers = new Headers({\n    'Content-type': 'application/json'\n  });\n  db.fetch(path, opts).then(function (response) {\n    status = response.status;\n    ok = response.ok;\n    return response.json();\n  }).then(function (json) {\n    if (!ok) {\n      json.status = status;\n      var err = generateErrorFromResponse(json);\n      callback(err);\n    } else {\n      callback(null, json);\n    }\n  }).catch(callback);\n}\n\nfunction createIndex(db, requestDef, callback) {\n  requestDef = massageCreateIndexRequest(requestDef);\n  dbFetch(db, '_index', {\n    method: 'POST',\n    body: JSON.stringify(requestDef)\n  }, callback);\n}\n\nfunction find(db, requestDef, callback) {\n  dbFetch(db, '_find', {\n    method: 'POST',\n    body: JSON.stringify(requestDef)\n  }, callback);\n}\n\nfunction explain(db, requestDef, callback) {\n  dbFetch(db, '_explain', {\n    method: 'POST',\n    body: JSON.stringify(requestDef)\n  }, callback);\n}\n\nfunction getIndexes(db, callback) {\n  dbFetch(db, '_index', {\n    method: 'GET'\n  }, callback);\n}\n\nfunction deleteIndex(db, indexDef, callback) {\n  var ddoc = indexDef.ddoc;\n  var type = indexDef.type || 'json';\n  var name = indexDef.name;\n\n  if (!ddoc) {\n    return callback(new Error('you must provide an index\\'s ddoc'));\n  }\n\n  if (!name) {\n    return callback(new Error('you must provide an index\\'s name'));\n  }\n\n  var url = '_index/' + [ddoc, type, name].map(encodeURIComponent).join('/');\n  dbFetch(db, url, {\n    method: 'DELETE'\n  }, callback);\n}\n\nfunction getArguments(fun) {\n  return function () {\n    var len = arguments.length;\n    var args = new Array(len);\n    var i = -1;\n\n    while (++i < len) {\n      args[i] = arguments[i];\n    }\n\n    return fun.call(this, args);\n  };\n}\n\nfunction callbackify(fun) {\n  return getArguments(function (args) {\n    var cb = args.pop();\n    var promise = fun.apply(this, args);\n    promisedCallback(promise, cb);\n    return promise;\n  });\n}\n\nfunction promisedCallback(promise, callback) {\n  promise.then(function (res) {\n    nextTick(function () {\n      callback(null, res);\n    });\n  }, function (reason) {\n    nextTick(function () {\n      callback(reason);\n    });\n  });\n  return promise;\n}\n\nvar flatten = getArguments(function (args) {\n  var res = [];\n\n  for (var i = 0, len = args.length; i < len; i++) {\n    var subArr = args[i];\n\n    if (Array.isArray(subArr)) {\n      res = res.concat(flatten.apply(null, subArr));\n    } else {\n      res.push(subArr);\n    }\n  }\n\n  return res;\n});\n\nfunction mergeObjects(arr) {\n  var res = {};\n\n  for (var i = 0, len = arr.length; i < len; i++) {\n    res = assign(res, arr[i]);\n  }\n\n  return res;\n} // Selects a list of fields defined in dot notation from one doc\n// and copies them to a new doc. Like underscore _.pick but supports nesting.\n\n\nfunction pick(obj, arr) {\n  var res = {};\n\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var parsedField = parseField(arr[i]);\n    var value = getFieldFromDoc(obj, parsedField);\n\n    if (typeof value !== 'undefined') {\n      setFieldInDoc(res, parsedField, value);\n    }\n  }\n\n  return res;\n} // e.g. ['a'], ['a', 'b'] is true, but ['b'], ['a', 'b'] is false\n\n\nfunction oneArrayIsSubArrayOfOther(left, right) {\n  for (var i = 0, len = Math.min(left.length, right.length); i < len; i++) {\n    if (left[i] !== right[i]) {\n      return false;\n    }\n  }\n\n  return true;\n} // e.g.['a', 'b', 'c'], ['a', 'b'] is false\n\n\nfunction oneArrayIsStrictSubArrayOfOther(left, right) {\n  if (left.length > right.length) {\n    return false;\n  }\n\n  return oneArrayIsSubArrayOfOther(left, right);\n} // same as above, but treat the left array as an unordered set\n// e.g. ['b', 'a'], ['a', 'b', 'c'] is true, but ['c'], ['a', 'b', 'c'] is false\n\n\nfunction oneSetIsSubArrayOfOther(left, right) {\n  left = left.slice();\n\n  for (var i = 0, len = right.length; i < len; i++) {\n    var field = right[i];\n\n    if (!left.length) {\n      break;\n    }\n\n    var leftIdx = left.indexOf(field);\n\n    if (leftIdx === -1) {\n      return false;\n    } else {\n      left.splice(leftIdx, 1);\n    }\n  }\n\n  return true;\n}\n\nfunction arrayToObject(arr) {\n  var res = {};\n\n  for (var i = 0, len = arr.length; i < len; i++) {\n    res[arr[i]] = true;\n  }\n\n  return res;\n}\n\nfunction max(arr, fun) {\n  var max = null;\n  var maxScore = -1;\n\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var element = arr[i];\n    var score = fun(element);\n\n    if (score > maxScore) {\n      maxScore = score;\n      max = element;\n    }\n  }\n\n  return max;\n}\n\nfunction arrayEquals(arr1, arr2) {\n  if (arr1.length !== arr2.length) {\n    return false;\n  }\n\n  for (var i = 0, len = arr1.length; i < len; i++) {\n    if (arr1[i] !== arr2[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction uniq(arr) {\n  var obj = {};\n\n  for (var i = 0; i < arr.length; i++) {\n    obj['$' + arr[i]] = true;\n  }\n\n  return Object.keys(obj).map(function (key) {\n    return key.substring(1);\n  });\n} //\n// One thing about these mappers:\n//\n// Per the advice of John-David Dalton (http://youtu.be/NthmeLEhDDM),\n// what you want to do in this case is optimize for the smallest possible\n// function, since that's the thing that gets run over and over again.\n//\n// This code would be a lot simpler if all the if/elses were inside\n// the function, but it would also be a lot less performant.\n//\n\n\nfunction createDeepMultiMapper(fields, emit) {\n  return function (doc) {\n    var toEmit = [];\n\n    for (var i = 0, iLen = fields.length; i < iLen; i++) {\n      var parsedField = parseField(fields[i]);\n      var value = doc;\n\n      for (var j = 0, jLen = parsedField.length; j < jLen; j++) {\n        var key = parsedField[j];\n        value = value[key];\n\n        if (typeof value === 'undefined') {\n          return; // don't emit\n        }\n      }\n\n      toEmit.push(value);\n    }\n\n    emit(toEmit);\n  };\n}\n\nfunction createDeepSingleMapper(field, emit) {\n  var parsedField = parseField(field);\n  return function (doc) {\n    var value = doc;\n\n    for (var i = 0, len = parsedField.length; i < len; i++) {\n      var key = parsedField[i];\n      value = value[key];\n\n      if (typeof value === 'undefined') {\n        return; // do nothing\n      }\n    }\n\n    emit(value);\n  };\n}\n\nfunction createShallowSingleMapper(field, emit) {\n  return function (doc) {\n    emit(doc[field]);\n  };\n}\n\nfunction createShallowMultiMapper(fields, emit) {\n  return function (doc) {\n    var toEmit = [];\n\n    for (var i = 0, len = fields.length; i < len; i++) {\n      toEmit.push(doc[fields[i]]);\n    }\n\n    emit(toEmit);\n  };\n}\n\nfunction checkShallow(fields) {\n  for (var i = 0, len = fields.length; i < len; i++) {\n    var field = fields[i];\n\n    if (field.indexOf('.') !== -1) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction createMapper(fields, emit) {\n  var isShallow = checkShallow(fields);\n  var isSingle = fields.length === 1; // notice we try to optimize for the most common case,\n  // i.e. single shallow indexes\n\n  if (isShallow) {\n    if (isSingle) {\n      return createShallowSingleMapper(fields[0], emit);\n    } else {\n      // multi\n      return createShallowMultiMapper(fields, emit);\n    }\n  } else {\n    // deep\n    if (isSingle) {\n      return createDeepSingleMapper(fields[0], emit);\n    } else {\n      // multi\n      return createDeepMultiMapper(fields, emit);\n    }\n  }\n}\n\nfunction mapper(mapFunDef, emit) {\n  // mapFunDef is a list of fields\n  var fields = Object.keys(mapFunDef.fields);\n  return createMapper(fields, emit);\n}\n/* istanbul ignore next */\n\n\nfunction reducer()\n/*reduceFunDef*/\n{\n  throw new Error('reduce not supported');\n}\n\nfunction ddocValidator(ddoc, viewName) {\n  var view = ddoc.views[viewName]; // This doesn't actually need to be here apparently, but\n  // I feel safer keeping it.\n\n  /* istanbul ignore if */\n\n  if (!view.map || !view.map.fields) {\n    throw new Error('ddoc ' + ddoc._id + ' with view ' + viewName + ' doesn\\'t have map.fields defined. ' + 'maybe it wasn\\'t created by this plugin?');\n  }\n}\n\nvar abstractMapper = abstractMapReduce(\n/* localDocName */\n'indexes', mapper, reducer, ddocValidator); // normalize the \"sort\" value\n\nfunction massageSort(sort) {\n  if (!Array.isArray(sort)) {\n    throw new Error('invalid sort json - should be an array');\n  }\n\n  return sort.map(function (sorting) {\n    if (typeof sorting === 'string') {\n      var obj = {};\n      obj[sorting] = 'asc';\n      return obj;\n    } else {\n      return sorting;\n    }\n  });\n}\n\nfunction massageUseIndex(useIndex) {\n  var cleanedUseIndex = [];\n\n  if (typeof useIndex === 'string') {\n    cleanedUseIndex.push(useIndex);\n  } else {\n    cleanedUseIndex = useIndex;\n  }\n\n  return cleanedUseIndex.map(function (name) {\n    return name.replace('_design/', '');\n  });\n}\n\nfunction massageIndexDef(indexDef) {\n  indexDef.fields = indexDef.fields.map(function (field) {\n    if (typeof field === 'string') {\n      var obj = {};\n      obj[field] = 'asc';\n      return obj;\n    }\n\n    return field;\n  });\n  return indexDef;\n}\n\nfunction getKeyFromDoc(doc, index) {\n  var res = [];\n\n  for (var i = 0; i < index.def.fields.length; i++) {\n    var field = getKey(index.def.fields[i]);\n    res.push(doc[field]);\n  }\n\n  return res;\n} // have to do this manually because REASONS. I don't know why\n// CouchDB didn't implement inclusive_start\n\n\nfunction filterInclusiveStart(rows, targetValue, index) {\n  var indexFields = index.def.fields;\n\n  for (var i = 0, len = rows.length; i < len; i++) {\n    var row = rows[i]; // shave off any docs at the beginning that are <= the\n    // target value\n\n    var docKey = getKeyFromDoc(row.doc, index);\n\n    if (indexFields.length === 1) {\n      docKey = docKey[0]; // only one field, not multi-field\n    } else {\n      // more than one field in index\n      // in the case where e.g. the user is searching {$gt: {a: 1}}\n      // but the index is [a, b], then we need to shorten the doc key\n      while (docKey.length > targetValue.length) {\n        docKey.pop();\n      }\n    } //ABS as we just looking for values that don't match\n\n\n    if (Math.abs(collate(docKey, targetValue)) > 0) {\n      // no need to filter any further; we're past the key\n      break;\n    }\n  }\n\n  return i > 0 ? rows.slice(i) : rows;\n}\n\nfunction reverseOptions(opts) {\n  var newOpts = clone(opts);\n  delete newOpts.startkey;\n  delete newOpts.endkey;\n  delete newOpts.inclusive_start;\n  delete newOpts.inclusive_end;\n\n  if ('endkey' in opts) {\n    newOpts.startkey = opts.endkey;\n  }\n\n  if ('startkey' in opts) {\n    newOpts.endkey = opts.startkey;\n  }\n\n  if ('inclusive_start' in opts) {\n    newOpts.inclusive_end = opts.inclusive_start;\n  }\n\n  if ('inclusive_end' in opts) {\n    newOpts.inclusive_start = opts.inclusive_end;\n  }\n\n  return newOpts;\n}\n\nfunction validateIndex(index) {\n  var ascFields = index.fields.filter(function (field) {\n    return getValue(field) === 'asc';\n  });\n\n  if (ascFields.length !== 0 && ascFields.length !== index.fields.length) {\n    throw new Error('unsupported mixed sorting');\n  }\n}\n\nfunction validateSort(requestDef, index) {\n  if (index.defaultUsed && requestDef.sort) {\n    var noneIdSorts = requestDef.sort.filter(function (sortItem) {\n      return Object.keys(sortItem)[0] !== '_id';\n    }).map(function (sortItem) {\n      return Object.keys(sortItem)[0];\n    });\n\n    if (noneIdSorts.length > 0) {\n      throw new Error('Cannot sort on field(s) \"' + noneIdSorts.join(',') + '\" when using the default index');\n    }\n  }\n\n  if (index.defaultUsed) {\n    return;\n  }\n}\n\nfunction validateFindRequest(requestDef) {\n  if (typeof requestDef.selector !== 'object') {\n    throw new Error('you must provide a selector when you find()');\n  }\n  /*var selectors = requestDef.selector['$and'] || [requestDef.selector];\n  for (var i = 0; i < selectors.length; i++) {\n    var selector = selectors[i];\n    var keys = Object.keys(selector);\n    if (keys.length === 0) {\n      throw new Error('invalid empty selector');\n    }\n    //var selection = selector[keys[0]];\n    /*if (Object.keys(selection).length !== 1) {\n      throw new Error('invalid selector: ' + JSON.stringify(selection) +\n        ' - it must have exactly one key/value');\n    }\n  }*/\n\n} // determine the maximum number of fields\n// we're going to need to query, e.g. if the user\n// has selection ['a'] and sorting ['a', 'b'], then we\n// need to use the longer of the two: ['a', 'b']\n\n\nfunction getUserFields(selector, sort) {\n  var selectorFields = Object.keys(selector);\n  var sortFields = sort ? sort.map(getKey) : [];\n  var userFields;\n\n  if (selectorFields.length >= sortFields.length) {\n    userFields = selectorFields;\n  } else {\n    userFields = sortFields;\n  }\n\n  if (sortFields.length === 0) {\n    return {\n      fields: userFields\n    };\n  } // sort according to the user's preferred sorting\n\n\n  userFields = userFields.sort(function (left, right) {\n    var leftIdx = sortFields.indexOf(left);\n\n    if (leftIdx === -1) {\n      leftIdx = Number.MAX_VALUE;\n    }\n\n    var rightIdx = sortFields.indexOf(right);\n\n    if (rightIdx === -1) {\n      rightIdx = Number.MAX_VALUE;\n    }\n\n    return leftIdx < rightIdx ? -1 : leftIdx > rightIdx ? 1 : 0;\n  });\n  return {\n    fields: userFields,\n    sortOrder: sort.map(getKey)\n  };\n}\n\nfunction createIndex$1(db, requestDef) {\n  requestDef = massageCreateIndexRequest(requestDef);\n  var originalIndexDef = clone(requestDef.index);\n  requestDef.index = massageIndexDef(requestDef.index);\n  validateIndex(requestDef.index); // calculating md5 is expensive - memoize and only\n  // run if required\n\n  var md5;\n\n  function getMd5() {\n    return md5 || (md5 = stringMd5(JSON.stringify(requestDef)));\n  }\n\n  var viewName = requestDef.name || 'idx-' + getMd5();\n  var ddocName = requestDef.ddoc || 'idx-' + getMd5();\n  var ddocId = '_design/' + ddocName;\n  var hasInvalidLanguage = false;\n  var viewExists = false;\n\n  function updateDdoc(doc) {\n    if (doc._rev && doc.language !== 'query') {\n      hasInvalidLanguage = true;\n    }\n\n    doc.language = 'query';\n    doc.views = doc.views || {};\n    viewExists = !!doc.views[viewName];\n\n    if (viewExists) {\n      return false;\n    }\n\n    doc.views[viewName] = {\n      map: {\n        fields: mergeObjects(requestDef.index.fields)\n      },\n      reduce: '_count',\n      options: {\n        def: originalIndexDef\n      }\n    };\n    return doc;\n  }\n\n  db.constructor.emit('debug', ['find', 'creating index', ddocId]);\n  return upsert(db, ddocId, updateDdoc).then(function () {\n    if (hasInvalidLanguage) {\n      throw new Error('invalid language for ddoc with id \"' + ddocId + '\" (should be \"query\")');\n    }\n  }).then(function () {\n    // kick off a build\n    // TODO: abstract-pouchdb-mapreduce should support auto-updating\n    // TODO: should also use update_after, but pouchdb/pouchdb#3415 blocks me\n    var signature = ddocName + '/' + viewName;\n    return abstractMapper.query.call(db, signature, {\n      limit: 0,\n      reduce: false\n    }).then(function () {\n      return {\n        id: ddocId,\n        name: viewName,\n        result: viewExists ? 'exists' : 'created'\n      };\n    });\n  });\n}\n\nfunction getIndexes$1(db) {\n  // just search through all the design docs and filter in-memory.\n  // hopefully there aren't that many ddocs.\n  return db.allDocs({\n    startkey: '_design/',\n    endkey: \"_design/\\uFFFF\",\n    include_docs: true\n  }).then(function (allDocsRes) {\n    var res = {\n      indexes: [{\n        ddoc: null,\n        name: '_all_docs',\n        type: 'special',\n        def: {\n          fields: [{\n            _id: 'asc'\n          }]\n        }\n      }]\n    };\n    res.indexes = flatten(res.indexes, allDocsRes.rows.filter(function (row) {\n      return row.doc.language === 'query';\n    }).map(function (row) {\n      var viewNames = row.doc.views !== undefined ? Object.keys(row.doc.views) : [];\n      return viewNames.map(function (viewName) {\n        var view = row.doc.views[viewName];\n        return {\n          ddoc: row.id,\n          name: viewName,\n          type: 'json',\n          def: massageIndexDef(view.options.def)\n        };\n      });\n    })); // these are sorted by view name for some reason\n\n    res.indexes.sort(function (left, right) {\n      return compare(left.name, right.name);\n    });\n    res.total_rows = res.indexes.length;\n    return res;\n  });\n} // couchdb lowest collation value\n\n\nvar COLLATE_LO = null; // couchdb highest collation value (TODO: well not really, but close enough amirite)\n\nvar COLLATE_HI = {\n  \"\\uFFFF\": {}\n}; // couchdb second-lowest collation value\n\nfunction checkFieldInIndex(index, field) {\n  var indexFields = index.def.fields.map(getKey);\n\n  for (var i = 0, len = indexFields.length; i < len; i++) {\n    var indexField = indexFields[i];\n\n    if (field === indexField) {\n      return true;\n    }\n  }\n\n  return false;\n} // so when you do e.g. $eq/$eq, we can do it entirely in the database.\n// but when you do e.g. $gt/$eq, the first part can be done\n// in the database, but the second part has to be done in-memory,\n// because $gt has forced us to lose precision.\n// so that's what this determines\n\n\nfunction userOperatorLosesPrecision(selector, field) {\n  var matcher = selector[field];\n  var userOperator = getKey(matcher);\n  return userOperator !== '$eq';\n} // sort the user fields by their position in the index,\n// if they're in the index\n\n\nfunction sortFieldsByIndex(userFields, index) {\n  var indexFields = index.def.fields.map(getKey);\n  return userFields.slice().sort(function (a, b) {\n    var aIdx = indexFields.indexOf(a);\n    var bIdx = indexFields.indexOf(b);\n\n    if (aIdx === -1) {\n      aIdx = Number.MAX_VALUE;\n    }\n\n    if (bIdx === -1) {\n      bIdx = Number.MAX_VALUE;\n    }\n\n    return compare(aIdx, bIdx);\n  });\n} // first pass to try to find fields that will need to be sorted in-memory\n\n\nfunction getBasicInMemoryFields(index, selector, userFields) {\n  userFields = sortFieldsByIndex(userFields, index); // check if any of the user selectors lose precision\n\n  var needToFilterInMemory = false;\n\n  for (var i = 0, len = userFields.length; i < len; i++) {\n    var field = userFields[i];\n\n    if (needToFilterInMemory || !checkFieldInIndex(index, field)) {\n      return userFields.slice(i);\n    }\n\n    if (i < len - 1 && userOperatorLosesPrecision(selector, field)) {\n      needToFilterInMemory = true;\n    }\n  }\n\n  return [];\n}\n\nfunction getInMemoryFieldsFromNe(selector) {\n  var fields = [];\n  Object.keys(selector).forEach(function (field) {\n    var matcher = selector[field];\n    Object.keys(matcher).forEach(function (operator) {\n      if (operator === '$ne') {\n        fields.push(field);\n      }\n    });\n  });\n  return fields;\n}\n\nfunction getInMemoryFields(coreInMemoryFields, index, selector, userFields) {\n  var result = flatten( // in-memory fields reported as necessary by the query planner\n  coreInMemoryFields, // combine with another pass that checks for any we may have missed\n  getBasicInMemoryFields(index, selector, userFields), // combine with another pass that checks for $ne's\n  getInMemoryFieldsFromNe(selector));\n  return sortFieldsByIndex(uniq(result), index);\n} // check that at least one field in the user's query is represented\n// in the index. order matters in the case of sorts\n\n\nfunction checkIndexFieldsMatch(indexFields, sortOrder, fields) {\n  if (sortOrder) {\n    // array has to be a strict subarray of index array. furthermore,\n    // the sortOrder fields need to all be represented in the index\n    var sortMatches = oneArrayIsStrictSubArrayOfOther(sortOrder, indexFields);\n    var selectorMatches = oneArrayIsSubArrayOfOther(fields, indexFields);\n    return sortMatches && selectorMatches;\n  } // all of the user's specified fields still need to be\n  // on the left side of the index array, although the order\n  // doesn't matter\n\n\n  return oneSetIsSubArrayOfOther(fields, indexFields);\n}\n\nvar logicalMatchers = ['$eq', '$gt', '$gte', '$lt', '$lte'];\n\nfunction isNonLogicalMatcher(matcher) {\n  return logicalMatchers.indexOf(matcher) === -1;\n} // check all the index fields for usages of '$ne'\n// e.g. if the user queries {foo: {$ne: 'foo'}, bar: {$eq: 'bar'}},\n// then we can neither use an index on ['foo'] nor an index on\n// ['foo', 'bar'], but we can use an index on ['bar'] or ['bar', 'foo']\n\n\nfunction checkFieldsLogicallySound(indexFields, selector) {\n  var firstField = indexFields[0];\n  var matcher = selector[firstField];\n\n  if (typeof matcher === 'undefined') {\n    /* istanbul ignore next */\n    return true;\n  }\n\n  var hasLogicalOperator = Object.keys(matcher).some(function (matcherKey) {\n    return !isNonLogicalMatcher(matcherKey);\n  });\n\n  if (!hasLogicalOperator) {\n    return false;\n  }\n\n  var isInvalidNe = Object.keys(matcher).length === 1 && getKey(matcher) === '$ne';\n  return !isInvalidNe;\n}\n\nfunction checkIndexMatches(index, sortOrder, fields, selector) {\n  var indexFields = index.def.fields.map(getKey);\n  var fieldsMatch = checkIndexFieldsMatch(indexFields, sortOrder, fields);\n\n  if (!fieldsMatch) {\n    return false;\n  }\n\n  return checkFieldsLogicallySound(indexFields, selector);\n} //\n// the algorithm is very simple:\n// take all the fields the user supplies, and if those fields\n// are a strict subset of the fields in some index,\n// then use that index\n//\n//\n\n\nfunction findMatchingIndexes(selector, userFields, sortOrder, indexes) {\n  return indexes.reduce(function (res, index) {\n    var indexMatches = checkIndexMatches(index, sortOrder, userFields, selector);\n\n    if (indexMatches) {\n      res.push(index);\n    }\n\n    return res;\n  }, []);\n} // find the best index, i.e. the one that matches the most fields\n// in the user's query\n\n\nfunction findBestMatchingIndex(selector, userFields, sortOrder, indexes, useIndex) {\n  var matchingIndexes = findMatchingIndexes(selector, userFields, sortOrder, indexes);\n\n  if (matchingIndexes.length === 0) {\n    if (useIndex) {\n      throw {\n        error: \"no_usable_index\",\n        message: \"There is no index available for this selector.\"\n      };\n    } //return `all_docs` as a default index;\n    //I'm assuming that _all_docs is always first\n\n\n    var defaultIndex = indexes[0];\n    defaultIndex.defaultUsed = true;\n    return defaultIndex;\n  }\n\n  if (matchingIndexes.length === 1 && !useIndex) {\n    return matchingIndexes[0];\n  }\n\n  var userFieldsMap = arrayToObject(userFields);\n\n  function scoreIndex(index) {\n    var indexFields = index.def.fields.map(getKey);\n    var score = 0;\n\n    for (var i = 0, len = indexFields.length; i < len; i++) {\n      var indexField = indexFields[i];\n\n      if (userFieldsMap[indexField]) {\n        score++;\n      }\n    }\n\n    return score;\n  }\n\n  if (useIndex) {\n    var useIndexDdoc = '_design/' + useIndex[0];\n    var useIndexName = useIndex.length === 2 ? useIndex[1] : false;\n    var index = matchingIndexes.find(function (index) {\n      if (useIndexName && index.ddoc === useIndexDdoc && useIndexName === index.name) {\n        return true;\n      }\n\n      if (index.ddoc === useIndexDdoc) {\n        /* istanbul ignore next */\n        return true;\n      }\n\n      return false;\n    });\n\n    if (!index) {\n      throw {\n        error: \"unknown_error\",\n        message: \"Could not find that index or could not use that index for the query\"\n      };\n    }\n\n    return index;\n  }\n\n  return max(matchingIndexes, scoreIndex);\n}\n\nfunction getSingleFieldQueryOptsFor(userOperator, userValue) {\n  switch (userOperator) {\n    case '$eq':\n      return {\n        key: userValue\n      };\n\n    case '$lte':\n      return {\n        endkey: userValue\n      };\n\n    case '$gte':\n      return {\n        startkey: userValue\n      };\n\n    case '$lt':\n      return {\n        endkey: userValue,\n        inclusive_end: false\n      };\n\n    case '$gt':\n      return {\n        startkey: userValue,\n        inclusive_start: false\n      };\n  }\n}\n\nfunction getSingleFieldCoreQueryPlan(selector, index) {\n  var field = getKey(index.def.fields[0]); //ignoring this because the test to exercise the branch is skipped at the moment\n\n  /* istanbul ignore next */\n\n  var matcher = selector[field] || {};\n  var inMemoryFields = [];\n  var userOperators = Object.keys(matcher);\n  var combinedOpts;\n  userOperators.forEach(function (userOperator) {\n    if (isNonLogicalMatcher(userOperator)) {\n      inMemoryFields.push(field);\n      return;\n    }\n\n    var userValue = matcher[userOperator];\n    var newQueryOpts = getSingleFieldQueryOptsFor(userOperator, userValue);\n\n    if (combinedOpts) {\n      combinedOpts = mergeObjects([combinedOpts, newQueryOpts]);\n    } else {\n      combinedOpts = newQueryOpts;\n    }\n  });\n  return {\n    queryOpts: combinedOpts,\n    inMemoryFields: inMemoryFields\n  };\n}\n\nfunction getMultiFieldCoreQueryPlan(userOperator, userValue) {\n  switch (userOperator) {\n    case '$eq':\n      return {\n        startkey: userValue,\n        endkey: userValue\n      };\n\n    case '$lte':\n      return {\n        endkey: userValue\n      };\n\n    case '$gte':\n      return {\n        startkey: userValue\n      };\n\n    case '$lt':\n      return {\n        endkey: userValue,\n        inclusive_end: false\n      };\n\n    case '$gt':\n      return {\n        startkey: userValue,\n        inclusive_start: false\n      };\n  }\n}\n\nfunction getMultiFieldQueryOpts(selector, index) {\n  var indexFields = index.def.fields.map(getKey);\n  var inMemoryFields = [];\n  var startkey = [];\n  var endkey = [];\n  var inclusiveStart;\n  var inclusiveEnd;\n\n  function finish(i) {\n    if (inclusiveStart !== false) {\n      startkey.push(COLLATE_LO);\n    }\n\n    if (inclusiveEnd !== false) {\n      endkey.push(COLLATE_HI);\n    } // keep track of the fields where we lost specificity,\n    // and therefore need to filter in-memory\n\n\n    inMemoryFields = indexFields.slice(i);\n  }\n\n  for (var i = 0, len = indexFields.length; i < len; i++) {\n    var indexField = indexFields[i];\n    var matcher = selector[indexField];\n\n    if (!matcher || !Object.keys(matcher).length) {\n      // fewer fields in user query than in index\n      finish(i);\n      break;\n    } else if (i > 0) {\n      if (Object.keys(matcher).some(isNonLogicalMatcher)) {\n        // non-logical are ignored\n        finish(i);\n        break;\n      }\n\n      var usingGtlt = '$gt' in matcher || '$gte' in matcher || '$lt' in matcher || '$lte' in matcher;\n      var previousKeys = Object.keys(selector[indexFields[i - 1]]);\n      var previousWasEq = arrayEquals(previousKeys, ['$eq']);\n      var previousWasSame = arrayEquals(previousKeys, Object.keys(matcher));\n      var gtltLostSpecificity = usingGtlt && !previousWasEq && !previousWasSame;\n\n      if (gtltLostSpecificity) {\n        finish(i);\n        break;\n      }\n    }\n\n    var userOperators = Object.keys(matcher);\n    var combinedOpts = null;\n\n    for (var j = 0; j < userOperators.length; j++) {\n      var userOperator = userOperators[j];\n      var userValue = matcher[userOperator];\n      var newOpts = getMultiFieldCoreQueryPlan(userOperator, userValue);\n\n      if (combinedOpts) {\n        combinedOpts = mergeObjects([combinedOpts, newOpts]);\n      } else {\n        combinedOpts = newOpts;\n      }\n    }\n\n    startkey.push('startkey' in combinedOpts ? combinedOpts.startkey : COLLATE_LO);\n    endkey.push('endkey' in combinedOpts ? combinedOpts.endkey : COLLATE_HI);\n\n    if ('inclusive_start' in combinedOpts) {\n      inclusiveStart = combinedOpts.inclusive_start;\n    }\n\n    if ('inclusive_end' in combinedOpts) {\n      inclusiveEnd = combinedOpts.inclusive_end;\n    }\n  }\n\n  var res = {\n    startkey: startkey,\n    endkey: endkey\n  };\n\n  if (typeof inclusiveStart !== 'undefined') {\n    res.inclusive_start = inclusiveStart;\n  }\n\n  if (typeof inclusiveEnd !== 'undefined') {\n    res.inclusive_end = inclusiveEnd;\n  }\n\n  return {\n    queryOpts: res,\n    inMemoryFields: inMemoryFields\n  };\n}\n\nfunction getDefaultQueryPlan(selector) {\n  //using default index, so all fields need to be done in memory\n  return {\n    queryOpts: {\n      startkey: null\n    },\n    inMemoryFields: [Object.keys(selector)]\n  };\n}\n\nfunction getCoreQueryPlan(selector, index) {\n  if (index.defaultUsed) {\n    return getDefaultQueryPlan(selector, index);\n  }\n\n  if (index.def.fields.length === 1) {\n    // one field in index, so the value was indexed as a singleton\n    return getSingleFieldCoreQueryPlan(selector, index);\n  } // else index has multiple fields, so the value was indexed as an array\n\n\n  return getMultiFieldQueryOpts(selector, index);\n}\n\nfunction planQuery(request, indexes) {\n  var selector = request.selector;\n  var sort = request.sort;\n  var userFieldsRes = getUserFields(selector, sort);\n  var userFields = userFieldsRes.fields;\n  var sortOrder = userFieldsRes.sortOrder;\n  var index = findBestMatchingIndex(selector, userFields, sortOrder, indexes, request.use_index);\n  var coreQueryPlan = getCoreQueryPlan(selector, index);\n  var queryOpts = coreQueryPlan.queryOpts;\n  var coreInMemoryFields = coreQueryPlan.inMemoryFields;\n  var inMemoryFields = getInMemoryFields(coreInMemoryFields, index, selector, userFields);\n  var res = {\n    queryOpts: queryOpts,\n    index: index,\n    inMemoryFields: inMemoryFields\n  };\n  return res;\n}\n\nfunction indexToSignature(index) {\n  // remove '_design/'\n  return index.ddoc.substring(8) + '/' + index.name;\n}\n\nfunction doAllDocs(db, originalOpts) {\n  var opts = clone(originalOpts); // CouchDB responds in weird ways when you provide a non-string to _id;\n  // we mimic the behavior for consistency. See issue66 tests for details.\n\n  if (opts.descending) {\n    if ('endkey' in opts && typeof opts.endkey !== 'string') {\n      opts.endkey = '';\n    }\n\n    if ('startkey' in opts && typeof opts.startkey !== 'string') {\n      opts.limit = 0;\n    }\n  } else {\n    if ('startkey' in opts && typeof opts.startkey !== 'string') {\n      opts.startkey = '';\n    }\n\n    if ('endkey' in opts && typeof opts.endkey !== 'string') {\n      opts.limit = 0;\n    }\n  }\n\n  if ('key' in opts && typeof opts.key !== 'string') {\n    opts.limit = 0;\n  }\n\n  return db.allDocs(opts).then(function (res) {\n    // filter out any design docs that _all_docs might return\n    res.rows = res.rows.filter(function (row) {\n      return !/^_design\\//.test(row.id);\n    });\n    return res;\n  });\n}\n\nfunction find$1(db, requestDef, explain) {\n  if (requestDef.selector) {\n    requestDef.selector = massageSelector(requestDef.selector);\n  }\n\n  if (requestDef.sort) {\n    requestDef.sort = massageSort(requestDef.sort);\n  }\n\n  if (requestDef.use_index) {\n    requestDef.use_index = massageUseIndex(requestDef.use_index);\n  }\n\n  validateFindRequest(requestDef);\n  return getIndexes$1(db).then(function (getIndexesRes) {\n    db.constructor.emit('debug', ['find', 'planning query', requestDef]);\n    var queryPlan = planQuery(requestDef, getIndexesRes.indexes);\n    db.constructor.emit('debug', ['find', 'query plan', queryPlan]);\n    var indexToUse = queryPlan.index;\n    validateSort(requestDef, indexToUse);\n    var opts = assign({\n      include_docs: true,\n      reduce: false\n    }, queryPlan.queryOpts);\n\n    if ('startkey' in opts && 'endkey' in opts && collate(opts.startkey, opts.endkey) > 0) {\n      // can't possibly return any results, startkey > endkey\n\n      /* istanbul ignore next */\n      return {\n        docs: []\n      };\n    }\n\n    var isDescending = requestDef.sort && typeof requestDef.sort[0] !== 'string' && getValue(requestDef.sort[0]) === 'desc';\n\n    if (isDescending) {\n      // either all descending or all ascending\n      opts.descending = true;\n      opts = reverseOptions(opts);\n    }\n\n    if (!queryPlan.inMemoryFields.length) {\n      // no in-memory filtering necessary, so we can let the\n      // database do the limit/skip for us\n      if ('limit' in requestDef) {\n        opts.limit = requestDef.limit;\n      }\n\n      if ('skip' in requestDef) {\n        opts.skip = requestDef.skip;\n      }\n    }\n\n    if (explain) {\n      return Promise.resolve(queryPlan, opts);\n    }\n\n    return Promise.resolve().then(function () {\n      if (indexToUse.name === '_all_docs') {\n        return doAllDocs(db, opts);\n      } else {\n        var signature = indexToSignature(indexToUse);\n        return abstractMapper.query.call(db, signature, opts);\n      }\n    }).then(function (res) {\n      if (opts.inclusive_start === false) {\n        // may have to manually filter the first one,\n        // since couchdb has no true inclusive_start option\n        res.rows = filterInclusiveStart(res.rows, opts.startkey, indexToUse);\n      }\n\n      if (queryPlan.inMemoryFields.length) {\n        // need to filter some stuff in-memory\n        res.rows = filterInMemoryFields(res.rows, requestDef, queryPlan.inMemoryFields);\n      }\n\n      var resp = {\n        docs: res.rows.map(function (row) {\n          var doc = row.doc;\n\n          if (requestDef.fields) {\n            return pick(doc, requestDef.fields);\n          }\n\n          return doc;\n        })\n      };\n\n      if (indexToUse.defaultUsed) {\n        resp.warning = 'no matching index found, create an index to optimize query time';\n      }\n\n      return resp;\n    });\n  });\n}\n\nfunction explain$1(db, requestDef) {\n  return find$1(db, requestDef, true).then(function (queryPlan) {\n    return {\n      dbname: db.name,\n      index: queryPlan.index,\n      selector: requestDef.selector,\n      range: {\n        start_key: queryPlan.queryOpts.startkey,\n        end_key: queryPlan.queryOpts.endkey\n      },\n      opts: {\n        use_index: requestDef.use_index || [],\n        bookmark: \"nil\",\n        //hardcoded to match CouchDB since its not supported,\n        limit: requestDef.limit,\n        skip: requestDef.skip,\n        sort: requestDef.sort || {},\n        fields: requestDef.fields,\n        conflicts: false,\n        //hardcoded to match CouchDB since its not supported,\n        r: [49] // hardcoded to match CouchDB since its not support\n\n      },\n      limit: requestDef.limit,\n      skip: requestDef.skip || 0,\n      fields: requestDef.fields\n    };\n  });\n}\n\nfunction deleteIndex$1(db, index) {\n  if (!index.ddoc) {\n    throw new Error('you must supply an index.ddoc when deleting');\n  }\n\n  if (!index.name) {\n    throw new Error('you must supply an index.name when deleting');\n  }\n\n  var docId = index.ddoc;\n  var viewName = index.name;\n\n  function deltaFun(doc) {\n    if (Object.keys(doc.views).length === 1 && doc.views[viewName]) {\n      // only one view in this ddoc, delete the whole ddoc\n      return {\n        _id: docId,\n        _deleted: true\n      };\n    } // more than one view here, just remove the view\n\n\n    delete doc.views[viewName];\n    return doc;\n  }\n\n  return upsert(db, docId, deltaFun).then(function () {\n    return abstractMapper.viewCleanup.apply(db);\n  }).then(function () {\n    return {\n      ok: true\n    };\n  });\n}\n\nvar createIndexAsCallback = callbackify(createIndex$1);\nvar findAsCallback = callbackify(find$1);\nvar explainAsCallback = callbackify(explain$1);\nvar getIndexesAsCallback = callbackify(getIndexes$1);\nvar deleteIndexAsCallback = callbackify(deleteIndex$1);\nvar plugin = {};\nplugin.createIndex = toPromise(function (requestDef, callback) {\n  if (typeof requestDef !== 'object') {\n    return callback(new Error('you must provide an index to create'));\n  }\n\n  var createIndex$$1 = isRemote(this) ? createIndex : createIndexAsCallback;\n  createIndex$$1(this, requestDef, callback);\n});\nplugin.find = toPromise(function (requestDef, callback) {\n  if (typeof callback === 'undefined') {\n    callback = requestDef;\n    requestDef = undefined;\n  }\n\n  if (typeof requestDef !== 'object') {\n    return callback(new Error('you must provide search parameters to find()'));\n  }\n\n  var find$$1 = isRemote(this) ? find : findAsCallback;\n  find$$1(this, requestDef, callback);\n});\nplugin.explain = toPromise(function (requestDef, callback) {\n  if (typeof callback === 'undefined') {\n    callback = requestDef;\n    requestDef = undefined;\n  }\n\n  if (typeof requestDef !== 'object') {\n    return callback(new Error('you must provide search parameters to explain()'));\n  }\n\n  var find$$1 = isRemote(this) ? explain : explainAsCallback;\n  find$$1(this, requestDef, callback);\n});\nplugin.getIndexes = toPromise(function (callback) {\n  var getIndexes$$1 = isRemote(this) ? getIndexes : getIndexesAsCallback;\n  getIndexes$$1(this, callback);\n});\nplugin.deleteIndex = toPromise(function (indexDef, callback) {\n  if (typeof indexDef !== 'object') {\n    return callback(new Error('you must provide an index to delete'));\n  }\n\n  var deleteIndex$$1 = isRemote(this) ? deleteIndex : deleteIndexAsCallback;\n  deleteIndex$$1(this, indexDef, callback);\n});\nexport default plugin;","map":{"version":3,"sources":["/Users/Hanzalah/Desktop/github/todo-offline/rxdb-hasura-demo/node_modules/pouchdb-find/lib/index-browser.es.js"],"names":["clone","assign","nextTick","upsert","toPromise","isRemote","generateErrorFromResponse","Headers","getFieldFromDoc","setFieldInDoc","parseField","getKey","getValue","compare","massageSelector","filterInMemoryFields","abstractMapReduce","collate","stringMd5","massageCreateIndexRequest","requestDef","index","forEach","key","fields","type","dbFetch","db","path","opts","callback","status","ok","headers","fetch","then","response","json","err","catch","createIndex","method","body","JSON","stringify","find","explain","getIndexes","deleteIndex","indexDef","ddoc","name","Error","url","map","encodeURIComponent","join","getArguments","fun","len","arguments","length","args","Array","i","call","callbackify","cb","pop","promise","apply","promisedCallback","res","reason","flatten","subArr","isArray","concat","push","mergeObjects","arr","pick","obj","parsedField","value","oneArrayIsSubArrayOfOther","left","right","Math","min","oneArrayIsStrictSubArrayOfOther","oneSetIsSubArrayOfOther","slice","field","leftIdx","indexOf","splice","arrayToObject","max","maxScore","element","score","arrayEquals","arr1","arr2","uniq","Object","keys","substring","createDeepMultiMapper","emit","doc","toEmit","iLen","j","jLen","createDeepSingleMapper","createShallowSingleMapper","createShallowMultiMapper","checkShallow","createMapper","isShallow","isSingle","mapper","mapFunDef","reducer","ddocValidator","viewName","view","views","_id","abstractMapper","massageSort","sort","sorting","massageUseIndex","useIndex","cleanedUseIndex","replace","massageIndexDef","getKeyFromDoc","def","filterInclusiveStart","rows","targetValue","indexFields","row","docKey","abs","reverseOptions","newOpts","startkey","endkey","inclusive_start","inclusive_end","validateIndex","ascFields","filter","validateSort","defaultUsed","noneIdSorts","sortItem","validateFindRequest","selector","getUserFields","selectorFields","sortFields","userFields","Number","MAX_VALUE","rightIdx","sortOrder","createIndex$1","originalIndexDef","md5","getMd5","ddocName","ddocId","hasInvalidLanguage","viewExists","updateDdoc","_rev","language","reduce","options","constructor","signature","query","limit","id","result","getIndexes$1","allDocs","include_docs","allDocsRes","indexes","viewNames","undefined","total_rows","COLLATE_LO","COLLATE_HI","checkFieldInIndex","indexField","userOperatorLosesPrecision","matcher","userOperator","sortFieldsByIndex","a","b","aIdx","bIdx","getBasicInMemoryFields","needToFilterInMemory","getInMemoryFieldsFromNe","operator","getInMemoryFields","coreInMemoryFields","checkIndexFieldsMatch","sortMatches","selectorMatches","logicalMatchers","isNonLogicalMatcher","checkFieldsLogicallySound","firstField","hasLogicalOperator","some","matcherKey","isInvalidNe","checkIndexMatches","fieldsMatch","findMatchingIndexes","indexMatches","findBestMatchingIndex","matchingIndexes","error","message","defaultIndex","userFieldsMap","scoreIndex","useIndexDdoc","useIndexName","getSingleFieldQueryOptsFor","userValue","getSingleFieldCoreQueryPlan","inMemoryFields","userOperators","combinedOpts","newQueryOpts","queryOpts","getMultiFieldCoreQueryPlan","getMultiFieldQueryOpts","inclusiveStart","inclusiveEnd","finish","usingGtlt","previousKeys","previousWasEq","previousWasSame","gtltLostSpecificity","getDefaultQueryPlan","getCoreQueryPlan","planQuery","request","userFieldsRes","use_index","coreQueryPlan","indexToSignature","doAllDocs","originalOpts","descending","test","find$1","getIndexesRes","queryPlan","indexToUse","docs","isDescending","skip","Promise","resolve","resp","warning","explain$1","dbname","range","start_key","end_key","bookmark","conflicts","r","deleteIndex$1","docId","deltaFun","_deleted","viewCleanup","createIndexAsCallback","findAsCallback","explainAsCallback","getIndexesAsCallback","deleteIndexAsCallback","plugin","createIndex$$1","find$$1","getIndexes$$1","deleteIndex$$1"],"mappings":"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","sourcesContent":["import { clone, assign, nextTick, upsert, toPromise, isRemote } from 'pouchdb-utils';\nimport { generateErrorFromResponse } from 'pouchdb-errors';\nimport { Headers } from 'pouchdb-fetch';\nimport { getFieldFromDoc, setFieldInDoc, parseField, getKey, getValue, compare, massageSelector, filterInMemoryFields } from 'pouchdb-selector-core';\nimport abstractMapReduce from 'pouchdb-abstract-mapreduce';\nimport { collate } from 'pouchdb-collate';\nimport { stringMd5 } from 'pouchdb-md5';\n\n// we restucture the supplied JSON considerably, because the official\n// Mango API is very particular about a lot of this stuff, but we like\n// to be liberal with what we accept in order to prevent mental\n// breakdowns in our users\nfunction massageCreateIndexRequest(requestDef) {\n  requestDef = clone(requestDef);\n\n  if (!requestDef.index) {\n    requestDef.index = {};\n  }\n\n  ['type', 'name', 'ddoc'].forEach(function (key) {\n    if (requestDef.index[key]) {\n      requestDef[key] = requestDef.index[key];\n      delete requestDef.index[key];\n    }\n  });\n\n  if (requestDef.fields) {\n    requestDef.index.fields = requestDef.fields;\n    delete requestDef.fields;\n  }\n\n  if (!requestDef.type) {\n    requestDef.type = 'json';\n  }\n  return requestDef;\n}\n\nfunction dbFetch(db, path, opts, callback) {\n  var status, ok;\n  opts.headers = new Headers({'Content-type': 'application/json'});\n  db.fetch(path, opts).then(function (response) {\n    status = response.status;\n    ok = response.ok;\n    return response.json();\n  }).then(function (json) {\n    if (!ok) {\n      json.status = status;\n      var err = generateErrorFromResponse(json);\n      callback(err);\n    } else {\n      callback(null, json);\n    }\n  }).catch(callback);\n}\n\nfunction createIndex(db, requestDef, callback) {\n  requestDef = massageCreateIndexRequest(requestDef);\n  dbFetch(db, '_index', {\n    method: 'POST',\n    body: JSON.stringify(requestDef)\n  }, callback);\n}\n\nfunction find(db, requestDef, callback) {\n  dbFetch(db, '_find', {\n    method: 'POST',\n    body: JSON.stringify(requestDef)\n  }, callback);\n}\n\nfunction explain(db, requestDef, callback) {\n  dbFetch(db, '_explain', {\n    method: 'POST',\n    body: JSON.stringify(requestDef)\n  }, callback);\n}\n\nfunction getIndexes(db, callback) {\n  dbFetch(db, '_index', {\n    method: 'GET'\n  }, callback);\n}\n\nfunction deleteIndex(db, indexDef, callback) {\n\n\n  var ddoc = indexDef.ddoc;\n  var type = indexDef.type || 'json';\n  var name = indexDef.name;\n\n  if (!ddoc) {\n    return callback(new Error('you must provide an index\\'s ddoc'));\n  }\n\n  if (!name) {\n    return callback(new Error('you must provide an index\\'s name'));\n  }\n\n  var url = '_index/' + [ddoc, type, name].map(encodeURIComponent).join('/');\n\n  dbFetch(db, url, {method: 'DELETE'}, callback);\n}\n\nfunction getArguments(fun) {\n  return function () {\n    var len = arguments.length;\n    var args = new Array(len);\n    var i = -1;\n    while (++i < len) {\n      args[i] = arguments[i];\n    }\n    return fun.call(this, args);\n  };\n}\n\nfunction callbackify(fun) {\n  return getArguments(function (args) {\n    var cb = args.pop();\n    var promise = fun.apply(this, args);\n    promisedCallback(promise, cb);\n    return promise;\n  });\n}\n\nfunction promisedCallback(promise, callback) {\n  promise.then(function (res) {\n    nextTick(function () {\n      callback(null, res);\n    });\n  }, function (reason) {\n    nextTick(function () {\n      callback(reason);\n    });\n  });\n  return promise;\n}\n\nvar flatten = getArguments(function (args) {\n  var res = [];\n  for (var i = 0, len = args.length; i < len; i++) {\n    var subArr = args[i];\n    if (Array.isArray(subArr)) {\n      res = res.concat(flatten.apply(null, subArr));\n    } else {\n      res.push(subArr);\n    }\n  }\n  return res;\n});\n\nfunction mergeObjects(arr) {\n  var res = {};\n  for (var i = 0, len = arr.length; i < len; i++) {\n    res = assign(res, arr[i]);\n  }\n  return res;\n}\n\n// Selects a list of fields defined in dot notation from one doc\n// and copies them to a new doc. Like underscore _.pick but supports nesting.\nfunction pick(obj, arr) {\n  var res = {};\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var parsedField = parseField(arr[i]);\n    var value = getFieldFromDoc(obj, parsedField);\n    if (typeof value !== 'undefined') {\n      setFieldInDoc(res, parsedField, value);\n    }\n  }\n  return res;\n}\n\n// e.g. ['a'], ['a', 'b'] is true, but ['b'], ['a', 'b'] is false\nfunction oneArrayIsSubArrayOfOther(left, right) {\n\n  for (var i = 0, len = Math.min(left.length, right.length); i < len; i++) {\n    if (left[i] !== right[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// e.g.['a', 'b', 'c'], ['a', 'b'] is false\nfunction oneArrayIsStrictSubArrayOfOther(left, right) {\n\n  if (left.length > right.length) {\n    return false;\n  }\n\n  return oneArrayIsSubArrayOfOther(left, right);\n}\n\n// same as above, but treat the left array as an unordered set\n// e.g. ['b', 'a'], ['a', 'b', 'c'] is true, but ['c'], ['a', 'b', 'c'] is false\nfunction oneSetIsSubArrayOfOther(left, right) {\n  left = left.slice();\n  for (var i = 0, len = right.length; i < len; i++) {\n    var field = right[i];\n    if (!left.length) {\n      break;\n    }\n    var leftIdx = left.indexOf(field);\n    if (leftIdx === -1) {\n      return false;\n    } else {\n      left.splice(leftIdx, 1);\n    }\n  }\n  return true;\n}\n\nfunction arrayToObject(arr) {\n  var res = {};\n  for (var i = 0, len = arr.length; i < len; i++) {\n    res[arr[i]] = true;\n  }\n  return res;\n}\n\nfunction max(arr, fun) {\n  var max = null;\n  var maxScore = -1;\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var element = arr[i];\n    var score = fun(element);\n    if (score > maxScore) {\n      maxScore = score;\n      max = element;\n    }\n  }\n  return max;\n}\n\nfunction arrayEquals(arr1, arr2) {\n  if (arr1.length !== arr2.length) {\n    return false;\n  }\n  for (var i = 0, len = arr1.length; i < len; i++) {\n    if (arr1[i] !== arr2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction uniq(arr) {\n  var obj = {};\n  for (var i = 0; i < arr.length; i++) {\n    obj['$' + arr[i]] = true;\n  }\n  return Object.keys(obj).map(function (key) {\n    return key.substring(1);\n  });\n}\n\n//\n// One thing about these mappers:\n//\n// Per the advice of John-David Dalton (http://youtu.be/NthmeLEhDDM),\n// what you want to do in this case is optimize for the smallest possible\n// function, since that's the thing that gets run over and over again.\n//\n// This code would be a lot simpler if all the if/elses were inside\n// the function, but it would also be a lot less performant.\n//\n\n\nfunction createDeepMultiMapper(fields, emit) {\n  return function (doc) {\n    var toEmit = [];\n    for (var i = 0, iLen = fields.length; i < iLen; i++) {\n      var parsedField = parseField(fields[i]);\n      var value = doc;\n      for (var j = 0, jLen = parsedField.length; j < jLen; j++) {\n        var key = parsedField[j];\n        value = value[key];\n        if (typeof value === 'undefined') {\n          return; // don't emit\n        }\n      }\n      toEmit.push(value);\n    }\n    emit(toEmit);\n  };\n}\n\nfunction createDeepSingleMapper(field, emit) {\n  var parsedField = parseField(field);\n  return function (doc) {\n    var value = doc;\n    for (var i = 0, len = parsedField.length; i < len; i++) {\n      var key = parsedField[i];\n      value = value[key];\n      if (typeof value === 'undefined') {\n        return; // do nothing\n      }\n    }\n    emit(value);\n  };\n}\n\nfunction createShallowSingleMapper(field, emit) {\n  return function (doc) {\n    emit(doc[field]);\n  };\n}\n\nfunction createShallowMultiMapper(fields, emit) {\n  return function (doc) {\n    var toEmit = [];\n    for (var i = 0, len = fields.length; i < len; i++) {\n      toEmit.push(doc[fields[i]]);\n    }\n    emit(toEmit);\n  };\n}\n\nfunction checkShallow(fields) {\n  for (var i = 0, len = fields.length; i < len; i++) {\n    var field = fields[i];\n    if (field.indexOf('.') !== -1) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction createMapper(fields, emit) {\n  var isShallow = checkShallow(fields);\n  var isSingle = fields.length === 1;\n\n  // notice we try to optimize for the most common case,\n  // i.e. single shallow indexes\n  if (isShallow) {\n    if (isSingle) {\n      return createShallowSingleMapper(fields[0], emit);\n    } else { // multi\n      return createShallowMultiMapper(fields, emit);\n    }\n  } else { // deep\n    if (isSingle) {\n      return createDeepSingleMapper(fields[0], emit);\n    } else { // multi\n      return createDeepMultiMapper(fields, emit);\n    }\n  }\n}\n\nfunction mapper(mapFunDef, emit) {\n  // mapFunDef is a list of fields\n\n  var fields = Object.keys(mapFunDef.fields);\n\n  return createMapper(fields, emit);\n}\n\n/* istanbul ignore next */\nfunction reducer(/*reduceFunDef*/) {\n  throw new Error('reduce not supported');\n}\n\nfunction ddocValidator(ddoc, viewName) {\n  var view = ddoc.views[viewName];\n  // This doesn't actually need to be here apparently, but\n  // I feel safer keeping it.\n  /* istanbul ignore if */\n  if (!view.map || !view.map.fields) {\n    throw new Error('ddoc ' + ddoc._id +' with view ' + viewName +\n      ' doesn\\'t have map.fields defined. ' +\n      'maybe it wasn\\'t created by this plugin?');\n  }\n}\n\nvar abstractMapper = abstractMapReduce(\n  /* localDocName */ 'indexes',\n  mapper,\n  reducer,\n  ddocValidator\n);\n\n// normalize the \"sort\" value\nfunction massageSort(sort) {\n  if (!Array.isArray(sort)) {\n    throw new Error('invalid sort json - should be an array');\n  }\n  return sort.map(function (sorting) {\n    if (typeof sorting === 'string') {\n      var obj = {};\n      obj[sorting] = 'asc';\n      return obj;\n    } else {\n      return sorting;\n    }\n  });\n}\n\nfunction massageUseIndex(useIndex) {\n  var cleanedUseIndex = [];\n  if (typeof useIndex === 'string') {\n    cleanedUseIndex.push(useIndex);\n  } else {\n    cleanedUseIndex = useIndex;\n  }\n\n  return cleanedUseIndex.map(function (name) {\n    return name.replace('_design/', '');\n  });\n}\n\nfunction massageIndexDef(indexDef) {\n  indexDef.fields = indexDef.fields.map(function (field) {\n    if (typeof field === 'string') {\n      var obj = {};\n      obj[field] = 'asc';\n      return obj;\n    }\n    return field;\n  });\n  return indexDef;\n}\n\nfunction getKeyFromDoc(doc, index) {\n  var res = [];\n  for (var i = 0; i < index.def.fields.length; i++) {\n    var field = getKey(index.def.fields[i]);\n    res.push(doc[field]);\n  }\n  return res;\n}\n\n// have to do this manually because REASONS. I don't know why\n// CouchDB didn't implement inclusive_start\nfunction filterInclusiveStart(rows, targetValue, index) {\n  var indexFields = index.def.fields;\n  for (var i = 0, len = rows.length; i < len; i++) {\n    var row = rows[i];\n\n    // shave off any docs at the beginning that are <= the\n    // target value\n\n    var docKey = getKeyFromDoc(row.doc, index);\n    if (indexFields.length === 1) {\n      docKey = docKey[0]; // only one field, not multi-field\n    } else { // more than one field in index\n      // in the case where e.g. the user is searching {$gt: {a: 1}}\n      // but the index is [a, b], then we need to shorten the doc key\n      while (docKey.length > targetValue.length) {\n        docKey.pop();\n      }\n    }\n    //ABS as we just looking for values that don't match\n    if (Math.abs(collate(docKey, targetValue)) > 0) {\n      // no need to filter any further; we're past the key\n      break;\n    }\n  }\n  return i > 0 ? rows.slice(i) : rows;\n}\n\nfunction reverseOptions(opts) {\n  var newOpts = clone(opts);\n  delete newOpts.startkey;\n  delete newOpts.endkey;\n  delete newOpts.inclusive_start;\n  delete newOpts.inclusive_end;\n\n  if ('endkey' in opts) {\n    newOpts.startkey = opts.endkey;\n  }\n  if ('startkey' in opts) {\n    newOpts.endkey = opts.startkey;\n  }\n  if ('inclusive_start' in opts) {\n    newOpts.inclusive_end = opts.inclusive_start;\n  }\n  if ('inclusive_end' in opts) {\n    newOpts.inclusive_start = opts.inclusive_end;\n  }\n  return newOpts;\n}\n\nfunction validateIndex(index) {\n  var ascFields = index.fields.filter(function (field) {\n    return getValue(field) === 'asc';\n  });\n  if (ascFields.length !== 0 && ascFields.length !== index.fields.length) {\n    throw new Error('unsupported mixed sorting');\n  }\n}\n\nfunction validateSort(requestDef, index) {\n  if (index.defaultUsed && requestDef.sort) {\n    var noneIdSorts = requestDef.sort.filter(function (sortItem) {\n      return Object.keys(sortItem)[0] !== '_id';\n    }).map(function (sortItem) {\n      return Object.keys(sortItem)[0];\n    });\n\n    if (noneIdSorts.length > 0) {\n      throw new Error('Cannot sort on field(s) \"' + noneIdSorts.join(',') +\n      '\" when using the default index');\n    }\n  }\n\n  if (index.defaultUsed) {\n    return;\n  }\n}\n\nfunction validateFindRequest(requestDef) {\n  if (typeof requestDef.selector !== 'object') {\n    throw new Error('you must provide a selector when you find()');\n  }\n\n  /*var selectors = requestDef.selector['$and'] || [requestDef.selector];\n  for (var i = 0; i < selectors.length; i++) {\n    var selector = selectors[i];\n    var keys = Object.keys(selector);\n    if (keys.length === 0) {\n      throw new Error('invalid empty selector');\n    }\n    //var selection = selector[keys[0]];\n    /*if (Object.keys(selection).length !== 1) {\n      throw new Error('invalid selector: ' + JSON.stringify(selection) +\n        ' - it must have exactly one key/value');\n    }\n  }*/\n}\n\n// determine the maximum number of fields\n// we're going to need to query, e.g. if the user\n// has selection ['a'] and sorting ['a', 'b'], then we\n// need to use the longer of the two: ['a', 'b']\nfunction getUserFields(selector, sort) {\n  var selectorFields = Object.keys(selector);\n  var sortFields = sort? sort.map(getKey) : [];\n  var userFields;\n  if (selectorFields.length >= sortFields.length) {\n    userFields = selectorFields;\n  } else {\n    userFields = sortFields;\n  }\n\n  if (sortFields.length === 0) {\n    return {\n      fields: userFields\n    };\n  }\n\n  // sort according to the user's preferred sorting\n  userFields = userFields.sort(function (left, right) {\n    var leftIdx = sortFields.indexOf(left);\n    if (leftIdx === -1) {\n      leftIdx = Number.MAX_VALUE;\n    }\n    var rightIdx = sortFields.indexOf(right);\n    if (rightIdx === -1) {\n      rightIdx = Number.MAX_VALUE;\n    }\n    return leftIdx < rightIdx ? -1 : leftIdx > rightIdx ? 1 : 0;\n  });\n\n  return {\n    fields: userFields,\n    sortOrder: sort.map(getKey)\n  };\n}\n\nfunction createIndex$1(db, requestDef) {\n  requestDef = massageCreateIndexRequest(requestDef);\n  var originalIndexDef = clone(requestDef.index);\n  requestDef.index = massageIndexDef(requestDef.index);\n\n  validateIndex(requestDef.index);\n\n  // calculating md5 is expensive - memoize and only\n  // run if required\n  var md5;\n  function getMd5() {\n    return md5 || (md5 = stringMd5(JSON.stringify(requestDef)));\n  }\n\n  var viewName = requestDef.name || ('idx-' + getMd5());\n\n  var ddocName = requestDef.ddoc || ('idx-' + getMd5());\n  var ddocId = '_design/' + ddocName;\n\n  var hasInvalidLanguage = false;\n  var viewExists = false;\n\n  function updateDdoc(doc) {\n    if (doc._rev && doc.language !== 'query') {\n      hasInvalidLanguage = true;\n    }\n    doc.language = 'query';\n    doc.views = doc.views || {};\n\n    viewExists = !!doc.views[viewName];\n\n    if (viewExists) {\n      return false;\n    }\n\n    doc.views[viewName] = {\n      map: {\n        fields: mergeObjects(requestDef.index.fields)\n      },\n      reduce: '_count',\n      options: {\n        def: originalIndexDef\n      }\n    };\n\n    return doc;\n  }\n\n  db.constructor.emit('debug', ['find', 'creating index', ddocId]);\n\n  return upsert(db, ddocId, updateDdoc).then(function () {\n    if (hasInvalidLanguage) {\n      throw new Error('invalid language for ddoc with id \"' +\n      ddocId +\n      '\" (should be \"query\")');\n    }\n  }).then(function () {\n    // kick off a build\n    // TODO: abstract-pouchdb-mapreduce should support auto-updating\n    // TODO: should also use update_after, but pouchdb/pouchdb#3415 blocks me\n    var signature = ddocName + '/' + viewName;\n    return abstractMapper.query.call(db, signature, {\n      limit: 0,\n      reduce: false\n    }).then(function () {\n      return {\n        id: ddocId,\n        name: viewName,\n        result: viewExists ? 'exists' : 'created'\n      };\n    });\n  });\n}\n\nfunction getIndexes$1(db) {\n  // just search through all the design docs and filter in-memory.\n  // hopefully there aren't that many ddocs.\n  return db.allDocs({\n    startkey: '_design/',\n    endkey: '_design/\\uffff',\n    include_docs: true\n  }).then(function (allDocsRes) {\n    var res = {\n      indexes: [{\n        ddoc: null,\n        name: '_all_docs',\n        type: 'special',\n        def: {\n          fields: [{_id: 'asc'}]\n        }\n      }]\n    };\n\n    res.indexes = flatten(res.indexes, allDocsRes.rows.filter(function (row) {\n      return row.doc.language === 'query';\n    }).map(function (row) {\n      var viewNames = row.doc.views !== undefined ? Object.keys(row.doc.views) : [];\n\n      return viewNames.map(function (viewName) {\n        var view = row.doc.views[viewName];\n        return {\n          ddoc: row.id,\n          name: viewName,\n          type: 'json',\n          def: massageIndexDef(view.options.def)\n        };\n      });\n    }));\n\n    // these are sorted by view name for some reason\n    res.indexes.sort(function (left, right) {\n      return compare(left.name, right.name);\n    });\n    res.total_rows = res.indexes.length;\n    return res;\n  });\n}\n\n// couchdb lowest collation value\nvar COLLATE_LO = null;\n\n// couchdb highest collation value (TODO: well not really, but close enough amirite)\nvar COLLATE_HI = {\"\\uffff\": {}};\n\n// couchdb second-lowest collation value\n\nfunction checkFieldInIndex(index, field) {\n  var indexFields = index.def.fields.map(getKey);\n  for (var i = 0, len = indexFields.length; i < len; i++) {\n    var indexField = indexFields[i];\n    if (field === indexField) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// so when you do e.g. $eq/$eq, we can do it entirely in the database.\n// but when you do e.g. $gt/$eq, the first part can be done\n// in the database, but the second part has to be done in-memory,\n// because $gt has forced us to lose precision.\n// so that's what this determines\nfunction userOperatorLosesPrecision(selector, field) {\n  var matcher = selector[field];\n  var userOperator = getKey(matcher);\n\n  return userOperator !== '$eq';\n}\n\n// sort the user fields by their position in the index,\n// if they're in the index\nfunction sortFieldsByIndex(userFields, index) {\n  var indexFields = index.def.fields.map(getKey);\n\n  return userFields.slice().sort(function (a, b) {\n    var aIdx = indexFields.indexOf(a);\n    var bIdx = indexFields.indexOf(b);\n    if (aIdx === -1) {\n      aIdx = Number.MAX_VALUE;\n    }\n    if (bIdx === -1) {\n      bIdx = Number.MAX_VALUE;\n    }\n    return compare(aIdx, bIdx);\n  });\n}\n\n// first pass to try to find fields that will need to be sorted in-memory\nfunction getBasicInMemoryFields(index, selector, userFields) {\n\n  userFields = sortFieldsByIndex(userFields, index);\n\n  // check if any of the user selectors lose precision\n  var needToFilterInMemory = false;\n  for (var i = 0, len = userFields.length; i < len; i++) {\n    var field = userFields[i];\n    if (needToFilterInMemory || !checkFieldInIndex(index, field)) {\n      return userFields.slice(i);\n    }\n    if (i < len - 1 && userOperatorLosesPrecision(selector, field)) {\n      needToFilterInMemory = true;\n    }\n  }\n  return [];\n}\n\nfunction getInMemoryFieldsFromNe(selector) {\n  var fields = [];\n  Object.keys(selector).forEach(function (field) {\n    var matcher = selector[field];\n    Object.keys(matcher).forEach(function (operator) {\n      if (operator === '$ne') {\n        fields.push(field);\n      }\n    });\n  });\n  return fields;\n}\n\nfunction getInMemoryFields(coreInMemoryFields, index, selector, userFields) {\n  var result = flatten(\n    // in-memory fields reported as necessary by the query planner\n    coreInMemoryFields,\n    // combine with another pass that checks for any we may have missed\n    getBasicInMemoryFields(index, selector, userFields),\n    // combine with another pass that checks for $ne's\n    getInMemoryFieldsFromNe(selector)\n  );\n\n  return sortFieldsByIndex(uniq(result), index);\n}\n\n// check that at least one field in the user's query is represented\n// in the index. order matters in the case of sorts\nfunction checkIndexFieldsMatch(indexFields, sortOrder, fields) {\n  if (sortOrder) {\n    // array has to be a strict subarray of index array. furthermore,\n    // the sortOrder fields need to all be represented in the index\n    var sortMatches = oneArrayIsStrictSubArrayOfOther(sortOrder, indexFields);\n    var selectorMatches = oneArrayIsSubArrayOfOther(fields, indexFields);\n\n    return sortMatches && selectorMatches;\n  }\n\n  // all of the user's specified fields still need to be\n  // on the left side of the index array, although the order\n  // doesn't matter\n  return oneSetIsSubArrayOfOther(fields, indexFields);\n}\n\nvar logicalMatchers = ['$eq', '$gt', '$gte', '$lt', '$lte'];\nfunction isNonLogicalMatcher(matcher) {\n  return logicalMatchers.indexOf(matcher) === -1;\n}\n\n// check all the index fields for usages of '$ne'\n// e.g. if the user queries {foo: {$ne: 'foo'}, bar: {$eq: 'bar'}},\n// then we can neither use an index on ['foo'] nor an index on\n// ['foo', 'bar'], but we can use an index on ['bar'] or ['bar', 'foo']\nfunction checkFieldsLogicallySound(indexFields, selector) {\n  var firstField = indexFields[0];\n  var matcher = selector[firstField];\n\n  if (typeof matcher === 'undefined') {\n    /* istanbul ignore next */\n    return true;\n  }\n\n  var hasLogicalOperator = Object.keys(matcher).some(function (matcherKey) {\n    return !(isNonLogicalMatcher(matcherKey));\n  });\n\n  if (!hasLogicalOperator) {\n    return false;\n  }\n\n  var isInvalidNe = Object.keys(matcher).length === 1 &&\n    getKey(matcher) === '$ne';\n\n  return !isInvalidNe;\n}\n\nfunction checkIndexMatches(index, sortOrder, fields, selector) {\n\n  var indexFields = index.def.fields.map(getKey);\n\n  var fieldsMatch = checkIndexFieldsMatch(indexFields, sortOrder, fields);\n\n  if (!fieldsMatch) {\n    return false;\n  }\n\n  return checkFieldsLogicallySound(indexFields, selector);\n}\n\n//\n// the algorithm is very simple:\n// take all the fields the user supplies, and if those fields\n// are a strict subset of the fields in some index,\n// then use that index\n//\n//\nfunction findMatchingIndexes(selector, userFields, sortOrder, indexes) {\n\n  return indexes.reduce(function (res, index) {\n    var indexMatches = checkIndexMatches(index, sortOrder, userFields, selector);\n    if (indexMatches) {\n      res.push(index);\n    }\n    return res;\n  }, []);\n}\n\n// find the best index, i.e. the one that matches the most fields\n// in the user's query\nfunction findBestMatchingIndex(selector, userFields, sortOrder, indexes, useIndex) {\n\n  var matchingIndexes = findMatchingIndexes(selector, userFields, sortOrder, indexes);\n\n  if (matchingIndexes.length === 0) {\n    if (useIndex) {\n      throw {\n        error: \"no_usable_index\",\n        message: \"There is no index available for this selector.\"\n      };\n    }\n    //return `all_docs` as a default index;\n    //I'm assuming that _all_docs is always first\n    var defaultIndex = indexes[0];\n    defaultIndex.defaultUsed = true;\n    return defaultIndex;\n  }\n  if (matchingIndexes.length === 1 && !useIndex) {\n    return matchingIndexes[0];\n  }\n\n  var userFieldsMap = arrayToObject(userFields);\n\n  function scoreIndex(index) {\n    var indexFields = index.def.fields.map(getKey);\n    var score = 0;\n    for (var i = 0, len = indexFields.length; i < len; i++) {\n      var indexField = indexFields[i];\n      if (userFieldsMap[indexField]) {\n        score++;\n      }\n    }\n    return score;\n  }\n\n  if (useIndex) {\n    var useIndexDdoc = '_design/' + useIndex[0];\n    var useIndexName = useIndex.length === 2 ? useIndex[1] : false;\n    var index = matchingIndexes.find(function (index) {\n      if (useIndexName && index.ddoc === useIndexDdoc && useIndexName === index.name) {\n        return true;\n      }\n\n      if (index.ddoc === useIndexDdoc) {\n        /* istanbul ignore next */\n        return true;\n      }\n\n      return false;\n    });\n\n    if (!index) {\n      throw {\n        error: \"unknown_error\",\n        message: \"Could not find that index or could not use that index for the query\"\n      };\n    }\n    return index;\n  }\n\n  return max(matchingIndexes, scoreIndex);\n}\n\nfunction getSingleFieldQueryOptsFor(userOperator, userValue) {\n  switch (userOperator) {\n    case '$eq':\n      return {key: userValue};\n    case '$lte':\n      return {endkey: userValue};\n    case '$gte':\n      return {startkey: userValue};\n    case '$lt':\n      return {\n        endkey: userValue,\n        inclusive_end: false\n      };\n    case '$gt':\n      return {\n        startkey: userValue,\n        inclusive_start: false\n      };\n  }\n}\n\nfunction getSingleFieldCoreQueryPlan(selector, index) {\n  var field = getKey(index.def.fields[0]);\n  //ignoring this because the test to exercise the branch is skipped at the moment\n  /* istanbul ignore next */\n  var matcher = selector[field] || {};\n  var inMemoryFields = [];\n\n  var userOperators = Object.keys(matcher);\n\n  var combinedOpts;\n\n  userOperators.forEach(function (userOperator) {\n\n    if (isNonLogicalMatcher(userOperator)) {\n      inMemoryFields.push(field);\n      return;\n    }\n\n    var userValue = matcher[userOperator];\n\n    var newQueryOpts = getSingleFieldQueryOptsFor(userOperator, userValue);\n\n    if (combinedOpts) {\n      combinedOpts = mergeObjects([combinedOpts, newQueryOpts]);\n    } else {\n      combinedOpts = newQueryOpts;\n    }\n  });\n\n  return {\n    queryOpts: combinedOpts,\n    inMemoryFields: inMemoryFields\n  };\n}\n\nfunction getMultiFieldCoreQueryPlan(userOperator, userValue) {\n  switch (userOperator) {\n    case '$eq':\n      return {\n        startkey: userValue,\n        endkey: userValue\n      };\n    case '$lte':\n      return {\n        endkey: userValue\n      };\n    case '$gte':\n      return {\n        startkey: userValue\n      };\n    case '$lt':\n      return {\n        endkey: userValue,\n        inclusive_end: false\n      };\n    case '$gt':\n      return {\n        startkey: userValue,\n        inclusive_start: false\n      };\n  }\n}\n\nfunction getMultiFieldQueryOpts(selector, index) {\n\n  var indexFields = index.def.fields.map(getKey);\n\n  var inMemoryFields = [];\n  var startkey = [];\n  var endkey = [];\n  var inclusiveStart;\n  var inclusiveEnd;\n\n\n  function finish(i) {\n\n    if (inclusiveStart !== false) {\n      startkey.push(COLLATE_LO);\n    }\n    if (inclusiveEnd !== false) {\n      endkey.push(COLLATE_HI);\n    }\n    // keep track of the fields where we lost specificity,\n    // and therefore need to filter in-memory\n    inMemoryFields = indexFields.slice(i);\n  }\n\n  for (var i = 0, len = indexFields.length; i < len; i++) {\n    var indexField = indexFields[i];\n\n    var matcher = selector[indexField];\n\n    if (!matcher || !Object.keys(matcher).length) { // fewer fields in user query than in index\n      finish(i);\n      break;\n    } else if (i > 0) {\n      if (Object.keys(matcher).some(isNonLogicalMatcher)) { // non-logical are ignored\n        finish(i);\n        break;\n      }\n      var usingGtlt = (\n        '$gt' in matcher || '$gte' in matcher ||\n        '$lt' in matcher || '$lte' in matcher);\n      var previousKeys = Object.keys(selector[indexFields[i - 1]]);\n      var previousWasEq = arrayEquals(previousKeys, ['$eq']);\n      var previousWasSame = arrayEquals(previousKeys, Object.keys(matcher));\n      var gtltLostSpecificity = usingGtlt && !previousWasEq && !previousWasSame;\n      if (gtltLostSpecificity) {\n        finish(i);\n        break;\n      }\n    }\n\n    var userOperators = Object.keys(matcher);\n\n    var combinedOpts = null;\n\n    for (var j = 0; j < userOperators.length; j++) {\n      var userOperator = userOperators[j];\n      var userValue = matcher[userOperator];\n\n      var newOpts = getMultiFieldCoreQueryPlan(userOperator, userValue);\n\n      if (combinedOpts) {\n        combinedOpts = mergeObjects([combinedOpts, newOpts]);\n      } else {\n        combinedOpts = newOpts;\n      }\n    }\n\n    startkey.push('startkey' in combinedOpts ? combinedOpts.startkey : COLLATE_LO);\n    endkey.push('endkey' in combinedOpts ? combinedOpts.endkey : COLLATE_HI);\n    if ('inclusive_start' in combinedOpts) {\n      inclusiveStart = combinedOpts.inclusive_start;\n    }\n    if ('inclusive_end' in combinedOpts) {\n      inclusiveEnd = combinedOpts.inclusive_end;\n    }\n  }\n\n  var res = {\n    startkey: startkey,\n    endkey: endkey\n  };\n\n  if (typeof inclusiveStart !== 'undefined') {\n    res.inclusive_start = inclusiveStart;\n  }\n  if (typeof inclusiveEnd !== 'undefined') {\n    res.inclusive_end = inclusiveEnd;\n  }\n\n  return {\n    queryOpts: res,\n    inMemoryFields: inMemoryFields\n  };\n}\n\nfunction getDefaultQueryPlan(selector) {\n  //using default index, so all fields need to be done in memory\n  return {\n    queryOpts: {startkey: null},\n    inMemoryFields: [Object.keys(selector)]\n  };\n}\n\nfunction getCoreQueryPlan(selector, index) {\n  if (index.defaultUsed) {\n    return getDefaultQueryPlan(selector, index);\n  }\n\n  if (index.def.fields.length === 1) {\n    // one field in index, so the value was indexed as a singleton\n    return getSingleFieldCoreQueryPlan(selector, index);\n  }\n  // else index has multiple fields, so the value was indexed as an array\n  return getMultiFieldQueryOpts(selector, index);\n}\n\nfunction planQuery(request, indexes) {\n\n  var selector = request.selector;\n  var sort = request.sort;\n\n  var userFieldsRes = getUserFields(selector, sort);\n\n  var userFields = userFieldsRes.fields;\n  var sortOrder = userFieldsRes.sortOrder;\n  var index = findBestMatchingIndex(selector, userFields, sortOrder, indexes, request.use_index);\n\n  var coreQueryPlan = getCoreQueryPlan(selector, index);\n  var queryOpts = coreQueryPlan.queryOpts;\n  var coreInMemoryFields = coreQueryPlan.inMemoryFields;\n\n  var inMemoryFields = getInMemoryFields(coreInMemoryFields, index, selector, userFields);\n\n  var res = {\n    queryOpts: queryOpts,\n    index: index,\n    inMemoryFields: inMemoryFields\n  };\n  return res;\n}\n\nfunction indexToSignature(index) {\n  // remove '_design/'\n  return index.ddoc.substring(8) + '/' + index.name;\n}\n\nfunction doAllDocs(db, originalOpts) {\n  var opts = clone(originalOpts);\n\n  // CouchDB responds in weird ways when you provide a non-string to _id;\n  // we mimic the behavior for consistency. See issue66 tests for details.\n\n  if (opts.descending) {\n    if ('endkey' in opts && typeof opts.endkey !== 'string') {\n      opts.endkey = '';\n    }\n    if ('startkey' in opts && typeof opts.startkey !== 'string') {\n      opts.limit = 0;\n    }\n  } else {\n    if ('startkey' in opts && typeof opts.startkey !== 'string') {\n      opts.startkey = '';\n    }\n    if ('endkey' in opts && typeof opts.endkey !== 'string') {\n      opts.limit = 0;\n    }\n  }\n  if ('key' in opts && typeof opts.key !== 'string') {\n    opts.limit = 0;\n  }\n\n  return db.allDocs(opts)\n  .then(function (res) {\n    // filter out any design docs that _all_docs might return\n    res.rows = res.rows.filter(function (row) {\n      return !/^_design\\//.test(row.id);\n    });\n    return res;\n  });\n}\n\nfunction find$1(db, requestDef, explain) {\n  if (requestDef.selector) {\n    requestDef.selector = massageSelector(requestDef.selector);\n  }\n\n  if (requestDef.sort) {\n    requestDef.sort = massageSort(requestDef.sort);\n  }\n\n  if (requestDef.use_index) {\n    requestDef.use_index = massageUseIndex(requestDef.use_index);\n  }\n\n  validateFindRequest(requestDef);\n\n  return getIndexes$1(db).then(function (getIndexesRes) {\n\n    db.constructor.emit('debug', ['find', 'planning query', requestDef]);\n    var queryPlan = planQuery(requestDef, getIndexesRes.indexes);\n    db.constructor.emit('debug', ['find', 'query plan', queryPlan]);\n\n    var indexToUse = queryPlan.index;\n\n    validateSort(requestDef, indexToUse);\n\n    var opts = assign({\n      include_docs: true,\n      reduce: false\n    }, queryPlan.queryOpts);\n\n    if ('startkey' in opts && 'endkey' in opts &&\n        collate(opts.startkey, opts.endkey) > 0) {\n      // can't possibly return any results, startkey > endkey\n      /* istanbul ignore next */\n      return {docs: []};\n    }\n\n    var isDescending = requestDef.sort &&\n      typeof requestDef.sort[0] !== 'string' &&\n      getValue(requestDef.sort[0]) === 'desc';\n\n    if (isDescending) {\n      // either all descending or all ascending\n      opts.descending = true;\n      opts = reverseOptions(opts);\n    }\n\n    if (!queryPlan.inMemoryFields.length) {\n      // no in-memory filtering necessary, so we can let the\n      // database do the limit/skip for us\n      if ('limit' in requestDef) {\n        opts.limit = requestDef.limit;\n      }\n      if ('skip' in requestDef) {\n        opts.skip = requestDef.skip;\n      }\n    }\n\n    if (explain) {\n      return Promise.resolve(queryPlan, opts);\n    }\n\n    return Promise.resolve().then(function () {\n      if (indexToUse.name === '_all_docs') {\n        return doAllDocs(db, opts);\n      } else {\n        var signature = indexToSignature(indexToUse);\n        return abstractMapper.query.call(db, signature, opts);\n      }\n    }).then(function (res) {\n      if (opts.inclusive_start === false) {\n        // may have to manually filter the first one,\n        // since couchdb has no true inclusive_start option\n        res.rows = filterInclusiveStart(res.rows, opts.startkey, indexToUse);\n      }\n\n      if (queryPlan.inMemoryFields.length) {\n        // need to filter some stuff in-memory\n        res.rows = filterInMemoryFields(res.rows, requestDef, queryPlan.inMemoryFields);\n      }\n\n      var resp = {\n        docs: res.rows.map(function (row) {\n          var doc = row.doc;\n          if (requestDef.fields) {\n            return pick(doc, requestDef.fields);\n          }\n          return doc;\n        })\n      };\n\n      if (indexToUse.defaultUsed) {\n        resp.warning = 'no matching index found, create an index to optimize query time';\n      }\n\n      return resp;\n    });\n  });\n}\n\nfunction explain$1(db, requestDef) {\n  return find$1(db, requestDef, true)\n  .then(function (queryPlan) {\n    return {\n      dbname: db.name,\n      index: queryPlan.index,\n      selector: requestDef.selector,\n      range: {\n        start_key: queryPlan.queryOpts.startkey,\n        end_key: queryPlan.queryOpts.endkey,\n      },\n      opts: {\n        use_index: requestDef.use_index || [],\n        bookmark: \"nil\", //hardcoded to match CouchDB since its not supported,\n        limit: requestDef.limit,\n        skip: requestDef.skip,\n        sort: requestDef.sort || {},\n        fields: requestDef.fields,\n        conflicts: false, //hardcoded to match CouchDB since its not supported,\n        r: [49], // hardcoded to match CouchDB since its not support\n      },\n      limit: requestDef.limit,\n      skip: requestDef.skip || 0,\n      fields: requestDef.fields,\n    };\n  });\n}\n\nfunction deleteIndex$1(db, index) {\n\n  if (!index.ddoc) {\n    throw new Error('you must supply an index.ddoc when deleting');\n  }\n\n  if (!index.name) {\n    throw new Error('you must supply an index.name when deleting');\n  }\n\n  var docId = index.ddoc;\n  var viewName = index.name;\n\n  function deltaFun(doc) {\n    if (Object.keys(doc.views).length === 1 && doc.views[viewName]) {\n      // only one view in this ddoc, delete the whole ddoc\n      return {_id: docId, _deleted: true};\n    }\n    // more than one view here, just remove the view\n    delete doc.views[viewName];\n    return doc;\n  }\n\n  return upsert(db, docId, deltaFun).then(function () {\n    return abstractMapper.viewCleanup.apply(db);\n  }).then(function () {\n    return {ok: true};\n  });\n}\n\nvar createIndexAsCallback = callbackify(createIndex$1);\nvar findAsCallback = callbackify(find$1);\nvar explainAsCallback = callbackify(explain$1);\nvar getIndexesAsCallback = callbackify(getIndexes$1);\nvar deleteIndexAsCallback = callbackify(deleteIndex$1);\n\nvar plugin = {};\nplugin.createIndex = toPromise(function (requestDef, callback) {\n\n  if (typeof requestDef !== 'object') {\n    return callback(new Error('you must provide an index to create'));\n  }\n\n  var createIndex$$1 = isRemote(this) ?\n    createIndex : createIndexAsCallback;\n  createIndex$$1(this, requestDef, callback);\n});\n\nplugin.find = toPromise(function (requestDef, callback) {\n\n  if (typeof callback === 'undefined') {\n    callback = requestDef;\n    requestDef = undefined;\n  }\n\n  if (typeof requestDef !== 'object') {\n    return callback(new Error('you must provide search parameters to find()'));\n  }\n\n  var find$$1 = isRemote(this) ? find : findAsCallback;\n  find$$1(this, requestDef, callback);\n});\n\nplugin.explain = toPromise(function (requestDef, callback) {\n\n  if (typeof callback === 'undefined') {\n    callback = requestDef;\n    requestDef = undefined;\n  }\n\n  if (typeof requestDef !== 'object') {\n    return callback(new Error('you must provide search parameters to explain()'));\n  }\n\n  var find$$1 = isRemote(this) ? explain : explainAsCallback;\n  find$$1(this, requestDef, callback);\n});\n\nplugin.getIndexes = toPromise(function (callback) {\n\n  var getIndexes$$1 = isRemote(this) ? getIndexes : getIndexesAsCallback;\n  getIndexes$$1(this, callback);\n});\n\nplugin.deleteIndex = toPromise(function (indexDef, callback) {\n\n  if (typeof indexDef !== 'object') {\n    return callback(new Error('you must provide an index to delete'));\n  }\n\n  var deleteIndex$$1 = isRemote(this) ?\n    deleteIndex : deleteIndexAsCallback;\n  deleteIndex$$1(this, indexDef, callback);\n});\n\nexport default plugin;\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport { map } from 'rxjs/operators';\nimport { createUpdateEvent } from './../rx-change-event';\nimport { nextTick, isElectronRenderer, now } from './../util';\nimport { newRxError } from '../rx-error';\nimport { pouchAttachmentBinaryHash } from '../pouch-db';\n\nfunction ensureSchemaSupportsAttachments(doc) {\n  var schemaJson = doc.collection.schema.jsonSchema;\n\n  if (!schemaJson.attachments) {\n    throw newRxError('AT1', {\n      link: 'https://pubkey.github.io/rxdb/rx-attachment.html'\n    });\n  }\n}\n\nfunction resyncRxDocument(doc) {\n  var startTime = now();\n  return doc.collection.pouch.get(doc.primary).then(function (docDataFromPouch) {\n    var data = doc.collection._handleFromPouch(docDataFromPouch);\n\n    var endTime = now();\n    var changeEvent = createUpdateEvent(doc.collection, data, null, startTime, endTime, doc);\n    doc.$emit(changeEvent);\n  });\n}\n\nexport var blobBufferUtil = {\n  /**\n   * depending if we are on node or browser,\n   * we have to use Buffer(node) or Blob(browser)\n   */\n  createBlobBuffer: function createBlobBuffer(data, type) {\n    var blobBuffer;\n\n    if (isElectronRenderer) {\n      // if we are inside of electron-renderer, always use the node-buffer\n      return Buffer.from(data, {\n        type: type\n      });\n    }\n\n    try {\n      // for browsers\n      blobBuffer = new Blob([data], {\n        type: type\n      });\n    } catch (e) {\n      // for node\n      blobBuffer = Buffer.from(data, {\n        type: type\n      });\n    }\n\n    return blobBuffer;\n  },\n  toString: function toString(blobBuffer) {\n    if (blobBuffer instanceof Buffer) {\n      // node\n      return nextTick().then(function () {\n        return blobBuffer.toString();\n      });\n    }\n\n    return new Promise(function (res) {\n      // browsers\n      var reader = new FileReader();\n      reader.addEventListener('loadend', function (e) {\n        var text = e.target.result;\n        res(text);\n      });\n      var blobBufferType = Object.prototype.toString.call(blobBuffer);\n      /**\n       * in the electron-renderer we have a typed array insteaf of a blob\n       * so we have to transform it.\n       * @link https://github.com/pubkey/rxdb/issues/1371\n       */\n\n      if (blobBufferType === '[object Uint8Array]') {\n        blobBuffer = new Blob([blobBuffer]);\n      }\n\n      reader.readAsText(blobBuffer);\n    });\n  }\n};\n\nvar _assignMethodsToAttachment = function _assignMethodsToAttachment(attachment) {\n  Object.entries(attachment.doc.collection.attachments).forEach(function (_ref) {\n    var funName = _ref[0],\n        fun = _ref[1];\n    Object.defineProperty(attachment, funName, {\n      get: function get() {\n        return fun.bind(attachment);\n      }\n    });\n  });\n};\n/**\n * an RxAttachment is basically just the attachment-stub\n * wrapped so that you can access the attachment-data\n */\n\n\nexport var RxAttachment =\n/*#__PURE__*/\nfunction () {\n  function RxAttachment(_ref2) {\n    var doc = _ref2.doc,\n        id = _ref2.id,\n        type = _ref2.type,\n        length = _ref2.length,\n        digest = _ref2.digest,\n        rev = _ref2.rev;\n    this.doc = doc;\n    this.id = id;\n    this.type = type;\n    this.length = length;\n    this.digest = digest;\n    this.rev = rev;\n\n    _assignMethodsToAttachment(this);\n  }\n\n  var _proto = RxAttachment.prototype;\n\n  _proto.remove = function remove() {\n    var _this = this;\n\n    return this.doc.collection.pouch.removeAttachment(this.doc.primary, this.id, this.doc._data._rev).then(function () {\n      return resyncRxDocument(_this.doc);\n    });\n  }\n  /**\n   * returns the data for the attachment\n   */\n  ;\n\n  _proto.getData = function getData() {\n    var _this2 = this;\n\n    return this.doc.collection.pouch.getAttachment(this.doc.primary, this.id).then(function (data) {\n      if (shouldEncrypt(_this2.doc)) {\n        return blobBufferUtil.toString(data).then(function (dataString) {\n          return blobBufferUtil.createBlobBuffer(_this2.doc.collection._crypter._decryptValue(dataString), _this2.type);\n        });\n      } else return data;\n    });\n  };\n\n  _proto.getStringData = function getStringData() {\n    return this.getData().then(function (bufferBlob) {\n      return blobBufferUtil.toString(bufferBlob);\n    });\n  };\n\n  return RxAttachment;\n}();\nexport function fromPouchDocument(id, pouchDocAttachment, rxDocument) {\n  return new RxAttachment({\n    doc: rxDocument,\n    id: id,\n    type: pouchDocAttachment.content_type,\n    length: pouchDocAttachment.length,\n    digest: pouchDocAttachment.digest,\n    rev: pouchDocAttachment.revpos\n  });\n}\n\nfunction shouldEncrypt(doc) {\n  return !!doc.collection.schema.jsonSchema.attachments.encrypted;\n}\n\nexport function putAttachment(_x) {\n  return _putAttachment.apply(this, arguments);\n}\n/**\n * get an attachment of the document by its id\n */\n\nfunction _putAttachment() {\n  _putAttachment = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee2(_ref3) {\n    var _this5 = this;\n\n    var id,\n        data,\n        _ref3$type,\n        type,\n        skipIfSame,\n        blobBuffer,\n        _args2 = arguments;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            id = _ref3.id, data = _ref3.data, _ref3$type = _ref3.type, type = _ref3$type === void 0 ? 'text/plain' : _ref3$type;\n            skipIfSame = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : false;\n            ensureSchemaSupportsAttachments(this);\n\n            if (shouldEncrypt(this)) {\n              data = this.collection._crypter._encryptValue(data);\n            }\n\n            blobBuffer = blobBufferUtil.createBlobBuffer(data, type);\n            this._atomicQueue = this._atomicQueue.then(\n            /*#__PURE__*/\n            _asyncToGenerator(\n            /*#__PURE__*/\n            _regeneratorRuntime.mark(function _callee() {\n              var currentMeta, newHash;\n              return _regeneratorRuntime.wrap(function _callee$(_context) {\n                while (1) {\n                  switch (_context.prev = _context.next) {\n                    case 0:\n                      if (!(skipIfSame && _this5._data._attachments && _this5._data._attachments[id])) {\n                        _context.next = 7;\n                        break;\n                      }\n\n                      currentMeta = _this5._data._attachments[id];\n                      _context.next = 4;\n                      return pouchAttachmentBinaryHash(data);\n\n                    case 4:\n                      newHash = _context.sent;\n\n                      if (!(currentMeta.content_type === type && currentMeta.digest === newHash)) {\n                        _context.next = 7;\n                        break;\n                      }\n\n                      return _context.abrupt(\"return\", _this5.getAttachment(id));\n\n                    case 7:\n                      return _context.abrupt(\"return\", _this5.collection.pouch.putAttachment(_this5.primary, id, _this5._data._rev, blobBuffer, type).then(function () {\n                        return _this5.collection.pouch.get(_this5.primary);\n                      }).then(function (docData) {\n                        var attachmentData = docData._attachments[id];\n                        var attachment = fromPouchDocument(id, attachmentData, _this5);\n                        _this5._data._rev = docData._rev;\n                        _this5._data._attachments = docData._attachments;\n                        return resyncRxDocument(_this5).then(function () {\n                          return attachment;\n                        });\n                      }));\n\n                    case 8:\n                    case \"end\":\n                      return _context.stop();\n                  }\n                }\n              }, _callee);\n            })));\n            return _context2.abrupt(\"return\", this._atomicQueue);\n\n          case 7:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, this);\n  }));\n  return _putAttachment.apply(this, arguments);\n}\n\nexport function getAttachment(id) {\n  ensureSchemaSupportsAttachments(this);\n\n  var docData = this._dataSync$.getValue();\n\n  if (!docData._attachments || !docData._attachments[id]) return null;\n  var attachmentData = docData._attachments[id];\n  var attachment = fromPouchDocument(id, attachmentData, this);\n  return attachment;\n}\n/**\n * returns all attachments of the document\n */\n\nexport function allAttachments() {\n  var _this3 = this;\n\n  ensureSchemaSupportsAttachments(this);\n\n  var docData = this._dataSync$.getValue(); // if there are no attachments, the field is missing\n\n\n  if (!docData._attachments) return [];\n  return Object.keys(docData._attachments).map(function (id) {\n    return fromPouchDocument(id, docData._attachments[id], _this3);\n  });\n}\nexport function preMigrateDocument(action) {\n  delete action.migrated._attachments;\n  return action;\n}\nexport function postMigrateDocument(action) {\n  var primaryPath = action.oldCollection.schema.primaryPath;\n  var attachments = action.doc._attachments;\n  if (!attachments) return Promise.resolve(action);\n  var currentPromise = Promise.resolve();\n  Object.keys(attachments).forEach(function (id) {\n    var stubData = attachments[id];\n    var primary = action.doc[primaryPath];\n    currentPromise = currentPromise.then(function () {\n      return action.oldCollection.pouchdb.getAttachment(primary, id);\n    }).then(function (data) {\n      return blobBufferUtil.toString(data);\n    }).then(function (data) {\n      return action.newestCollection.pouch.putAttachment(primary, id, action.res.rev, blobBufferUtil.createBlobBuffer(data, stubData.content_type), stubData.content_type);\n    }).then(function (res) {\n      return action.res = res;\n    });\n  });\n  return currentPromise;\n}\nexport var rxdb = true;\nexport var prototypes = {\n  RxDocument: function RxDocument(proto) {\n    proto.putAttachment = putAttachment;\n    proto.getAttachment = getAttachment;\n    proto.allAttachments = allAttachments;\n    Object.defineProperty(proto, 'allAttachments$', {\n      get: function allAttachments$() {\n        var _this4 = this;\n\n        return this._dataSync$.pipe(map(function (data) {\n          if (!data['_attachments']) return {};\n          return data['_attachments'];\n        }), map(function (attachmentsData) {\n          return Object.entries(attachmentsData);\n        }), map(function (entries) {\n          return entries.map(function (_ref4) {\n            var id = _ref4[0],\n                attachmentData = _ref4[1];\n            return fromPouchDocument(id, attachmentData, _this4);\n          });\n        }));\n      }\n    });\n  }\n};\nexport var overwritable = {};\nexport var hooks = {\n  preMigrateDocument: preMigrateDocument,\n  postMigrateDocument: postMigrateDocument\n};\nexport var RxDBAttachmentsPlugin = {\n  name: 'attachments',\n  rxdb: rxdb,\n  prototypes: prototypes,\n  overwritable: overwritable,\n  hooks: hooks\n};","map":{"version":3,"sources":["/Users/Hanzalah/Desktop/github/todo-offline/rxdb-hasura-demo/node_modules/rxdb/dist/es/plugins/attachments.js"],"names":["_regeneratorRuntime","_asyncToGenerator","map","createUpdateEvent","nextTick","isElectronRenderer","now","newRxError","pouchAttachmentBinaryHash","ensureSchemaSupportsAttachments","doc","schemaJson","collection","schema","jsonSchema","attachments","link","resyncRxDocument","startTime","pouch","get","primary","then","docDataFromPouch","data","_handleFromPouch","endTime","changeEvent","$emit","blobBufferUtil","createBlobBuffer","type","blobBuffer","Buffer","from","Blob","e","toString","Promise","res","reader","FileReader","addEventListener","text","target","result","blobBufferType","Object","prototype","call","readAsText","_assignMethodsToAttachment","attachment","entries","forEach","_ref","funName","fun","defineProperty","bind","RxAttachment","_ref2","id","length","digest","rev","_proto","remove","_this","removeAttachment","_data","_rev","getData","_this2","getAttachment","shouldEncrypt","dataString","_crypter","_decryptValue","getStringData","bufferBlob","fromPouchDocument","pouchDocAttachment","rxDocument","content_type","revpos","encrypted","putAttachment","_x","_putAttachment","apply","arguments","mark","_callee2","_ref3","_this5","_ref3$type","skipIfSame","_args2","wrap","_callee2$","_context2","prev","next","undefined","_encryptValue","_atomicQueue","_callee","currentMeta","newHash","_callee$","_context","_attachments","sent","abrupt","docData","attachmentData","stop","_dataSync$","getValue","allAttachments","_this3","keys","preMigrateDocument","action","migrated","postMigrateDocument","primaryPath","oldCollection","resolve","currentPromise","stubData","pouchdb","newestCollection","rxdb","prototypes","RxDocument","proto","allAttachments$","_this4","pipe","attachmentsData","_ref4","overwritable","hooks","RxDBAttachmentsPlugin","name"],"mappings":"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","sourcesContent":["import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport { map } from 'rxjs/operators';\nimport { createUpdateEvent } from './../rx-change-event';\nimport { nextTick, isElectronRenderer, now } from './../util';\nimport { newRxError } from '../rx-error';\nimport { pouchAttachmentBinaryHash } from '../pouch-db';\n\nfunction ensureSchemaSupportsAttachments(doc) {\n  var schemaJson = doc.collection.schema.jsonSchema;\n\n  if (!schemaJson.attachments) {\n    throw newRxError('AT1', {\n      link: 'https://pubkey.github.io/rxdb/rx-attachment.html'\n    });\n  }\n}\n\nfunction resyncRxDocument(doc) {\n  var startTime = now();\n  return doc.collection.pouch.get(doc.primary).then(function (docDataFromPouch) {\n    var data = doc.collection._handleFromPouch(docDataFromPouch);\n\n    var endTime = now();\n    var changeEvent = createUpdateEvent(doc.collection, data, null, startTime, endTime, doc);\n    doc.$emit(changeEvent);\n  });\n}\n\nexport var blobBufferUtil = {\n  /**\n   * depending if we are on node or browser,\n   * we have to use Buffer(node) or Blob(browser)\n   */\n  createBlobBuffer: function createBlobBuffer(data, type) {\n    var blobBuffer;\n\n    if (isElectronRenderer) {\n      // if we are inside of electron-renderer, always use the node-buffer\n      return Buffer.from(data, {\n        type: type\n      });\n    }\n\n    try {\n      // for browsers\n      blobBuffer = new Blob([data], {\n        type: type\n      });\n    } catch (e) {\n      // for node\n      blobBuffer = Buffer.from(data, {\n        type: type\n      });\n    }\n\n    return blobBuffer;\n  },\n  toString: function toString(blobBuffer) {\n    if (blobBuffer instanceof Buffer) {\n      // node\n      return nextTick().then(function () {\n        return blobBuffer.toString();\n      });\n    }\n\n    return new Promise(function (res) {\n      // browsers\n      var reader = new FileReader();\n      reader.addEventListener('loadend', function (e) {\n        var text = e.target.result;\n        res(text);\n      });\n      var blobBufferType = Object.prototype.toString.call(blobBuffer);\n      /**\n       * in the electron-renderer we have a typed array insteaf of a blob\n       * so we have to transform it.\n       * @link https://github.com/pubkey/rxdb/issues/1371\n       */\n\n      if (blobBufferType === '[object Uint8Array]') {\n        blobBuffer = new Blob([blobBuffer]);\n      }\n\n      reader.readAsText(blobBuffer);\n    });\n  }\n};\n\nvar _assignMethodsToAttachment = function _assignMethodsToAttachment(attachment) {\n  Object.entries(attachment.doc.collection.attachments).forEach(function (_ref) {\n    var funName = _ref[0],\n        fun = _ref[1];\n    Object.defineProperty(attachment, funName, {\n      get: function get() {\n        return fun.bind(attachment);\n      }\n    });\n  });\n};\n/**\n * an RxAttachment is basically just the attachment-stub\n * wrapped so that you can access the attachment-data\n */\n\n\nexport var RxAttachment = /*#__PURE__*/function () {\n  function RxAttachment(_ref2) {\n    var doc = _ref2.doc,\n        id = _ref2.id,\n        type = _ref2.type,\n        length = _ref2.length,\n        digest = _ref2.digest,\n        rev = _ref2.rev;\n    this.doc = doc;\n    this.id = id;\n    this.type = type;\n    this.length = length;\n    this.digest = digest;\n    this.rev = rev;\n\n    _assignMethodsToAttachment(this);\n  }\n\n  var _proto = RxAttachment.prototype;\n\n  _proto.remove = function remove() {\n    var _this = this;\n\n    return this.doc.collection.pouch.removeAttachment(this.doc.primary, this.id, this.doc._data._rev).then(function () {\n      return resyncRxDocument(_this.doc);\n    });\n  }\n  /**\n   * returns the data for the attachment\n   */\n  ;\n\n  _proto.getData = function getData() {\n    var _this2 = this;\n\n    return this.doc.collection.pouch.getAttachment(this.doc.primary, this.id).then(function (data) {\n      if (shouldEncrypt(_this2.doc)) {\n        return blobBufferUtil.toString(data).then(function (dataString) {\n          return blobBufferUtil.createBlobBuffer(_this2.doc.collection._crypter._decryptValue(dataString), _this2.type);\n        });\n      } else return data;\n    });\n  };\n\n  _proto.getStringData = function getStringData() {\n    return this.getData().then(function (bufferBlob) {\n      return blobBufferUtil.toString(bufferBlob);\n    });\n  };\n\n  return RxAttachment;\n}();\nexport function fromPouchDocument(id, pouchDocAttachment, rxDocument) {\n  return new RxAttachment({\n    doc: rxDocument,\n    id: id,\n    type: pouchDocAttachment.content_type,\n    length: pouchDocAttachment.length,\n    digest: pouchDocAttachment.digest,\n    rev: pouchDocAttachment.revpos\n  });\n}\n\nfunction shouldEncrypt(doc) {\n  return !!doc.collection.schema.jsonSchema.attachments.encrypted;\n}\n\nexport function putAttachment(_x) {\n  return _putAttachment.apply(this, arguments);\n}\n/**\n * get an attachment of the document by its id\n */\n\nfunction _putAttachment() {\n  _putAttachment = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref3) {\n    var _this5 = this;\n\n    var id,\n        data,\n        _ref3$type,\n        type,\n        skipIfSame,\n        blobBuffer,\n        _args2 = arguments;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            id = _ref3.id, data = _ref3.data, _ref3$type = _ref3.type, type = _ref3$type === void 0 ? 'text/plain' : _ref3$type;\n            skipIfSame = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : false;\n            ensureSchemaSupportsAttachments(this);\n\n            if (shouldEncrypt(this)) {\n              data = this.collection._crypter._encryptValue(data);\n            }\n\n            blobBuffer = blobBufferUtil.createBlobBuffer(data, type);\n            this._atomicQueue = this._atomicQueue.then( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n              var currentMeta, newHash;\n              return _regeneratorRuntime.wrap(function _callee$(_context) {\n                while (1) {\n                  switch (_context.prev = _context.next) {\n                    case 0:\n                      if (!(skipIfSame && _this5._data._attachments && _this5._data._attachments[id])) {\n                        _context.next = 7;\n                        break;\n                      }\n\n                      currentMeta = _this5._data._attachments[id];\n                      _context.next = 4;\n                      return pouchAttachmentBinaryHash(data);\n\n                    case 4:\n                      newHash = _context.sent;\n\n                      if (!(currentMeta.content_type === type && currentMeta.digest === newHash)) {\n                        _context.next = 7;\n                        break;\n                      }\n\n                      return _context.abrupt(\"return\", _this5.getAttachment(id));\n\n                    case 7:\n                      return _context.abrupt(\"return\", _this5.collection.pouch.putAttachment(_this5.primary, id, _this5._data._rev, blobBuffer, type).then(function () {\n                        return _this5.collection.pouch.get(_this5.primary);\n                      }).then(function (docData) {\n                        var attachmentData = docData._attachments[id];\n                        var attachment = fromPouchDocument(id, attachmentData, _this5);\n                        _this5._data._rev = docData._rev;\n                        _this5._data._attachments = docData._attachments;\n                        return resyncRxDocument(_this5).then(function () {\n                          return attachment;\n                        });\n                      }));\n\n                    case 8:\n                    case \"end\":\n                      return _context.stop();\n                  }\n                }\n              }, _callee);\n            })));\n            return _context2.abrupt(\"return\", this._atomicQueue);\n\n          case 7:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, this);\n  }));\n  return _putAttachment.apply(this, arguments);\n}\n\nexport function getAttachment(id) {\n  ensureSchemaSupportsAttachments(this);\n\n  var docData = this._dataSync$.getValue();\n\n  if (!docData._attachments || !docData._attachments[id]) return null;\n  var attachmentData = docData._attachments[id];\n  var attachment = fromPouchDocument(id, attachmentData, this);\n  return attachment;\n}\n/**\n * returns all attachments of the document\n */\n\nexport function allAttachments() {\n  var _this3 = this;\n\n  ensureSchemaSupportsAttachments(this);\n\n  var docData = this._dataSync$.getValue(); // if there are no attachments, the field is missing\n\n\n  if (!docData._attachments) return [];\n  return Object.keys(docData._attachments).map(function (id) {\n    return fromPouchDocument(id, docData._attachments[id], _this3);\n  });\n}\nexport function preMigrateDocument(action) {\n  delete action.migrated._attachments;\n  return action;\n}\nexport function postMigrateDocument(action) {\n  var primaryPath = action.oldCollection.schema.primaryPath;\n  var attachments = action.doc._attachments;\n  if (!attachments) return Promise.resolve(action);\n  var currentPromise = Promise.resolve();\n  Object.keys(attachments).forEach(function (id) {\n    var stubData = attachments[id];\n    var primary = action.doc[primaryPath];\n    currentPromise = currentPromise.then(function () {\n      return action.oldCollection.pouchdb.getAttachment(primary, id);\n    }).then(function (data) {\n      return blobBufferUtil.toString(data);\n    }).then(function (data) {\n      return action.newestCollection.pouch.putAttachment(primary, id, action.res.rev, blobBufferUtil.createBlobBuffer(data, stubData.content_type), stubData.content_type);\n    }).then(function (res) {\n      return action.res = res;\n    });\n  });\n  return currentPromise;\n}\nexport var rxdb = true;\nexport var prototypes = {\n  RxDocument: function RxDocument(proto) {\n    proto.putAttachment = putAttachment;\n    proto.getAttachment = getAttachment;\n    proto.allAttachments = allAttachments;\n    Object.defineProperty(proto, 'allAttachments$', {\n      get: function allAttachments$() {\n        var _this4 = this;\n\n        return this._dataSync$.pipe(map(function (data) {\n          if (!data['_attachments']) return {};\n          return data['_attachments'];\n        }), map(function (attachmentsData) {\n          return Object.entries(attachmentsData);\n        }), map(function (entries) {\n          return entries.map(function (_ref4) {\n            var id = _ref4[0],\n                attachmentData = _ref4[1];\n            return fromPouchDocument(id, attachmentData, _this4);\n          });\n        }));\n      }\n    });\n  }\n};\nexport var overwritable = {};\nexport var hooks = {\n  preMigrateDocument: preMigrateDocument,\n  postMigrateDocument: postMigrateDocument\n};\nexport var RxDBAttachmentsPlugin = {\n  name: 'attachments',\n  rxdb: rxdb,\n  prototypes: prototypes,\n  overwritable: overwritable,\n  hooks: hooks\n};\n//# sourceMappingURL=attachments.js.map"]},"metadata":{},"sourceType":"module"}
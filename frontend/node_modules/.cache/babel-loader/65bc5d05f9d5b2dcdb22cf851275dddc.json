{"ast":null,"code":"import _regeneratorRuntime from \"/Users/Hanzalah/Desktop/github/todo-offline/rxdb-hasura-demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _classCallCheck from \"/Users/Hanzalah/Desktop/github/todo-offline/rxdb-hasura-demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/Hanzalah/Desktop/github/todo-offline/rxdb-hasura-demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport RxDB from 'rxdb';\nimport { todoSchema } from './Schema';\nimport RxDBSchemaCheckModule from 'rxdb/plugins/schema-check';\nimport RxDBErrorMessagesModule from 'rxdb/plugins/error-messages';\nimport RxDBValidateModule from 'rxdb/plugins/validate';\nimport RxDBReplicationGraphQL from 'rxdb/plugins/replication-graphql';\nimport { SubscriptionClient } from 'subscriptions-transport-ws';\nRxDB.plugin(RxDBSchemaCheckModule);\nRxDB.plugin(RxDBErrorMessagesModule);\nRxDB.plugin(RxDBValidateModule);\nRxDB.plugin(RxDBReplicationGraphQL);\nRxDB.plugin(require('pouchdb-adapter-idb'));\nvar syncURL = 'https://todo-offline.hasura.app/v1/graphql';\nvar batchSize = 5;\n\nvar pullQueryBuilder = function pullQueryBuilder(userId) {\n  return function (doc) {\n    if (!doc) {\n      doc = {\n        id: '',\n        updatedAt: new Date(0).toUTCString()\n      };\n    }\n\n    var query = \"{\\n            todos(\\n                where: {\\n                    _or: [\\n                        {updatedAt: {_gt: \\\"\".concat(doc.updatedAt, \"\\\"}},\\n                        {\\n                            updatedAt: {_eq: \\\"\").concat(doc.updatedAt, \"\\\"},\\n                            id: {_gt: \\\"\").concat(doc.id, \"\\\"}\\n                        }\\n                    ],\\n                    userId: {_eq: \\\"\").concat(userId, \"\\\"} \\n                },\\n                limit: \").concat(batchSize, \",\\n                order_by: [{updatedAt: asc}, {id: asc}]\\n            ) {\\n                id\\n                text\\n                isCompleted\\n                deleted\\n                createdAt\\n                updatedAt\\n                userId\\n            }\\n        }\");\n    return {\n      query: query,\n      variables: {}\n    };\n  };\n};\n\nvar pushQueryBuilder = function pushQueryBuilder(doc) {\n  var query = \"\\n        mutation InsertTodo($todo: [todos_insert_input!]!) {\\n            insert_todos(\\n                objects: $todo,\\n                on_conflict: {\\n                    constraint: todos_pkey,\\n                    update_columns: [text, isCompleted, deleted, updatedAt]\\n                }){\\n                returning {\\n                  id\\n                }\\n              }\\n       }\\n    \";\n  var variables = {\n    todo: doc\n  };\n  return {\n    query: query,\n    variables: variables\n  };\n};\n\nexport var GraphQLReplicator =\n/*#__PURE__*/\nfunction () {\n  function GraphQLReplicator(db) {\n    _classCallCheck(this, GraphQLReplicator);\n\n    this.db = db;\n    this.replicationState = null;\n    this.subscriptionClient = null;\n  }\n\n  _createClass(GraphQLReplicator, [{\n    key: \"restart\",\n    value: function restart(auth) {\n      return _regeneratorRuntime.async(function restart$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (this.replicationState) {\n                this.replicationState.cancel();\n              }\n\n              if (this.subscriptionClient) {\n                this.subscriptionClient.close();\n              }\n\n              _context.next = 4;\n              return _regeneratorRuntime.awrap(this.setupGraphQLReplication(auth));\n\n            case 4:\n              this.replicationState = _context.sent;\n              this.subscriptionClient = this.setupGraphQLSubscription(auth, this.replicationState);\n\n            case 6:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, null, this);\n    }\n  }, {\n    key: \"setupGraphQLReplication\",\n    value: function setupGraphQLReplication(auth) {\n      var replicationState;\n      return _regeneratorRuntime.async(function setupGraphQLReplication$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              replicationState = this.db.todos.syncGraphQL({\n                url: syncURL,\n                headers: {\n                  'Authorization': \"Bearer \".concat(auth.idToken)\n                },\n                push: {\n                  batchSize: batchSize,\n                  queryBuilder: pushQueryBuilder\n                },\n                pull: {\n                  queryBuilder: pullQueryBuilder(auth.userId)\n                },\n                live: true,\n\n                /**\n                 * Because the websocket is used to inform the client\n                 * when something has changed,\n                 * we can set the liveIntervall to a high value\n                 */\n                liveInterval: 2000 * 60 * 10,\n                // 10 minutes\n                deletedFlag: 'deleted'\n              });\n              replicationState.error$.subscribe(function (err) {\n                console.error('replication error:');\n                console.dir(err);\n              });\n              return _context2.abrupt(\"return\", replicationState);\n\n            case 3:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, null, this);\n    }\n  }, {\n    key: \"setupGraphQLSubscription\",\n    value: function setupGraphQLSubscription(auth, replicationState) {\n      // Change this url to point to your hasura graphql url\n      var endpointURL = 'wss://todo-offline.hasura.app/v1/graphql';\n      var wsClient = new SubscriptionClient(endpointURL, {\n        reconnect: true,\n        connectionParams: {\n          headers: {\n            'Authorization': \"Bearer \".concat(auth.idToken)\n          }\n        },\n        timeout: 3000 * 60,\n        onConnect: function onConnect() {\n          console.log('SubscriptionClient.onConnect()');\n        },\n        connectionCallback: function connectionCallback() {\n          console.log('SubscriptionClient.connectionCallback:');\n        },\n        reconnectionAttempts: 10000,\n        inactivityTimeout: 10 * 1000,\n        lazy: true\n      });\n      var query = \"subscription onTodoChanged {\\n            todos {\\n                id\\n                deleted\\n                isCompleted\\n                text\\n            }       \\n        }\";\n      var ret = wsClient.request({\n        query: query\n      });\n      ret.subscribe({\n        next: function next(data) {\n          console.log('subscription emitted => trigger run');\n          console.dir(data);\n          replicationState.run();\n        },\n        error: function error(_error) {\n          console.log('got error:');\n          console.dir(_error);\n        }\n      });\n      return wsClient;\n    }\n  }]);\n\n  return GraphQLReplicator;\n}();\nexport var createDb = function createDb() {\n  var db;\n  return _regeneratorRuntime.async(function createDb$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          console.log('DatabaseService: creating database..');\n          _context3.next = 3;\n          return _regeneratorRuntime.awrap(RxDB.create({\n            name: 'tododb',\n            adapter: 'idb'\n          }));\n\n        case 3:\n          db = _context3.sent;\n          console.log('DatabaseService: created database');\n          window['db'] = db; // write to window for debugging\n\n          _context3.next = 8;\n          return _regeneratorRuntime.awrap(db.collection({\n            name: 'todos',\n            schema: todoSchema\n          }));\n\n        case 8:\n          return _context3.abrupt(\"return\", db);\n\n        case 9:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  });\n};","map":{"version":3,"sources":["/Users/Hanzalah/Desktop/github/todo-offline/rxdb-hasura-demo/src/components/Database.js"],"names":["RxDB","todoSchema","RxDBSchemaCheckModule","RxDBErrorMessagesModule","RxDBValidateModule","RxDBReplicationGraphQL","SubscriptionClient","plugin","require","syncURL","batchSize","pullQueryBuilder","userId","doc","id","updatedAt","Date","toUTCString","query","variables","pushQueryBuilder","todo","GraphQLReplicator","db","replicationState","subscriptionClient","auth","cancel","close","setupGraphQLReplication","setupGraphQLSubscription","todos","syncGraphQL","url","headers","idToken","push","queryBuilder","pull","live","liveInterval","deletedFlag","error$","subscribe","err","console","error","dir","endpointURL","wsClient","reconnect","connectionParams","timeout","onConnect","log","connectionCallback","reconnectionAttempts","inactivityTimeout","lazy","ret","request","next","data","run","createDb","create","name","adapter","window","collection","schema"],"mappings":";;;AAAA,OAAOA,IAAP,MAAiB,MAAjB;AACA,SAASC,UAAT,QAA2B,UAA3B;AACA,OAAOC,qBAAP,MAAkC,2BAAlC;AACA,OAAOC,uBAAP,MAAoC,6BAApC;AACA,OAAOC,kBAAP,MAA+B,uBAA/B;AACA,OAAOC,sBAAP,MAAmC,kCAAnC;AACA,SAASC,kBAAT,QAAmC,4BAAnC;AAGAN,IAAI,CAACO,MAAL,CAAYL,qBAAZ;AACAF,IAAI,CAACO,MAAL,CAAYJ,uBAAZ;AACAH,IAAI,CAACO,MAAL,CAAYH,kBAAZ;AACAJ,IAAI,CAACO,MAAL,CAAYF,sBAAZ;AACAL,IAAI,CAACO,MAAL,CAAYC,OAAO,CAAC,qBAAD,CAAnB;AAEA,IAAMC,OAAO,GAAG,4CAAhB;AAEA,IAAMC,SAAS,GAAG,CAAlB;;AACA,IAAMC,gBAAgB,GAAG,SAAnBA,gBAAmB,CAACC,MAAD,EAAY;AACjC,SAAO,UAACC,GAAD,EAAS;AACZ,QAAI,CAACA,GAAL,EAAU;AACNA,MAAAA,GAAG,GAAG;AACFC,QAAAA,EAAE,EAAE,EADF;AAEFC,QAAAA,SAAS,EAAE,IAAIC,IAAJ,CAAS,CAAT,EAAYC,WAAZ;AAFT,OAAN;AAIH;;AACD,QAAMC,KAAK,sIAI0BL,GAAG,CAACE,SAJ9B,8FAM6BF,GAAG,CAACE,SANjC,2DAOsBF,GAAG,CAACC,EAP1B,yGAUkBF,MAVlB,8DAYMF,SAZN,wRAAX;AAwBA,WAAO;AACHQ,MAAAA,KAAK,EAALA,KADG;AAEHC,MAAAA,SAAS,EAAE;AAFR,KAAP;AAIH,GAnCD;AAoCH,CArCD;;AAsCA,IAAMC,gBAAgB,GAAG,SAAnBA,gBAAmB,CAAAP,GAAG,EAAI;AAC5B,MAAMK,KAAK,qZAAX;AAcA,MAAMC,SAAS,GAAG;AACdE,IAAAA,IAAI,EAAER;AADQ,GAAlB;AAGA,SAAO;AACHK,IAAAA,KAAK,EAALA,KADG;AAEHC,IAAAA,SAAS,EAATA;AAFG,GAAP;AAIH,CAtBD;;AAuBA,WAAaG,iBAAb;AAAA;AAAA;AACI,6BAAYC,EAAZ,EAAgB;AAAA;;AACZ,SAAKA,EAAL,GAAUA,EAAV;AACA,SAAKC,gBAAL,GAAwB,IAAxB;AACA,SAAKC,kBAAL,GAA0B,IAA1B;AACH;;AALL;AAAA;AAAA,4BAMkBC,IANlB;AAAA;AAAA;AAAA;AAAA;AAOQ,kBAAG,KAAKF,gBAAR,EAA0B;AACtB,qBAAKA,gBAAL,CAAsBG,MAAtB;AACH;;AACD,kBAAG,KAAKF,kBAAR,EAA4B;AACxB,qBAAKA,kBAAL,CAAwBG,KAAxB;AACH;;AAZT;AAAA,+CAasC,KAAKC,uBAAL,CAA6BH,IAA7B,CAbtC;;AAAA;AAaQ,mBAAKF,gBAbb;AAcQ,mBAAKC,kBAAL,GAA0B,KAAKK,wBAAL,CAA8BJ,IAA9B,EAAoC,KAAKF,gBAAzC,CAA1B;;AAdR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,4CAgBkCE,IAhBlC;AAAA;AAAA;AAAA;AAAA;AAAA;AAiBcF,cAAAA,gBAjBd,GAiBiC,KAAKD,EAAL,CAAQQ,KAAR,CAAcC,WAAd,CAA0B;AAChDC,gBAAAA,GAAG,EAAExB,OAD2C;AAEhDyB,gBAAAA,OAAO,EAAE;AACL,oDAA2BR,IAAI,CAACS,OAAhC;AADK,iBAFuC;AAKhDC,gBAAAA,IAAI,EAAE;AACF1B,kBAAAA,SAAS,EAATA,SADE;AAEF2B,kBAAAA,YAAY,EAAEjB;AAFZ,iBAL0C;AAShDkB,gBAAAA,IAAI,EAAE;AACFD,kBAAAA,YAAY,EAAE1B,gBAAgB,CAACe,IAAI,CAACd,MAAN;AAD5B,iBAT0C;AAYhD2B,gBAAAA,IAAI,EAAE,IAZ0C;;AAahD;;;;;AAKAC,gBAAAA,YAAY,EAAE,OAAO,EAAP,GAAY,EAlBsB;AAkBlB;AAC9BC,gBAAAA,WAAW,EAAE;AAnBmC,eAA1B,CAjBjC;AAuCOjB,cAAAA,gBAAgB,CAACkB,MAAjB,CAAwBC,SAAxB,CAAkC,UAAAC,GAAG,EAAI;AACrCC,gBAAAA,OAAO,CAACC,KAAR,CAAc,oBAAd;AACAD,gBAAAA,OAAO,CAACE,GAAR,CAAYH,GAAZ;AACH,eAHD;AAvCP,gDA2CcpB,gBA3Cd;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,6CA8C6BE,IA9C7B,EA8CmCF,gBA9CnC,EA8CqD;AAC7C;AACA,UAAMwB,WAAW,GAAG,0CAApB;AACA,UAAMC,QAAQ,GAAG,IAAI3C,kBAAJ,CAAuB0C,WAAvB,EAAoC;AACjDE,QAAAA,SAAS,EAAE,IADsC;AAEjDC,QAAAA,gBAAgB,EAAE;AACdjB,UAAAA,OAAO,EAAE;AACL,8CAA2BR,IAAI,CAACS,OAAhC;AADK;AADK,SAF+B;AAOjDiB,QAAAA,OAAO,EAAE,OAAO,EAPiC;AAQjDC,QAAAA,SAAS,EAAE,qBAAM;AACbR,UAAAA,OAAO,CAACS,GAAR,CAAY,gCAAZ;AACH,SAVgD;AAWjDC,QAAAA,kBAAkB,EAAE,8BAAM;AACtBV,UAAAA,OAAO,CAACS,GAAR,CAAY,wCAAZ;AACH,SAbgD;AAcjDE,QAAAA,oBAAoB,EAAE,KAd2B;AAejDC,QAAAA,iBAAiB,EAAE,KAAK,IAfyB;AAgBjDC,QAAAA,IAAI,EAAE;AAhB2C,OAApC,CAAjB;AAmBA,UAAMxC,KAAK,uLAAX;AASA,UAAMyC,GAAG,GAAGV,QAAQ,CAACW,OAAT,CAAiB;AAAE1C,QAAAA,KAAK,EAALA;AAAF,OAAjB,CAAZ;AAEAyC,MAAAA,GAAG,CAAChB,SAAJ,CAAc;AACVkB,QAAAA,IADU,gBACLC,IADK,EACC;AACPjB,UAAAA,OAAO,CAACS,GAAR,CAAY,qCAAZ;AACAT,UAAAA,OAAO,CAACE,GAAR,CAAYe,IAAZ;AACAtC,UAAAA,gBAAgB,CAACuC,GAAjB;AACH,SALS;AAMVjB,QAAAA,KANU,iBAMJA,MANI,EAMG;AACTD,UAAAA,OAAO,CAACS,GAAR,CAAY,YAAZ;AACAT,UAAAA,OAAO,CAACE,GAAR,CAAYD,MAAZ;AACH;AATS,OAAd;AAYA,aAAOG,QAAP;AACH;AA5FL;;AAAA;AAAA;AAgGA,OAAO,IAAMe,QAAQ,GAAG,SAAXA,QAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AACpBnB,UAAAA,OAAO,CAACS,GAAR,CAAY,sCAAZ;AADoB;AAAA,2CAEHtD,IAAI,CAACiE,MAAL,CAAY;AACzBC,YAAAA,IAAI,EAAE,QADmB;AAEzBC,YAAAA,OAAO,EAAE;AAFgB,WAAZ,CAFG;;AAAA;AAEd5C,UAAAA,EAFc;AAMpBsB,UAAAA,OAAO,CAACS,GAAR,CAAY,mCAAZ;AACAc,UAAAA,MAAM,CAAC,IAAD,CAAN,GAAe7C,EAAf,CAPoB,CAOD;;AAPC;AAAA,2CAQdA,EAAE,CAAC8C,UAAH,CAAc;AAChBH,YAAAA,IAAI,EAAE,OADU;AAEhBI,YAAAA,MAAM,EAAErE;AAFQ,WAAd,CARc;;AAAA;AAAA,4CAYbsB,EAZa;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,CAAjB","sourcesContent":["import RxDB from 'rxdb';\nimport { todoSchema } from './Schema';\nimport RxDBSchemaCheckModule from 'rxdb/plugins/schema-check';\nimport RxDBErrorMessagesModule from 'rxdb/plugins/error-messages';\nimport RxDBValidateModule from 'rxdb/plugins/validate';\nimport RxDBReplicationGraphQL from 'rxdb/plugins/replication-graphql';\nimport { SubscriptionClient } from 'subscriptions-transport-ws';\n\n\nRxDB.plugin(RxDBSchemaCheckModule);\nRxDB.plugin(RxDBErrorMessagesModule);\nRxDB.plugin(RxDBValidateModule);\nRxDB.plugin(RxDBReplicationGraphQL);\nRxDB.plugin(require('pouchdb-adapter-idb'));\n\nconst syncURL = 'https://todo-offline.hasura.app/v1/graphql';\n\nconst batchSize = 5;\nconst pullQueryBuilder = (userId) => {\n    return (doc) => {\n        if (!doc) {\n            doc = {\n                id: '',\n                updatedAt: new Date(0).toUTCString()\n            };\n        }\n        const query = `{\n            todos(\n                where: {\n                    _or: [\n                        {updatedAt: {_gt: \"${doc.updatedAt}\"}},\n                        {\n                            updatedAt: {_eq: \"${doc.updatedAt}\"},\n                            id: {_gt: \"${doc.id}\"}\n                        }\n                    ],\n                    userId: {_eq: \"${userId}\"} \n                },\n                limit: ${batchSize},\n                order_by: [{updatedAt: asc}, {id: asc}]\n            ) {\n                id\n                text\n                isCompleted\n                deleted\n                createdAt\n                updatedAt\n                userId\n            }\n        }`;\n        return {\n            query,\n            variables: {}\n        };\n    };\n};\nconst pushQueryBuilder = doc => {\n    const query = `\n        mutation InsertTodo($todo: [todos_insert_input!]!) {\n            insert_todos(\n                objects: $todo,\n                on_conflict: {\n                    constraint: todos_pkey,\n                    update_columns: [text, isCompleted, deleted, updatedAt]\n                }){\n                returning {\n                  id\n                }\n              }\n       }\n    `;\n    const variables = {\n        todo: doc\n    };\n    return {\n        query,\n        variables\n    };\n};\nexport class GraphQLReplicator {\n    constructor(db) {\n        this.db = db;\n        this.replicationState = null;\n        this.subscriptionClient = null;      \n    }\n    async restart(auth) {\n        if(this.replicationState) {\n            this.replicationState.cancel()\n        }\n        if(this.subscriptionClient) {\n            this.subscriptionClient.close()\n        }\n        this.replicationState = await this.setupGraphQLReplication(auth)\n        this.subscriptionClient = this.setupGraphQLSubscription(auth, this.replicationState)\n    }\n    async setupGraphQLReplication(auth) {\n        const replicationState = this.db.todos.syncGraphQL({\n           url: syncURL,\n           headers: {\n               'Authorization': `Bearer ${auth.idToken}`\n           },\n           push: {\n               batchSize,\n               queryBuilder: pushQueryBuilder\n           },\n           pull: {\n               queryBuilder: pullQueryBuilder(auth.userId)\n           },\n           live: true,\n           /**\n            * Because the websocket is used to inform the client\n            * when something has changed,\n            * we can set the liveIntervall to a high value\n            */\n           liveInterval: 2000 * 60 * 10, // 10 minutes\n           deletedFlag: 'deleted'\n       });\n   \n       replicationState.error$.subscribe(err => {\n           console.error('replication error:');\n           console.dir(err);\n       });\n       return replicationState;\n    }\n   \n    setupGraphQLSubscription(auth, replicationState) {\n        // Change this url to point to your hasura graphql url\n        const endpointURL = 'wss://todo-offline.hasura.app/v1/graphql';\n        const wsClient = new SubscriptionClient(endpointURL, {\n            reconnect: true,\n            connectionParams: {\n                headers: {\n                    'Authorization': `Bearer ${auth.idToken}`\n                }\n            },\n            timeout: 3000 * 60,\n            onConnect: () => {\n                console.log('SubscriptionClient.onConnect()');\n            },\n            connectionCallback: () => {\n                console.log('SubscriptionClient.connectionCallback:');\n            },\n            reconnectionAttempts: 10000,\n            inactivityTimeout: 10 * 1000,\n            lazy: true\n        });\n    \n        const query = `subscription onTodoChanged {\n            todos {\n                id\n                deleted\n                isCompleted\n                text\n            }       \n        }`;\n    \n        const ret = wsClient.request({ query });\n    \n        ret.subscribe({\n            next(data) {\n                console.log('subscription emitted => trigger run');\n                console.dir(data);\n                replicationState.run();\n            },\n            error(error) {\n                console.log('got error:');\n                console.dir(error);\n            }\n        });\n    \n        return wsClient\n    }    \n}\n\n\nexport const createDb = async () => {\n    console.log('DatabaseService: creating database..');\n    const db = await RxDB.create({\n        name: 'tododb',\n        adapter: 'idb',\n    });\n    console.log('DatabaseService: created database');\n    window['db'] = db; // write to window for debugging\n    await db.collection({\n        name: 'todos',\n        schema: todoSchema\n     })\n    return db;\n};"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _createClass from \"@babel/runtime/helpers/createClass\";\nimport deepEqual from 'deep-equal';\nimport { merge, BehaviorSubject } from 'rxjs';\nimport { mergeMap, filter, map, first, tap } from 'rxjs/operators';\nimport { massageSelector, filterInMemoryFields } from 'pouchdb-selector-core';\nimport { sortObject, stringifyFilter, pluginMissing, clone, overwriteGetterForCaching, now } from './util';\nimport { newRxError, newRxTypeError } from './rx-error';\nimport { runPluginHooks } from './hooks';\nimport { createRxDocuments } from './rx-document-prototype-merge';\nimport { calculateNewResults } from './event-reduce';\nimport { triggerCacheReplacement } from './query-cache';\nvar _queryCount = 0;\n\nvar newQueryID = function newQueryID() {\n  return ++_queryCount;\n};\n\nexport var RxQueryBase =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Some stats then are used for debugging and cache replacement policies\n   */\n  // used by some plugins\n  // used to count the subscribers to the query\n  function RxQueryBase(op, mangoQuery, collection) {\n    this.id = newQueryID();\n    this._execOverDatabaseCount = 0;\n    this._creationTime = now();\n    this._lastEnsureEqual = 0;\n    this.other = {};\n    this.uncached = false;\n    this.refCount$ = new BehaviorSubject(null);\n    this._latestChangeEvent = -1;\n    this._resultsData = null;\n    this._resultsDataMap = new Map();\n    this._lastExecStart = 0;\n    this._lastExecEnd = 0;\n    this._resultsDocs$ = new BehaviorSubject(null);\n    this._ensureEqualQueue = Promise.resolve(false);\n    this.op = op;\n    this.mangoQuery = mangoQuery;\n    this.collection = collection;\n\n    if (!mangoQuery) {\n      mangoQuery = _getDefaultQuery(this.collection);\n    }\n  }\n\n  var _proto = RxQueryBase.prototype;\n  /**\n   * set the new result-data as result-docs of the query\n   * @param newResultData json-docs that were recieved from pouchdb\n   */\n\n  _proto._setResultData = function _setResultData(newResultData) {\n    this._resultsData = newResultData;\n    var docs = createRxDocuments(this.collection, this._resultsData);\n\n    this._resultsDocs$.next(docs);\n\n    return docs;\n  }\n  /**\n   * executes the query on the database\n   * @return results-array with document-data\n   */\n  ;\n\n  _proto._execOverDatabase = function _execOverDatabase() {\n    var _this = this;\n\n    this._execOverDatabaseCount = this._execOverDatabaseCount + 1;\n    this._lastExecStart = now();\n    var docsPromise;\n\n    switch (this.op) {\n      case 'find':\n        docsPromise = this.collection._pouchFind(this);\n        break;\n\n      case 'findOne':\n        docsPromise = this.collection._pouchFind(this, 1);\n        break;\n\n      default:\n        throw newRxError('QU1', {\n          op: this.op\n        });\n    }\n\n    return docsPromise.then(function (docs) {\n      _this._lastExecEnd = now();\n      _this._resultsDataMap = new Map();\n      var primPath = _this.collection.schema.primaryPath;\n      docs.forEach(function (doc) {\n        var id = doc[primPath];\n\n        _this._resultsDataMap.set(id, doc);\n      });\n      return docs;\n    });\n  }\n  /**\n   * Execute the query\n   * To have an easier implementations,\n   * just subscribe and use the first result\n   */\n  ;\n\n  _proto.exec = function exec(throwIfMissing) {\n    var _this2 = this; // TODO this should be ensured by typescript\n\n\n    if (throwIfMissing && this.op !== 'findOne') {\n      throw newRxError('QU9', {\n        query: this.mangoQuery,\n        op: this.op\n      });\n    }\n    /**\n     * run _ensureEqual() here,\n     * this will make sure that errors in the query which throw inside of pouchdb,\n     * will be thrown at this execution context\n     */\n\n\n    return _ensureEqual(this).then(function () {\n      return _this2.$.pipe(first()).toPromise();\n    }).then(function (result) {\n      if (!result && throwIfMissing) {\n        throw newRxError('QU10', {\n          query: _this2.mangoQuery,\n          op: _this2.op\n        });\n      } else {\n        return result;\n      }\n    });\n  }\n  /**\n   * cached call to get the massageSelector\n   * @overwrites itself with the actual value\n   */\n  ;\n  /**\n   * returns a string that is used for equal-comparisons\n   * @overwrites itself with the actual value\n   */\n\n\n  _proto.toString = function toString() {\n    var stringObj = sortObject({\n      op: this.op,\n      query: this.mangoQuery,\n      other: this.other\n    }, true);\n    var value = JSON.stringify(stringObj, stringifyFilter);\n\n    this.toString = function () {\n      return value;\n    };\n\n    return value;\n  }\n  /**\n   * returns the prepared query\n   * @overwrites itself with the actual value\n   */\n  ;\n\n  _proto.toJSON = function toJSON() {\n    var value = this.collection.database.storage.prepareQuery(this.asRxQuery, clone(this.mangoQuery));\n\n    this.toJSON = function () {\n      return value;\n    };\n\n    return value;\n  }\n  /**\n   * returns the key-compressed version of the query\n   * @overwrites itself with the actual value\n   */\n  ;\n\n  _proto.keyCompress = function keyCompress() {\n    var value;\n\n    if (!this.collection.schema.doKeyCompression()) {\n      value = this.toJSON();\n    } else {\n      value = this.collection._keyCompressor.compressQuery(this.toJSON());\n    }\n\n    this.keyCompress = function () {\n      return value;\n    };\n\n    return value;\n  }\n  /**\n   * returns true if the document matches the query,\n   * does not use the 'skip' and 'limit'\n   * // TODO this was moved to rx-storage\n   */\n  ;\n\n  _proto.doesDocumentDataMatch = function doesDocumentDataMatch(docData) {\n    // if doc is deleted, it cannot match\n    if (docData._deleted) return false;\n    docData = this.collection.schema.swapPrimaryToId(docData); // return matchesSelector(docData, selector);\n\n    /**\n     * the following is equal to the implementation of pouchdb\n     * we do not use matchesSelector() directly so we can cache the\n     * result of massageSelector\n     * @link https://github.com/pouchdb/pouchdb/blob/master/packages/node_modules/pouchdb-selector-core/src/matches-selector.js\n     */\n\n    var selector = this.massageSelector;\n    var row = {\n      doc: docData\n    };\n    var rowsMatched = filterInMemoryFields([row], {\n      selector: selector\n    }, Object.keys(selector));\n    return rowsMatched && rowsMatched.length === 1;\n  }\n  /**\n   * deletes all found documents\n   * @return promise with deleted documents\n   */\n  ;\n\n  _proto.remove = function remove() {\n    var ret;\n    return this.exec().then(function (docs) {\n      ret = docs;\n      if (Array.isArray(docs)) return Promise.all(docs.map(function (doc) {\n        return doc.remove();\n      }));else return docs.remove();\n    }).then(function () {\n      return ret;\n    });\n  }\n  /**\n   * helper function to transform RxQueryBase to RxQuery type\n   */\n  ;\n  /**\n   * updates all found documents\n   * @overwritten by plugin (optional)\n   */\n\n\n  _proto.update = function update(_updateObj) {\n    throw pluginMissing('update');\n  } // we only set some methods of query-builder here\n  // because the others depend on these ones\n  ;\n\n  _proto.where = function where(_queryObj) {\n    throw pluginMissing('query-builder');\n  };\n\n  _proto.sort = function sort(_params) {\n    throw pluginMissing('query-builder');\n  };\n\n  _proto.skip = function skip(_amount) {\n    throw pluginMissing('query-builder');\n  };\n\n  _proto.limit = function limit(_amount) {\n    throw pluginMissing('query-builder');\n  };\n\n  _createClass(RxQueryBase, [{\n    key: \"$\",\n    get: function get() {\n      var _this3 = this;\n\n      if (!this._$) {\n        /**\n         * We use _resultsDocs$ to emit new results\n         * This also ensure that there is a reemit on subscribe\n         */\n        var results$ = this._resultsDocs$.pipe(mergeMap(function (docs) {\n          return _ensureEqual(_this3).then(function (hasChanged) {\n            if (hasChanged) return false; // wait for next emit\n            else return docs;\n          });\n        }), filter(function (docs) {\n          return !!docs;\n        }), // not if previous returned false\n        map(function (docs) {\n          // findOne()-queries emit document or null\n          if (_this3.op === 'findOne') {\n            var doc = docs.length === 0 ? null : docs[0];\n            return doc;\n          } else return docs; // find()-queries emit RxDocument[]\n\n        }), map(function (docs) {\n          // copy the array so it wont matter if the user modifies it\n          var ret = Array.isArray(docs) ? docs.slice() : docs;\n          return ret;\n        }))['asObservable']();\n        /**\n         * subscribe to the changeEvent-stream so it detects changes if it has subscribers\n         */\n\n\n        var changeEvents$ = this.collection.$.pipe(tap(function () {\n          return _ensureEqual(_this3);\n        }), filter(function () {\n          return false;\n        }));\n        this._$ = // tslint:disable-next-line\n        merge(results$, changeEvents$, this.refCount$.pipe(filter(function () {\n          return false;\n        })));\n      }\n\n      return this._$;\n    } // stores the changeEvent-Number of the last handled change-event\n\n  }, {\n    key: \"massageSelector\",\n    get: function get() {\n      return overwriteGetterForCaching(this, 'massageSelector', massageSelector(this.mangoQuery.selector));\n    }\n  }, {\n    key: \"asRxQuery\",\n    get: function get() {\n      return this;\n    }\n  }]);\n\n  return RxQueryBase;\n}();\nexport function _getDefaultQuery(collection) {\n  var _selector;\n\n  return {\n    selector: (_selector = {}, _selector[collection.schema.primaryPath] = {}, _selector)\n  };\n}\n/**\n * run this query through the QueryCache\n */\n\nexport function tunnelQueryCache(rxQuery) {\n  return rxQuery.collection._queryCache.getByQuery(rxQuery);\n}\nexport function createRxQuery(op, queryObj, collection) {\n  // checks\n  if (queryObj && typeof queryObj !== 'object') {\n    throw newRxTypeError('QU7', {\n      queryObj: queryObj\n    });\n  }\n\n  if (Array.isArray(queryObj)) {\n    throw newRxTypeError('QU8', {\n      queryObj: queryObj\n    });\n  }\n\n  runPluginHooks('preCreateRxQuery', {\n    op: op,\n    queryObj: queryObj,\n    collection: collection\n  });\n  var ret = new RxQueryBase(op, queryObj, collection); // ensure when created with same params, only one is created\n\n  ret = tunnelQueryCache(ret);\n  runPluginHooks('createRxQuery', ret);\n  triggerCacheReplacement(collection);\n  return ret;\n}\n/**\n * check if the current results-state is in sync with the database\n * @return false if not which means it should re-execute\n */\n\nfunction _isResultsInSync(rxQuery) {\n  if (rxQuery._latestChangeEvent >= rxQuery.collection._changeEventBuffer.counter) {\n    return true;\n  } else return false;\n}\n/**\n * wraps __ensureEqual()\n * to ensure it does not run in parallel\n * @return true if has changed, false if not\n */\n\n\nfunction _ensureEqual(rxQuery) {\n  rxQuery._ensureEqualQueue = rxQuery._ensureEqualQueue.then(function () {\n    return new Promise(function (res) {\n      return setTimeout(res, 0);\n    });\n  }).then(function () {\n    return __ensureEqual(rxQuery);\n  }).then(function (ret) {\n    return new Promise(function (res) {\n      return setTimeout(res, 0);\n    }).then(function () {\n      return ret;\n    });\n  });\n  return rxQuery._ensureEqualQueue;\n}\n/**\n * ensures that the results of this query is equal to the results which a query over the database would give\n * @return true if results have changed\n */\n\n\nfunction __ensureEqual(rxQuery) {\n  rxQuery._lastEnsureEqual = now();\n  if (rxQuery.collection.database.destroyed) return false; // db is closed\n\n  if (_isResultsInSync(rxQuery)) return false; // nothing happend\n\n  var ret = false;\n  var mustReExec = false; // if this becomes true, a whole execution over the database is made\n\n  if (rxQuery._latestChangeEvent === -1) mustReExec = true; // have not executed yet -> must run\n\n  /**\n   * try to use the queryChangeDetector to calculate the new results\n   */\n\n  if (!mustReExec) {\n    var missedChangeEvents = rxQuery.collection._changeEventBuffer.getFrom(rxQuery._latestChangeEvent + 1);\n\n    if (missedChangeEvents === null) {\n      // changeEventBuffer is of bounds -> we must re-execute over the database\n      mustReExec = true;\n    } else {\n      rxQuery._latestChangeEvent = rxQuery.collection._changeEventBuffer.counter;\n      /**\n       * because pouchdb prefers writes over reads,\n       * we have to filter out the events that happend before the read has started\n       * so that we do not fill event-reduce with the wrong data\n       */\n\n      missedChangeEvents = missedChangeEvents.filter(function (cE) {\n        return !cE.startTime || cE.startTime > rxQuery._lastExecStart;\n      });\n\n      var runChangeEvents = rxQuery.collection._changeEventBuffer.reduceByLastOfDoc(missedChangeEvents);\n      /*\n      console.log('calculateNewResults() ' + new Date().getTime());\n      console.log(rxQuery._lastExecStart + ' - ' + rxQuery._lastExecEnd);\n      console.dir(rxQuery._resultsData.slice());\n      console.dir(runChangeEvents);\n      */\n\n\n      var eventReduceResult = calculateNewResults(rxQuery, runChangeEvents);\n\n      if (eventReduceResult.runFullQueryAgain) {\n        // could not calculate the new results, execute must be done\n        mustReExec = true;\n      } else if (eventReduceResult.changed) {\n        // we got the new results, we do not have to re-execute, mustReExec stays false\n        ret = true; // true because results changed\n\n        rxQuery._setResultData(eventReduceResult.newResults);\n      }\n    }\n  } // oh no we have to re-execute the whole query over the database\n\n\n  if (mustReExec) {\n    // counter can change while _execOverDatabase() is running so we save it here\n    var latestAfter = rxQuery.collection._changeEventBuffer.counter;\n    return rxQuery._execOverDatabase().then(function (newResultData) {\n      rxQuery._latestChangeEvent = latestAfter;\n\n      if (!deepEqual(newResultData, rxQuery._resultsData)) {\n        ret = true; // true because results changed\n\n        rxQuery._setResultData(newResultData);\n      }\n\n      return ret;\n    });\n  }\n\n  return ret; // true if results have changed\n}\n\nexport function isInstanceOf(obj) {\n  return obj instanceof RxQueryBase;\n}","map":{"version":3,"sources":["/Users/Hanzalah/Desktop/github/todo-offline/rxdb-hasura-demo/node_modules/rxdb/dist/es/rx-query.js"],"names":["_createClass","deepEqual","merge","BehaviorSubject","mergeMap","filter","map","first","tap","massageSelector","filterInMemoryFields","sortObject","stringifyFilter","pluginMissing","clone","overwriteGetterForCaching","now","newRxError","newRxTypeError","runPluginHooks","createRxDocuments","calculateNewResults","triggerCacheReplacement","_queryCount","newQueryID","RxQueryBase","op","mangoQuery","collection","id","_execOverDatabaseCount","_creationTime","_lastEnsureEqual","other","uncached","refCount$","_latestChangeEvent","_resultsData","_resultsDataMap","Map","_lastExecStart","_lastExecEnd","_resultsDocs$","_ensureEqualQueue","Promise","resolve","_getDefaultQuery","_proto","prototype","_setResultData","newResultData","docs","next","_execOverDatabase","_this","docsPromise","_pouchFind","then","primPath","schema","primaryPath","forEach","doc","set","exec","throwIfMissing","_this2","query","_ensureEqual","$","pipe","toPromise","result","toString","stringObj","value","JSON","stringify","toJSON","database","storage","prepareQuery","asRxQuery","keyCompress","doKeyCompression","_keyCompressor","compressQuery","doesDocumentDataMatch","docData","_deleted","swapPrimaryToId","selector","row","rowsMatched","Object","keys","length","remove","ret","Array","isArray","all","update","_updateObj","where","_queryObj","sort","_params","skip","_amount","limit","key","get","_this3","_$","results$","hasChanged","slice","changeEvents$","_selector","tunnelQueryCache","rxQuery","_queryCache","getByQuery","createRxQuery","queryObj","_isResultsInSync","_changeEventBuffer","counter","res","setTimeout","__ensureEqual","destroyed","mustReExec","missedChangeEvents","getFrom","cE","startTime","runChangeEvents","reduceByLastOfDoc","eventReduceResult","runFullQueryAgain","changed","newResults","latestAfter","isInstanceOf","obj"],"mappings":"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","sourcesContent":["import _createClass from \"@babel/runtime/helpers/createClass\";\nimport deepEqual from 'deep-equal';\nimport { merge, BehaviorSubject } from 'rxjs';\nimport { mergeMap, filter, map, first, tap } from 'rxjs/operators';\nimport { massageSelector, filterInMemoryFields } from 'pouchdb-selector-core';\nimport { sortObject, stringifyFilter, pluginMissing, clone, overwriteGetterForCaching, now } from './util';\nimport { newRxError, newRxTypeError } from './rx-error';\nimport { runPluginHooks } from './hooks';\nimport { createRxDocuments } from './rx-document-prototype-merge';\nimport { calculateNewResults } from './event-reduce';\nimport { triggerCacheReplacement } from './query-cache';\nvar _queryCount = 0;\n\nvar newQueryID = function newQueryID() {\n  return ++_queryCount;\n};\n\nexport var RxQueryBase = /*#__PURE__*/function () {\n  /**\n   * Some stats then are used for debugging and cache replacement policies\n   */\n  // used by some plugins\n  // used to count the subscribers to the query\n  function RxQueryBase(op, mangoQuery, collection) {\n    this.id = newQueryID();\n    this._execOverDatabaseCount = 0;\n    this._creationTime = now();\n    this._lastEnsureEqual = 0;\n    this.other = {};\n    this.uncached = false;\n    this.refCount$ = new BehaviorSubject(null);\n    this._latestChangeEvent = -1;\n    this._resultsData = null;\n    this._resultsDataMap = new Map();\n    this._lastExecStart = 0;\n    this._lastExecEnd = 0;\n    this._resultsDocs$ = new BehaviorSubject(null);\n    this._ensureEqualQueue = Promise.resolve(false);\n    this.op = op;\n    this.mangoQuery = mangoQuery;\n    this.collection = collection;\n\n    if (!mangoQuery) {\n      mangoQuery = _getDefaultQuery(this.collection);\n    }\n  }\n\n  var _proto = RxQueryBase.prototype;\n\n  /**\n   * set the new result-data as result-docs of the query\n   * @param newResultData json-docs that were recieved from pouchdb\n   */\n  _proto._setResultData = function _setResultData(newResultData) {\n    this._resultsData = newResultData;\n    var docs = createRxDocuments(this.collection, this._resultsData);\n\n    this._resultsDocs$.next(docs);\n\n    return docs;\n  }\n  /**\n   * executes the query on the database\n   * @return results-array with document-data\n   */\n  ;\n\n  _proto._execOverDatabase = function _execOverDatabase() {\n    var _this = this;\n\n    this._execOverDatabaseCount = this._execOverDatabaseCount + 1;\n    this._lastExecStart = now();\n    var docsPromise;\n\n    switch (this.op) {\n      case 'find':\n        docsPromise = this.collection._pouchFind(this);\n        break;\n\n      case 'findOne':\n        docsPromise = this.collection._pouchFind(this, 1);\n        break;\n\n      default:\n        throw newRxError('QU1', {\n          op: this.op\n        });\n    }\n\n    return docsPromise.then(function (docs) {\n      _this._lastExecEnd = now();\n      _this._resultsDataMap = new Map();\n      var primPath = _this.collection.schema.primaryPath;\n      docs.forEach(function (doc) {\n        var id = doc[primPath];\n\n        _this._resultsDataMap.set(id, doc);\n      });\n      return docs;\n    });\n  }\n  /**\n   * Execute the query\n   * To have an easier implementations,\n   * just subscribe and use the first result\n   */\n  ;\n\n  _proto.exec = function exec(throwIfMissing) {\n    var _this2 = this;\n\n    // TODO this should be ensured by typescript\n    if (throwIfMissing && this.op !== 'findOne') {\n      throw newRxError('QU9', {\n        query: this.mangoQuery,\n        op: this.op\n      });\n    }\n    /**\n     * run _ensureEqual() here,\n     * this will make sure that errors in the query which throw inside of pouchdb,\n     * will be thrown at this execution context\n     */\n\n\n    return _ensureEqual(this).then(function () {\n      return _this2.$.pipe(first()).toPromise();\n    }).then(function (result) {\n      if (!result && throwIfMissing) {\n        throw newRxError('QU10', {\n          query: _this2.mangoQuery,\n          op: _this2.op\n        });\n      } else {\n        return result;\n      }\n    });\n  }\n  /**\n   * cached call to get the massageSelector\n   * @overwrites itself with the actual value\n   */\n  ;\n\n  /**\n   * returns a string that is used for equal-comparisons\n   * @overwrites itself with the actual value\n   */\n  _proto.toString = function toString() {\n    var stringObj = sortObject({\n      op: this.op,\n      query: this.mangoQuery,\n      other: this.other\n    }, true);\n    var value = JSON.stringify(stringObj, stringifyFilter);\n\n    this.toString = function () {\n      return value;\n    };\n\n    return value;\n  }\n  /**\n   * returns the prepared query\n   * @overwrites itself with the actual value\n   */\n  ;\n\n  _proto.toJSON = function toJSON() {\n    var value = this.collection.database.storage.prepareQuery(this.asRxQuery, clone(this.mangoQuery));\n\n    this.toJSON = function () {\n      return value;\n    };\n\n    return value;\n  }\n  /**\n   * returns the key-compressed version of the query\n   * @overwrites itself with the actual value\n   */\n  ;\n\n  _proto.keyCompress = function keyCompress() {\n    var value;\n\n    if (!this.collection.schema.doKeyCompression()) {\n      value = this.toJSON();\n    } else {\n      value = this.collection._keyCompressor.compressQuery(this.toJSON());\n    }\n\n    this.keyCompress = function () {\n      return value;\n    };\n\n    return value;\n  }\n  /**\n   * returns true if the document matches the query,\n   * does not use the 'skip' and 'limit'\n   * // TODO this was moved to rx-storage\n   */\n  ;\n\n  _proto.doesDocumentDataMatch = function doesDocumentDataMatch(docData) {\n    // if doc is deleted, it cannot match\n    if (docData._deleted) return false;\n    docData = this.collection.schema.swapPrimaryToId(docData); // return matchesSelector(docData, selector);\n\n    /**\n     * the following is equal to the implementation of pouchdb\n     * we do not use matchesSelector() directly so we can cache the\n     * result of massageSelector\n     * @link https://github.com/pouchdb/pouchdb/blob/master/packages/node_modules/pouchdb-selector-core/src/matches-selector.js\n     */\n\n    var selector = this.massageSelector;\n    var row = {\n      doc: docData\n    };\n    var rowsMatched = filterInMemoryFields([row], {\n      selector: selector\n    }, Object.keys(selector));\n    return rowsMatched && rowsMatched.length === 1;\n  }\n  /**\n   * deletes all found documents\n   * @return promise with deleted documents\n   */\n  ;\n\n  _proto.remove = function remove() {\n    var ret;\n    return this.exec().then(function (docs) {\n      ret = docs;\n      if (Array.isArray(docs)) return Promise.all(docs.map(function (doc) {\n        return doc.remove();\n      }));else return docs.remove();\n    }).then(function () {\n      return ret;\n    });\n  }\n  /**\n   * helper function to transform RxQueryBase to RxQuery type\n   */\n  ;\n\n  /**\n   * updates all found documents\n   * @overwritten by plugin (optional)\n   */\n  _proto.update = function update(_updateObj) {\n    throw pluginMissing('update');\n  } // we only set some methods of query-builder here\n  // because the others depend on these ones\n  ;\n\n  _proto.where = function where(_queryObj) {\n    throw pluginMissing('query-builder');\n  };\n\n  _proto.sort = function sort(_params) {\n    throw pluginMissing('query-builder');\n  };\n\n  _proto.skip = function skip(_amount) {\n    throw pluginMissing('query-builder');\n  };\n\n  _proto.limit = function limit(_amount) {\n    throw pluginMissing('query-builder');\n  };\n\n  _createClass(RxQueryBase, [{\n    key: \"$\",\n    get: function get() {\n      var _this3 = this;\n\n      if (!this._$) {\n        /**\n         * We use _resultsDocs$ to emit new results\n         * This also ensure that there is a reemit on subscribe\n         */\n        var results$ = this._resultsDocs$.pipe(mergeMap(function (docs) {\n          return _ensureEqual(_this3).then(function (hasChanged) {\n            if (hasChanged) return false; // wait for next emit\n            else return docs;\n          });\n        }), filter(function (docs) {\n          return !!docs;\n        }), // not if previous returned false\n        map(function (docs) {\n          // findOne()-queries emit document or null\n          if (_this3.op === 'findOne') {\n            var doc = docs.length === 0 ? null : docs[0];\n            return doc;\n          } else return docs; // find()-queries emit RxDocument[]\n\n        }), map(function (docs) {\n          // copy the array so it wont matter if the user modifies it\n          var ret = Array.isArray(docs) ? docs.slice() : docs;\n          return ret;\n        }))['asObservable']();\n        /**\n         * subscribe to the changeEvent-stream so it detects changes if it has subscribers\n         */\n\n\n        var changeEvents$ = this.collection.$.pipe(tap(function () {\n          return _ensureEqual(_this3);\n        }), filter(function () {\n          return false;\n        }));\n        this._$ = // tslint:disable-next-line\n        merge(results$, changeEvents$, this.refCount$.pipe(filter(function () {\n          return false;\n        })));\n      }\n\n      return this._$;\n    } // stores the changeEvent-Number of the last handled change-event\n\n  }, {\n    key: \"massageSelector\",\n    get: function get() {\n      return overwriteGetterForCaching(this, 'massageSelector', massageSelector(this.mangoQuery.selector));\n    }\n  }, {\n    key: \"asRxQuery\",\n    get: function get() {\n      return this;\n    }\n  }]);\n\n  return RxQueryBase;\n}();\nexport function _getDefaultQuery(collection) {\n  var _selector;\n\n  return {\n    selector: (_selector = {}, _selector[collection.schema.primaryPath] = {}, _selector)\n  };\n}\n/**\n * run this query through the QueryCache\n */\n\nexport function tunnelQueryCache(rxQuery) {\n  return rxQuery.collection._queryCache.getByQuery(rxQuery);\n}\nexport function createRxQuery(op, queryObj, collection) {\n  // checks\n  if (queryObj && typeof queryObj !== 'object') {\n    throw newRxTypeError('QU7', {\n      queryObj: queryObj\n    });\n  }\n\n  if (Array.isArray(queryObj)) {\n    throw newRxTypeError('QU8', {\n      queryObj: queryObj\n    });\n  }\n\n  runPluginHooks('preCreateRxQuery', {\n    op: op,\n    queryObj: queryObj,\n    collection: collection\n  });\n  var ret = new RxQueryBase(op, queryObj, collection); // ensure when created with same params, only one is created\n\n  ret = tunnelQueryCache(ret);\n  runPluginHooks('createRxQuery', ret);\n  triggerCacheReplacement(collection);\n  return ret;\n}\n/**\n * check if the current results-state is in sync with the database\n * @return false if not which means it should re-execute\n */\n\nfunction _isResultsInSync(rxQuery) {\n  if (rxQuery._latestChangeEvent >= rxQuery.collection._changeEventBuffer.counter) {\n    return true;\n  } else return false;\n}\n/**\n * wraps __ensureEqual()\n * to ensure it does not run in parallel\n * @return true if has changed, false if not\n */\n\n\nfunction _ensureEqual(rxQuery) {\n  rxQuery._ensureEqualQueue = rxQuery._ensureEqualQueue.then(function () {\n    return new Promise(function (res) {\n      return setTimeout(res, 0);\n    });\n  }).then(function () {\n    return __ensureEqual(rxQuery);\n  }).then(function (ret) {\n    return new Promise(function (res) {\n      return setTimeout(res, 0);\n    }).then(function () {\n      return ret;\n    });\n  });\n  return rxQuery._ensureEqualQueue;\n}\n/**\n * ensures that the results of this query is equal to the results which a query over the database would give\n * @return true if results have changed\n */\n\n\nfunction __ensureEqual(rxQuery) {\n  rxQuery._lastEnsureEqual = now();\n  if (rxQuery.collection.database.destroyed) return false; // db is closed\n\n  if (_isResultsInSync(rxQuery)) return false; // nothing happend\n\n  var ret = false;\n  var mustReExec = false; // if this becomes true, a whole execution over the database is made\n\n  if (rxQuery._latestChangeEvent === -1) mustReExec = true; // have not executed yet -> must run\n\n  /**\n   * try to use the queryChangeDetector to calculate the new results\n   */\n\n  if (!mustReExec) {\n    var missedChangeEvents = rxQuery.collection._changeEventBuffer.getFrom(rxQuery._latestChangeEvent + 1);\n\n    if (missedChangeEvents === null) {\n      // changeEventBuffer is of bounds -> we must re-execute over the database\n      mustReExec = true;\n    } else {\n      rxQuery._latestChangeEvent = rxQuery.collection._changeEventBuffer.counter;\n      /**\n       * because pouchdb prefers writes over reads,\n       * we have to filter out the events that happend before the read has started\n       * so that we do not fill event-reduce with the wrong data\n       */\n\n      missedChangeEvents = missedChangeEvents.filter(function (cE) {\n        return !cE.startTime || cE.startTime > rxQuery._lastExecStart;\n      });\n\n      var runChangeEvents = rxQuery.collection._changeEventBuffer.reduceByLastOfDoc(missedChangeEvents);\n      /*\n      console.log('calculateNewResults() ' + new Date().getTime());\n      console.log(rxQuery._lastExecStart + ' - ' + rxQuery._lastExecEnd);\n      console.dir(rxQuery._resultsData.slice());\n      console.dir(runChangeEvents);\n      */\n\n\n      var eventReduceResult = calculateNewResults(rxQuery, runChangeEvents);\n\n      if (eventReduceResult.runFullQueryAgain) {\n        // could not calculate the new results, execute must be done\n        mustReExec = true;\n      } else if (eventReduceResult.changed) {\n        // we got the new results, we do not have to re-execute, mustReExec stays false\n        ret = true; // true because results changed\n\n        rxQuery._setResultData(eventReduceResult.newResults);\n      }\n    }\n  } // oh no we have to re-execute the whole query over the database\n\n\n  if (mustReExec) {\n    // counter can change while _execOverDatabase() is running so we save it here\n    var latestAfter = rxQuery.collection._changeEventBuffer.counter;\n    return rxQuery._execOverDatabase().then(function (newResultData) {\n      rxQuery._latestChangeEvent = latestAfter;\n\n      if (!deepEqual(newResultData, rxQuery._resultsData)) {\n        ret = true; // true because results changed\n\n        rxQuery._setResultData(newResultData);\n      }\n\n      return ret;\n    });\n  }\n\n  return ret; // true if results have changed\n}\n\nexport function isInstanceOf(obj) {\n  return obj instanceof RxQueryBase;\n}\n//# sourceMappingURL=rx-query.js.map"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { generateErrorFromResponse } from 'pouchdb-errors';\nimport { Headers } from 'pouchdb-fetch';\nimport abstractMapReduce from 'pouchdb-abstract-mapreduce';\nimport { stringMd5 } from 'pouchdb-md5';\nimport { collate } from 'pouchdb-collate';\nimport { getFieldFromDoc, setFieldInDoc, parseField, getKey, getValue, compare, massageSelector, filterInMemoryFields } from 'pouchdb-selector-core';\nimport { clone, assign, nextTick, upsert, toPromise, isRemote } from 'pouchdb-utils'; // we restucture the supplied JSON considerably, because the official\n// Mango API is very particular about a lot of this stuff, but we like\n// to be liberal with what we accept in order to prevent mental\n// breakdowns in our users\n\nfunction massageCreateIndexRequest(requestDef) {\n  requestDef = clone(requestDef);\n\n  if (!requestDef.index) {\n    requestDef.index = {};\n  }\n\n  ['type', 'name', 'ddoc'].forEach(function (key) {\n    if (requestDef.index[key]) {\n      requestDef[key] = requestDef.index[key];\n      delete requestDef.index[key];\n    }\n  });\n\n  if (requestDef.fields) {\n    requestDef.index.fields = requestDef.fields;\n    delete requestDef.fields;\n  }\n\n  if (!requestDef.type) {\n    requestDef.type = 'json';\n  }\n\n  return requestDef;\n}\n\nfunction dbFetch(db, path, opts, callback) {\n  var status, ok;\n  opts.headers = new Headers({\n    'Content-type': 'application/json'\n  });\n  db.fetch(path, opts).then(function (response) {\n    status = response.status;\n    ok = response.ok;\n    return response.json();\n  }).then(function (json) {\n    if (!ok) {\n      json.status = status;\n      var err = generateErrorFromResponse(json);\n      callback(err);\n    } else {\n      callback(null, json);\n    }\n  }).catch(callback);\n}\n\nfunction createIndex(db, requestDef, callback) {\n  requestDef = massageCreateIndexRequest(requestDef);\n  dbFetch(db, '_index', {\n    method: 'POST',\n    body: JSON.stringify(requestDef)\n  }, callback);\n}\n\nfunction find(db, requestDef, callback) {\n  dbFetch(db, '_find', {\n    method: 'POST',\n    body: JSON.stringify(requestDef)\n  }, callback);\n}\n\nfunction explain(db, requestDef, callback) {\n  dbFetch(db, '_explain', {\n    method: 'POST',\n    body: JSON.stringify(requestDef)\n  }, callback);\n}\n\nfunction getIndexes(db, callback) {\n  dbFetch(db, '_index', {\n    method: 'GET'\n  }, callback);\n}\n\nfunction deleteIndex(db, indexDef, callback) {\n  var ddoc = indexDef.ddoc;\n  var type = indexDef.type || 'json';\n  var name = indexDef.name;\n\n  if (!ddoc) {\n    return callback(new Error('you must provide an index\\'s ddoc'));\n  }\n\n  if (!name) {\n    return callback(new Error('you must provide an index\\'s name'));\n  }\n\n  var url = '_index/' + [ddoc, type, name].map(encodeURIComponent).join('/');\n  dbFetch(db, url, {\n    method: 'DELETE'\n  }, callback);\n}\n\nfunction getArguments(fun) {\n  return function () {\n    var len = arguments.length;\n    var args = new Array(len);\n    var i = -1;\n\n    while (++i < len) {\n      args[i] = arguments[i];\n    }\n\n    return fun.call(this, args);\n  };\n}\n\nfunction callbackify(fun) {\n  return getArguments(function (args) {\n    var cb = args.pop();\n    var promise = fun.apply(this, args);\n    promisedCallback(promise, cb);\n    return promise;\n  });\n}\n\nfunction promisedCallback(promise, callback) {\n  promise.then(function (res) {\n    nextTick(function () {\n      callback(null, res);\n    });\n  }, function (reason) {\n    nextTick(function () {\n      callback(reason);\n    });\n  });\n  return promise;\n}\n\nvar flatten = getArguments(function (args) {\n  var res = [];\n\n  for (var i = 0, len = args.length; i < len; i++) {\n    var subArr = args[i];\n\n    if (Array.isArray(subArr)) {\n      res = res.concat(flatten.apply(null, subArr));\n    } else {\n      res.push(subArr);\n    }\n  }\n\n  return res;\n});\n\nfunction mergeObjects(arr) {\n  var res = {};\n\n  for (var i = 0, len = arr.length; i < len; i++) {\n    res = assign(res, arr[i]);\n  }\n\n  return res;\n} // Selects a list of fields defined in dot notation from one doc\n// and copies them to a new doc. Like underscore _.pick but supports nesting.\n\n\nfunction pick(obj, arr) {\n  var res = {};\n\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var parsedField = parseField(arr[i]);\n    var value = getFieldFromDoc(obj, parsedField);\n\n    if (typeof value !== 'undefined') {\n      setFieldInDoc(res, parsedField, value);\n    }\n  }\n\n  return res;\n} // e.g. ['a'], ['a', 'b'] is true, but ['b'], ['a', 'b'] is false\n\n\nfunction oneArrayIsSubArrayOfOther(left, right) {\n  for (var i = 0, len = Math.min(left.length, right.length); i < len; i++) {\n    if (left[i] !== right[i]) {\n      return false;\n    }\n  }\n\n  return true;\n} // e.g.['a', 'b', 'c'], ['a', 'b'] is false\n\n\nfunction oneArrayIsStrictSubArrayOfOther(left, right) {\n  if (left.length > right.length) {\n    return false;\n  }\n\n  return oneArrayIsSubArrayOfOther(left, right);\n} // same as above, but treat the left array as an unordered set\n// e.g. ['b', 'a'], ['a', 'b', 'c'] is true, but ['c'], ['a', 'b', 'c'] is false\n\n\nfunction oneSetIsSubArrayOfOther(left, right) {\n  left = left.slice();\n\n  for (var i = 0, len = right.length; i < len; i++) {\n    var field = right[i];\n\n    if (!left.length) {\n      break;\n    }\n\n    var leftIdx = left.indexOf(field);\n\n    if (leftIdx === -1) {\n      return false;\n    } else {\n      left.splice(leftIdx, 1);\n    }\n  }\n\n  return true;\n}\n\nfunction arrayToObject(arr) {\n  var res = {};\n\n  for (var i = 0, len = arr.length; i < len; i++) {\n    res[arr[i]] = true;\n  }\n\n  return res;\n}\n\nfunction max(arr, fun) {\n  var max = null;\n  var maxScore = -1;\n\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var element = arr[i];\n    var score = fun(element);\n\n    if (score > maxScore) {\n      maxScore = score;\n      max = element;\n    }\n  }\n\n  return max;\n}\n\nfunction arrayEquals(arr1, arr2) {\n  if (arr1.length !== arr2.length) {\n    return false;\n  }\n\n  for (var i = 0, len = arr1.length; i < len; i++) {\n    if (arr1[i] !== arr2[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction uniq(arr) {\n  var obj = {};\n\n  for (var i = 0; i < arr.length; i++) {\n    obj['$' + arr[i]] = true;\n  }\n\n  return Object.keys(obj).map(function (key) {\n    return key.substring(1);\n  });\n} //\n// One thing about these mappers:\n//\n// Per the advice of John-David Dalton (http://youtu.be/NthmeLEhDDM),\n// what you want to do in this case is optimize for the smallest possible\n// function, since that's the thing that gets run over and over again.\n//\n// This code would be a lot simpler if all the if/elses were inside\n// the function, but it would also be a lot less performant.\n//\n\n\nfunction createDeepMultiMapper(fields, emit) {\n  return function (doc) {\n    var toEmit = [];\n\n    for (var i = 0, iLen = fields.length; i < iLen; i++) {\n      var parsedField = parseField(fields[i]);\n      var value = doc;\n\n      for (var j = 0, jLen = parsedField.length; j < jLen; j++) {\n        var key = parsedField[j];\n        value = value[key];\n\n        if (typeof value === 'undefined') {\n          return; // don't emit\n        }\n      }\n\n      toEmit.push(value);\n    }\n\n    emit(toEmit);\n  };\n}\n\nfunction createDeepSingleMapper(field, emit) {\n  var parsedField = parseField(field);\n  return function (doc) {\n    var value = doc;\n\n    for (var i = 0, len = parsedField.length; i < len; i++) {\n      var key = parsedField[i];\n      value = value[key];\n\n      if (typeof value === 'undefined') {\n        return; // do nothing\n      }\n    }\n\n    emit(value);\n  };\n}\n\nfunction createShallowSingleMapper(field, emit) {\n  return function (doc) {\n    emit(doc[field]);\n  };\n}\n\nfunction createShallowMultiMapper(fields, emit) {\n  return function (doc) {\n    var toEmit = [];\n\n    for (var i = 0, len = fields.length; i < len; i++) {\n      toEmit.push(doc[fields[i]]);\n    }\n\n    emit(toEmit);\n  };\n}\n\nfunction checkShallow(fields) {\n  for (var i = 0, len = fields.length; i < len; i++) {\n    var field = fields[i];\n\n    if (field.indexOf('.') !== -1) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction createMapper(fields, emit) {\n  var isShallow = checkShallow(fields);\n  var isSingle = fields.length === 1; // notice we try to optimize for the most common case,\n  // i.e. single shallow indexes\n\n  if (isShallow) {\n    if (isSingle) {\n      return createShallowSingleMapper(fields[0], emit);\n    } else {\n      // multi\n      return createShallowMultiMapper(fields, emit);\n    }\n  } else {\n    // deep\n    if (isSingle) {\n      return createDeepSingleMapper(fields[0], emit);\n    } else {\n      // multi\n      return createDeepMultiMapper(fields, emit);\n    }\n  }\n}\n\nfunction mapper(mapFunDef, emit) {\n  // mapFunDef is a list of fields\n  var fields = Object.keys(mapFunDef.fields);\n  return createMapper(fields, emit);\n}\n/* istanbul ignore next */\n\n\nfunction reducer()\n/*reduceFunDef*/\n{\n  throw new Error('reduce not supported');\n}\n\nfunction ddocValidator(ddoc, viewName) {\n  var view = ddoc.views[viewName]; // This doesn't actually need to be here apparently, but\n  // I feel safer keeping it.\n\n  /* istanbul ignore if */\n\n  if (!view.map || !view.map.fields) {\n    throw new Error('ddoc ' + ddoc._id + ' with view ' + viewName + ' doesn\\'t have map.fields defined. ' + 'maybe it wasn\\'t created by this plugin?');\n  }\n}\n\nvar abstractMapper = abstractMapReduce(\n/* localDocName */\n'indexes', mapper, reducer, ddocValidator);\n\nfunction abstractMapper$1(db) {\n  return db._customFindAbstractMapper || abstractMapper;\n} // normalize the \"sort\" value\n\n\nfunction massageSort(sort) {\n  if (!Array.isArray(sort)) {\n    throw new Error('invalid sort json - should be an array');\n  }\n\n  return sort.map(function (sorting) {\n    if (typeof sorting === 'string') {\n      var obj = {};\n      obj[sorting] = 'asc';\n      return obj;\n    } else {\n      return sorting;\n    }\n  });\n}\n\nfunction massageUseIndex(useIndex) {\n  var cleanedUseIndex = [];\n\n  if (typeof useIndex === 'string') {\n    cleanedUseIndex.push(useIndex);\n  } else {\n    cleanedUseIndex = useIndex;\n  }\n\n  return cleanedUseIndex.map(function (name) {\n    return name.replace('_design/', '');\n  });\n}\n\nfunction massageIndexDef(indexDef) {\n  indexDef.fields = indexDef.fields.map(function (field) {\n    if (typeof field === 'string') {\n      var obj = {};\n      obj[field] = 'asc';\n      return obj;\n    }\n\n    return field;\n  });\n  return indexDef;\n}\n\nfunction getKeyFromDoc(doc, index) {\n  var res = [];\n\n  for (var i = 0; i < index.def.fields.length; i++) {\n    var field = getKey(index.def.fields[i]);\n    res.push(doc[field]);\n  }\n\n  return res;\n} // have to do this manually because REASONS. I don't know why\n// CouchDB didn't implement inclusive_start\n\n\nfunction filterInclusiveStart(rows, targetValue, index) {\n  var indexFields = index.def.fields;\n\n  for (var i = 0, len = rows.length; i < len; i++) {\n    var row = rows[i]; // shave off any docs at the beginning that are <= the\n    // target value\n\n    var docKey = getKeyFromDoc(row.doc, index);\n\n    if (indexFields.length === 1) {\n      docKey = docKey[0]; // only one field, not multi-field\n    } else {\n      // more than one field in index\n      // in the case where e.g. the user is searching {$gt: {a: 1}}\n      // but the index is [a, b], then we need to shorten the doc key\n      while (docKey.length > targetValue.length) {\n        docKey.pop();\n      }\n    } //ABS as we just looking for values that don't match\n\n\n    if (Math.abs(collate(docKey, targetValue)) > 0) {\n      // no need to filter any further; we're past the key\n      break;\n    }\n  }\n\n  return i > 0 ? rows.slice(i) : rows;\n}\n\nfunction reverseOptions(opts) {\n  var newOpts = clone(opts);\n  delete newOpts.startkey;\n  delete newOpts.endkey;\n  delete newOpts.inclusive_start;\n  delete newOpts.inclusive_end;\n\n  if ('endkey' in opts) {\n    newOpts.startkey = opts.endkey;\n  }\n\n  if ('startkey' in opts) {\n    newOpts.endkey = opts.startkey;\n  }\n\n  if ('inclusive_start' in opts) {\n    newOpts.inclusive_end = opts.inclusive_start;\n  }\n\n  if ('inclusive_end' in opts) {\n    newOpts.inclusive_start = opts.inclusive_end;\n  }\n\n  return newOpts;\n}\n\nfunction validateIndex(index) {\n  var ascFields = index.fields.filter(function (field) {\n    return getValue(field) === 'asc';\n  });\n\n  if (ascFields.length !== 0 && ascFields.length !== index.fields.length) {\n    throw new Error('unsupported mixed sorting');\n  }\n}\n\nfunction validateSort(requestDef, index) {\n  if (index.defaultUsed && requestDef.sort) {\n    var noneIdSorts = requestDef.sort.filter(function (sortItem) {\n      return Object.keys(sortItem)[0] !== '_id';\n    }).map(function (sortItem) {\n      return Object.keys(sortItem)[0];\n    });\n\n    if (noneIdSorts.length > 0) {\n      throw new Error('Cannot sort on field(s) \"' + noneIdSorts.join(',') + '\" when using the default index');\n    }\n  }\n\n  if (index.defaultUsed) {\n    return;\n  }\n}\n\nfunction validateFindRequest(requestDef) {\n  if (typeof requestDef.selector !== 'object') {\n    throw new Error('you must provide a selector when you find()');\n  }\n  /*var selectors = requestDef.selector['$and'] || [requestDef.selector];\n  for (var i = 0; i < selectors.length; i++) {\n    var selector = selectors[i];\n    var keys = Object.keys(selector);\n    if (keys.length === 0) {\n      throw new Error('invalid empty selector');\n    }\n    //var selection = selector[keys[0]];\n    /*if (Object.keys(selection).length !== 1) {\n      throw new Error('invalid selector: ' + JSON.stringify(selection) +\n        ' - it must have exactly one key/value');\n    }\n  }*/\n\n} // determine the maximum number of fields\n// we're going to need to query, e.g. if the user\n// has selection ['a'] and sorting ['a', 'b'], then we\n// need to use the longer of the two: ['a', 'b']\n\n\nfunction getUserFields(selector, sort) {\n  var selectorFields = Object.keys(selector);\n  var sortFields = sort ? sort.map(getKey) : [];\n  var userFields;\n\n  if (selectorFields.length >= sortFields.length) {\n    userFields = selectorFields;\n  } else {\n    userFields = sortFields;\n  }\n\n  if (sortFields.length === 0) {\n    return {\n      fields: userFields\n    };\n  } // sort according to the user's preferred sorting\n\n\n  userFields = userFields.sort(function (left, right) {\n    var leftIdx = sortFields.indexOf(left);\n\n    if (leftIdx === -1) {\n      leftIdx = Number.MAX_VALUE;\n    }\n\n    var rightIdx = sortFields.indexOf(right);\n\n    if (rightIdx === -1) {\n      rightIdx = Number.MAX_VALUE;\n    }\n\n    return leftIdx < rightIdx ? -1 : leftIdx > rightIdx ? 1 : 0;\n  });\n  return {\n    fields: userFields,\n    sortOrder: sort.map(getKey)\n  };\n}\n\nfunction createIndex$1(db, requestDef) {\n  requestDef = massageCreateIndexRequest(requestDef);\n  var originalIndexDef = clone(requestDef.index);\n  requestDef.index = massageIndexDef(requestDef.index);\n  validateIndex(requestDef.index); // calculating md5 is expensive - memoize and only\n  // run if required\n\n  var md5;\n\n  function getMd5() {\n    return md5 || (md5 = stringMd5(JSON.stringify(requestDef)));\n  }\n\n  var viewName = requestDef.name || 'idx-' + getMd5();\n  var ddocName = requestDef.ddoc || 'idx-' + getMd5();\n  var ddocId = '_design/' + ddocName;\n  var hasInvalidLanguage = false;\n  var viewExists = false;\n\n  function updateDdoc(doc) {\n    if (doc._rev && doc.language !== 'query') {\n      hasInvalidLanguage = true;\n    }\n\n    doc.language = 'query';\n    doc.views = doc.views || {};\n    viewExists = !!doc.views[viewName];\n\n    if (viewExists) {\n      return false;\n    }\n\n    doc.views[viewName] = {\n      map: {\n        fields: mergeObjects(requestDef.index.fields)\n      },\n      reduce: '_count',\n      options: {\n        def: originalIndexDef\n      }\n    };\n    return doc;\n  }\n\n  db.constructor.emit('debug', ['find', 'creating index', ddocId]);\n  return upsert(db, ddocId, updateDdoc).then(function () {\n    if (hasInvalidLanguage) {\n      throw new Error('invalid language for ddoc with id \"' + ddocId + '\" (should be \"query\")');\n    }\n  }).then(function () {\n    // kick off a build\n    // TODO: abstract-pouchdb-mapreduce should support auto-updating\n    // TODO: should also use update_after, but pouchdb/pouchdb#3415 blocks me\n    var signature = ddocName + '/' + viewName;\n    return abstractMapper$1(db).query.call(db, signature, {\n      limit: 0,\n      reduce: false\n    }).then(function () {\n      return {\n        id: ddocId,\n        name: viewName,\n        result: viewExists ? 'exists' : 'created'\n      };\n    });\n  });\n}\n\nfunction getIndexes$1(db) {\n  // just search through all the design docs and filter in-memory.\n  // hopefully there aren't that many ddocs.\n  return db.allDocs({\n    startkey: '_design/',\n    endkey: \"_design/\\uFFFF\",\n    include_docs: true\n  }).then(function (allDocsRes) {\n    var res = {\n      indexes: [{\n        ddoc: null,\n        name: '_all_docs',\n        type: 'special',\n        def: {\n          fields: [{\n            _id: 'asc'\n          }]\n        }\n      }]\n    };\n    res.indexes = flatten(res.indexes, allDocsRes.rows.filter(function (row) {\n      return row.doc.language === 'query';\n    }).map(function (row) {\n      var viewNames = row.doc.views !== undefined ? Object.keys(row.doc.views) : [];\n      return viewNames.map(function (viewName) {\n        var view = row.doc.views[viewName];\n        return {\n          ddoc: row.id,\n          name: viewName,\n          type: 'json',\n          def: massageIndexDef(view.options.def)\n        };\n      });\n    })); // these are sorted by view name for some reason\n\n    res.indexes.sort(function (left, right) {\n      return compare(left.name, right.name);\n    });\n    res.total_rows = res.indexes.length;\n    return res;\n  });\n} // couchdb lowest collation value\n\n\nvar COLLATE_LO = null; // couchdb highest collation value (TODO: well not really, but close enough amirite)\n\nvar COLLATE_HI = {\n  \"\\uFFFF\": {}\n};\nvar SHORT_CIRCUIT_QUERY = {\n  queryOpts: {\n    limit: 0,\n    startkey: COLLATE_HI,\n    endkey: COLLATE_LO\n  },\n  inMemoryFields: []\n}; // couchdb second-lowest collation value\n\nfunction checkFieldInIndex(index, field) {\n  var indexFields = index.def.fields.map(getKey);\n\n  for (var i = 0, len = indexFields.length; i < len; i++) {\n    var indexField = indexFields[i];\n\n    if (field === indexField) {\n      return true;\n    }\n  }\n\n  return false;\n} // so when you do e.g. $eq/$eq, we can do it entirely in the database.\n// but when you do e.g. $gt/$eq, the first part can be done\n// in the database, but the second part has to be done in-memory,\n// because $gt has forced us to lose precision.\n// so that's what this determines\n\n\nfunction userOperatorLosesPrecision(selector, field) {\n  var matcher = selector[field];\n  var userOperator = getKey(matcher);\n  return userOperator !== '$eq';\n} // sort the user fields by their position in the index,\n// if they're in the index\n\n\nfunction sortFieldsByIndex(userFields, index) {\n  var indexFields = index.def.fields.map(getKey);\n  return userFields.slice().sort(function (a, b) {\n    var aIdx = indexFields.indexOf(a);\n    var bIdx = indexFields.indexOf(b);\n\n    if (aIdx === -1) {\n      aIdx = Number.MAX_VALUE;\n    }\n\n    if (bIdx === -1) {\n      bIdx = Number.MAX_VALUE;\n    }\n\n    return compare(aIdx, bIdx);\n  });\n} // first pass to try to find fields that will need to be sorted in-memory\n\n\nfunction getBasicInMemoryFields(index, selector, userFields) {\n  userFields = sortFieldsByIndex(userFields, index); // check if any of the user selectors lose precision\n\n  var needToFilterInMemory = false;\n\n  for (var i = 0, len = userFields.length; i < len; i++) {\n    var field = userFields[i];\n\n    if (needToFilterInMemory || !checkFieldInIndex(index, field)) {\n      return userFields.slice(i);\n    }\n\n    if (i < len - 1 && userOperatorLosesPrecision(selector, field)) {\n      needToFilterInMemory = true;\n    }\n  }\n\n  return [];\n}\n\nfunction getInMemoryFieldsFromNe(selector) {\n  var fields = [];\n  Object.keys(selector).forEach(function (field) {\n    var matcher = selector[field];\n    Object.keys(matcher).forEach(function (operator) {\n      if (operator === '$ne') {\n        fields.push(field);\n      }\n    });\n  });\n  return fields;\n}\n\nfunction getInMemoryFields(coreInMemoryFields, index, selector, userFields) {\n  var result = flatten( // in-memory fields reported as necessary by the query planner\n  coreInMemoryFields, // combine with another pass that checks for any we may have missed\n  getBasicInMemoryFields(index, selector, userFields), // combine with another pass that checks for $ne's\n  getInMemoryFieldsFromNe(selector));\n  return sortFieldsByIndex(uniq(result), index);\n} // check that at least one field in the user's query is represented\n// in the index. order matters in the case of sorts\n\n\nfunction checkIndexFieldsMatch(indexFields, sortOrder, fields) {\n  if (sortOrder) {\n    // array has to be a strict subarray of index array. furthermore,\n    // the sortOrder fields need to all be represented in the index\n    var sortMatches = oneArrayIsStrictSubArrayOfOther(sortOrder, indexFields);\n    var selectorMatches = oneArrayIsSubArrayOfOther(fields, indexFields);\n    return sortMatches && selectorMatches;\n  } // all of the user's specified fields still need to be\n  // on the left side of the index array, although the order\n  // doesn't matter\n\n\n  return oneSetIsSubArrayOfOther(fields, indexFields);\n}\n\nvar logicalMatchers = ['$eq', '$gt', '$gte', '$lt', '$lte'];\n\nfunction isNonLogicalMatcher(matcher) {\n  return logicalMatchers.indexOf(matcher) === -1;\n} // check all the index fields for usages of '$ne'\n// e.g. if the user queries {foo: {$ne: 'foo'}, bar: {$eq: 'bar'}},\n// then we can neither use an index on ['foo'] nor an index on\n// ['foo', 'bar'], but we can use an index on ['bar'] or ['bar', 'foo']\n\n\nfunction checkFieldsLogicallySound(indexFields, selector) {\n  var firstField = indexFields[0];\n  var matcher = selector[firstField];\n\n  if (typeof matcher === 'undefined') {\n    /* istanbul ignore next */\n    return true;\n  }\n\n  var isInvalidNe = Object.keys(matcher).length === 1 && getKey(matcher) === '$ne';\n  return !isInvalidNe;\n}\n\nfunction checkIndexMatches(index, sortOrder, fields, selector) {\n  var indexFields = index.def.fields.map(getKey);\n  var fieldsMatch = checkIndexFieldsMatch(indexFields, sortOrder, fields);\n\n  if (!fieldsMatch) {\n    return false;\n  }\n\n  return checkFieldsLogicallySound(indexFields, selector);\n} //\n// the algorithm is very simple:\n// take all the fields the user supplies, and if those fields\n// are a strict subset of the fields in some index,\n// then use that index\n//\n//\n\n\nfunction findMatchingIndexes(selector, userFields, sortOrder, indexes) {\n  return indexes.filter(function (index) {\n    return checkIndexMatches(index, sortOrder, userFields, selector);\n  });\n} // find the best index, i.e. the one that matches the most fields\n// in the user's query\n\n\nfunction findBestMatchingIndex(selector, userFields, sortOrder, indexes, useIndex) {\n  var matchingIndexes = findMatchingIndexes(selector, userFields, sortOrder, indexes);\n\n  if (matchingIndexes.length === 0) {\n    if (useIndex) {\n      throw {\n        error: \"no_usable_index\",\n        message: \"There is no index available for this selector.\"\n      };\n    } //return `all_docs` as a default index;\n    //I'm assuming that _all_docs is always first\n\n\n    var defaultIndex = indexes[0];\n    defaultIndex.defaultUsed = true;\n    return defaultIndex;\n  }\n\n  if (matchingIndexes.length === 1 && !useIndex) {\n    return matchingIndexes[0];\n  }\n\n  var userFieldsMap = arrayToObject(userFields);\n\n  function scoreIndex(index) {\n    var indexFields = index.def.fields.map(getKey);\n    var score = 0;\n\n    for (var i = 0, len = indexFields.length; i < len; i++) {\n      var indexField = indexFields[i];\n\n      if (userFieldsMap[indexField]) {\n        score++;\n      }\n    }\n\n    return score;\n  }\n\n  if (useIndex) {\n    var useIndexDdoc = '_design/' + useIndex[0];\n    var useIndexName = useIndex.length === 2 ? useIndex[1] : false;\n    var index = matchingIndexes.find(function (index) {\n      if (useIndexName && index.ddoc === useIndexDdoc && useIndexName === index.name) {\n        return true;\n      }\n\n      if (index.ddoc === useIndexDdoc) {\n        /* istanbul ignore next */\n        return true;\n      }\n\n      return false;\n    });\n\n    if (!index) {\n      throw {\n        error: \"unknown_error\",\n        message: \"Could not find that index or could not use that index for the query\"\n      };\n    }\n\n    return index;\n  }\n\n  return max(matchingIndexes, scoreIndex);\n}\n\nfunction getSingleFieldQueryOptsFor(userOperator, userValue) {\n  switch (userOperator) {\n    case '$eq':\n      return {\n        key: userValue\n      };\n\n    case '$lte':\n      return {\n        endkey: userValue\n      };\n\n    case '$gte':\n      return {\n        startkey: userValue\n      };\n\n    case '$lt':\n      return {\n        endkey: userValue,\n        inclusive_end: false\n      };\n\n    case '$gt':\n      return {\n        startkey: userValue,\n        inclusive_start: false\n      };\n  }\n\n  return {\n    startkey: COLLATE_LO\n  };\n}\n\nfunction getSingleFieldCoreQueryPlan(selector, index) {\n  var field = getKey(index.def.fields[0]); //ignoring this because the test to exercise the branch is skipped at the moment\n\n  /* istanbul ignore next */\n\n  var matcher = selector[field] || {};\n  var inMemoryFields = [];\n  var userOperators = Object.keys(matcher);\n  var combinedOpts;\n  userOperators.forEach(function (userOperator) {\n    if (isNonLogicalMatcher(userOperator)) {\n      inMemoryFields.push(field);\n    }\n\n    var userValue = matcher[userOperator];\n    var newQueryOpts = getSingleFieldQueryOptsFor(userOperator, userValue);\n\n    if (combinedOpts) {\n      combinedOpts = mergeObjects([combinedOpts, newQueryOpts]);\n    } else {\n      combinedOpts = newQueryOpts;\n    }\n  });\n  return {\n    queryOpts: combinedOpts,\n    inMemoryFields: inMemoryFields\n  };\n}\n\nfunction getMultiFieldCoreQueryPlan(userOperator, userValue) {\n  switch (userOperator) {\n    case '$eq':\n      return {\n        startkey: userValue,\n        endkey: userValue\n      };\n\n    case '$lte':\n      return {\n        endkey: userValue\n      };\n\n    case '$gte':\n      return {\n        startkey: userValue\n      };\n\n    case '$lt':\n      return {\n        endkey: userValue,\n        inclusive_end: false\n      };\n\n    case '$gt':\n      return {\n        startkey: userValue,\n        inclusive_start: false\n      };\n  }\n}\n\nfunction getMultiFieldQueryOpts(selector, index) {\n  var indexFields = index.def.fields.map(getKey);\n  var inMemoryFields = [];\n  var startkey = [];\n  var endkey = [];\n  var inclusiveStart;\n  var inclusiveEnd;\n\n  function finish(i) {\n    if (inclusiveStart !== false) {\n      startkey.push(COLLATE_LO);\n    }\n\n    if (inclusiveEnd !== false) {\n      endkey.push(COLLATE_HI);\n    } // keep track of the fields where we lost specificity,\n    // and therefore need to filter in-memory\n\n\n    inMemoryFields = indexFields.slice(i);\n  }\n\n  for (var i = 0, len = indexFields.length; i < len; i++) {\n    var indexField = indexFields[i];\n    var matcher = selector[indexField];\n\n    if (!matcher || !Object.keys(matcher).length) {\n      // fewer fields in user query than in index\n      finish(i);\n      break;\n    } else if (Object.keys(matcher).some(isNonLogicalMatcher)) {\n      // non-logical are ignored\n      finish(i);\n      break;\n    } else if (i > 0) {\n      var usingGtlt = '$gt' in matcher || '$gte' in matcher || '$lt' in matcher || '$lte' in matcher;\n      var previousKeys = Object.keys(selector[indexFields[i - 1]]);\n      var previousWasEq = arrayEquals(previousKeys, ['$eq']);\n      var previousWasSame = arrayEquals(previousKeys, Object.keys(matcher));\n      var gtltLostSpecificity = usingGtlt && !previousWasEq && !previousWasSame;\n\n      if (gtltLostSpecificity) {\n        finish(i);\n        break;\n      }\n    }\n\n    var userOperators = Object.keys(matcher);\n    var combinedOpts = null;\n\n    for (var j = 0; j < userOperators.length; j++) {\n      var userOperator = userOperators[j];\n      var userValue = matcher[userOperator];\n      var newOpts = getMultiFieldCoreQueryPlan(userOperator, userValue);\n\n      if (combinedOpts) {\n        combinedOpts = mergeObjects([combinedOpts, newOpts]);\n      } else {\n        combinedOpts = newOpts;\n      }\n    }\n\n    startkey.push('startkey' in combinedOpts ? combinedOpts.startkey : COLLATE_LO);\n    endkey.push('endkey' in combinedOpts ? combinedOpts.endkey : COLLATE_HI);\n\n    if ('inclusive_start' in combinedOpts) {\n      inclusiveStart = combinedOpts.inclusive_start;\n    }\n\n    if ('inclusive_end' in combinedOpts) {\n      inclusiveEnd = combinedOpts.inclusive_end;\n    }\n  }\n\n  var res = {\n    startkey: startkey,\n    endkey: endkey\n  };\n\n  if (typeof inclusiveStart !== 'undefined') {\n    res.inclusive_start = inclusiveStart;\n  }\n\n  if (typeof inclusiveEnd !== 'undefined') {\n    res.inclusive_end = inclusiveEnd;\n  }\n\n  return {\n    queryOpts: res,\n    inMemoryFields: inMemoryFields\n  };\n}\n\nfunction shouldShortCircuit(selector) {\n  // We have a field to select from, but not a valid value\n  // this should result in a short circuited query \n  // just like the http adapter (couchdb) and mongodb\n  // see tests for issue #7810\n  // @todo Use 'Object.values' when Node.js v6 support is dropped.\n  var values = Object.keys(selector).map(function (key) {\n    return selector[key];\n  });\n  return values.some(function (val) {\n    return typeof val === 'object' && Object.keys(val).length === 0;\n  });\n}\n\nfunction getDefaultQueryPlan(selector) {\n  //using default index, so all fields need to be done in memory\n  return {\n    queryOpts: {\n      startkey: null\n    },\n    inMemoryFields: [Object.keys(selector)]\n  };\n}\n\nfunction getCoreQueryPlan(selector, index) {\n  if (index.defaultUsed) {\n    return getDefaultQueryPlan(selector, index);\n  }\n\n  if (index.def.fields.length === 1) {\n    // one field in index, so the value was indexed as a singleton\n    return getSingleFieldCoreQueryPlan(selector, index);\n  } // else index has multiple fields, so the value was indexed as an array\n\n\n  return getMultiFieldQueryOpts(selector, index);\n}\n\nfunction planQuery(request, indexes) {\n  var selector = request.selector;\n  var sort = request.sort;\n\n  if (shouldShortCircuit(selector)) {\n    return assign({}, SHORT_CIRCUIT_QUERY, {\n      index: indexes[0]\n    });\n  }\n\n  var userFieldsRes = getUserFields(selector, sort);\n  var userFields = userFieldsRes.fields;\n  var sortOrder = userFieldsRes.sortOrder;\n  var index = findBestMatchingIndex(selector, userFields, sortOrder, indexes, request.use_index);\n  var coreQueryPlan = getCoreQueryPlan(selector, index);\n  var queryOpts = coreQueryPlan.queryOpts;\n  var coreInMemoryFields = coreQueryPlan.inMemoryFields;\n  var inMemoryFields = getInMemoryFields(coreInMemoryFields, index, selector, userFields);\n  var res = {\n    queryOpts: queryOpts,\n    index: index,\n    inMemoryFields: inMemoryFields\n  };\n  return res;\n}\n\nfunction indexToSignature(index) {\n  // remove '_design/'\n  return index.ddoc.substring(8) + '/' + index.name;\n}\n\nfunction doAllDocs(db, originalOpts) {\n  var opts = clone(originalOpts); // CouchDB responds in weird ways when you provide a non-string to _id;\n  // we mimic the behavior for consistency. See issue66 tests for details.\n\n  if (opts.descending) {\n    if ('endkey' in opts && typeof opts.endkey !== 'string') {\n      opts.endkey = '';\n    }\n\n    if ('startkey' in opts && typeof opts.startkey !== 'string') {\n      opts.limit = 0;\n    }\n  } else {\n    if ('startkey' in opts && typeof opts.startkey !== 'string') {\n      opts.startkey = '';\n    }\n\n    if ('endkey' in opts && typeof opts.endkey !== 'string') {\n      opts.limit = 0;\n    }\n  }\n\n  if ('key' in opts && typeof opts.key !== 'string') {\n    opts.limit = 0;\n  }\n\n  if (opts.limit > 0 && opts.indexes_count) {\n    // brute force and quite naive impl.\n    // amp up the limit with the amount of (indexes) design docs\n    // or is this too naive? How about skip?\n    opts.original_limit = opts.limit;\n    opts.limit += opts.indexes_count;\n  }\n\n  return db.allDocs(opts).then(function (res) {\n    // filter out any design docs that _all_docs might return\n    res.rows = res.rows.filter(function (row) {\n      return !/^_design\\//.test(row.id);\n    }); // put back original limit\n\n    if (opts.original_limit) {\n      opts.limit = opts.original_limit;\n    } // enforce the rows to respect the given limit\n\n\n    res.rows = res.rows.slice(0, opts.limit);\n    return res;\n  });\n}\n\nfunction find$1(db, requestDef, explain) {\n  if (requestDef.selector) {\n    requestDef.selector = massageSelector(requestDef.selector);\n  }\n\n  if (requestDef.sort) {\n    requestDef.sort = massageSort(requestDef.sort);\n  }\n\n  if (requestDef.use_index) {\n    requestDef.use_index = massageUseIndex(requestDef.use_index);\n  }\n\n  validateFindRequest(requestDef);\n  return getIndexes$1(db).then(function (getIndexesRes) {\n    db.constructor.emit('debug', ['find', 'planning query', requestDef]);\n    var queryPlan = planQuery(requestDef, getIndexesRes.indexes);\n    db.constructor.emit('debug', ['find', 'query plan', queryPlan]);\n    var indexToUse = queryPlan.index;\n    validateSort(requestDef, indexToUse);\n    var opts = assign({\n      include_docs: true,\n      reduce: false,\n      // Add amount of index for doAllDocs to use (related to issue #7810)\n      indexes_count: getIndexesRes.total_rows\n    }, queryPlan.queryOpts);\n\n    if ('startkey' in opts && 'endkey' in opts && collate(opts.startkey, opts.endkey) > 0) {\n      // can't possibly return any results, startkey > endkey\n\n      /* istanbul ignore next */\n      return {\n        docs: []\n      };\n    }\n\n    var isDescending = requestDef.sort && typeof requestDef.sort[0] !== 'string' && getValue(requestDef.sort[0]) === 'desc';\n\n    if (isDescending) {\n      // either all descending or all ascending\n      opts.descending = true;\n      opts = reverseOptions(opts);\n    }\n\n    if (!queryPlan.inMemoryFields.length) {\n      // no in-memory filtering necessary, so we can let the\n      // database do the limit/skip for us\n      if ('limit' in requestDef) {\n        opts.limit = requestDef.limit;\n      }\n\n      if ('skip' in requestDef) {\n        opts.skip = requestDef.skip;\n      }\n    }\n\n    if (explain) {\n      return Promise.resolve(queryPlan, opts);\n    }\n\n    return Promise.resolve().then(function () {\n      if (indexToUse.name === '_all_docs') {\n        return doAllDocs(db, opts);\n      } else {\n        var signature = indexToSignature(indexToUse);\n        return abstractMapper$1(db).query.call(db, signature, opts);\n      }\n    }).then(function (res) {\n      if (opts.inclusive_start === false) {\n        // may have to manually filter the first one,\n        // since couchdb has no true inclusive_start option\n        res.rows = filterInclusiveStart(res.rows, opts.startkey, indexToUse);\n      }\n\n      if (queryPlan.inMemoryFields.length) {\n        // need to filter some stuff in-memory\n        res.rows = filterInMemoryFields(res.rows, requestDef, queryPlan.inMemoryFields);\n      }\n\n      var resp = {\n        docs: res.rows.map(function (row) {\n          var doc = row.doc;\n\n          if (requestDef.fields) {\n            return pick(doc, requestDef.fields);\n          }\n\n          return doc;\n        })\n      };\n\n      if (indexToUse.defaultUsed) {\n        resp.warning = 'No matching index found, create an index to optimize query time.';\n      }\n\n      return resp;\n    });\n  });\n}\n\nfunction explain$1(db, requestDef) {\n  return find$1(db, requestDef, true).then(function (queryPlan) {\n    return {\n      dbname: db.name,\n      index: queryPlan.index,\n      selector: requestDef.selector,\n      range: {\n        start_key: queryPlan.queryOpts.startkey,\n        end_key: queryPlan.queryOpts.endkey\n      },\n      opts: {\n        use_index: requestDef.use_index || [],\n        bookmark: \"nil\",\n        //hardcoded to match CouchDB since its not supported,\n        limit: requestDef.limit,\n        skip: requestDef.skip,\n        sort: requestDef.sort || {},\n        fields: requestDef.fields,\n        conflicts: false,\n        //hardcoded to match CouchDB since its not supported,\n        r: [49] // hardcoded to match CouchDB since its not support\n\n      },\n      limit: requestDef.limit,\n      skip: requestDef.skip || 0,\n      fields: requestDef.fields\n    };\n  });\n}\n\nfunction deleteIndex$1(db, index) {\n  if (!index.ddoc) {\n    throw new Error('you must supply an index.ddoc when deleting');\n  }\n\n  if (!index.name) {\n    throw new Error('you must supply an index.name when deleting');\n  }\n\n  var docId = index.ddoc;\n  var viewName = index.name;\n\n  function deltaFun(doc) {\n    if (Object.keys(doc.views).length === 1 && doc.views[viewName]) {\n      // only one view in this ddoc, delete the whole ddoc\n      return {\n        _id: docId,\n        _deleted: true\n      };\n    } // more than one view here, just remove the view\n\n\n    delete doc.views[viewName];\n    return doc;\n  }\n\n  return upsert(db, docId, deltaFun).then(function () {\n    return abstractMapper$1(db).viewCleanup.apply(db);\n  }).then(function () {\n    return {\n      ok: true\n    };\n  });\n}\n\nvar createIndexAsCallback = callbackify(createIndex$1);\nvar findAsCallback = callbackify(find$1);\nvar explainAsCallback = callbackify(explain$1);\nvar getIndexesAsCallback = callbackify(getIndexes$1);\nvar deleteIndexAsCallback = callbackify(deleteIndex$1);\nvar plugin = {};\nplugin.createIndex = toPromise(function (requestDef, callback) {\n  if (typeof requestDef !== 'object') {\n    return callback(new Error('you must provide an index to create'));\n  }\n\n  var createIndex$$1 = isRemote(this) ? createIndex : createIndexAsCallback;\n  createIndex$$1(this, requestDef, callback);\n});\nplugin.find = toPromise(function (requestDef, callback) {\n  if (typeof callback === 'undefined') {\n    callback = requestDef;\n    requestDef = undefined;\n  }\n\n  if (typeof requestDef !== 'object') {\n    return callback(new Error('you must provide search parameters to find()'));\n  }\n\n  var find$$1 = isRemote(this) ? find : findAsCallback;\n  find$$1(this, requestDef, callback);\n});\nplugin.explain = toPromise(function (requestDef, callback) {\n  if (typeof callback === 'undefined') {\n    callback = requestDef;\n    requestDef = undefined;\n  }\n\n  if (typeof requestDef !== 'object') {\n    return callback(new Error('you must provide search parameters to explain()'));\n  }\n\n  var find$$1 = isRemote(this) ? explain : explainAsCallback;\n  find$$1(this, requestDef, callback);\n});\nplugin.getIndexes = toPromise(function (callback) {\n  var getIndexes$$1 = isRemote(this) ? getIndexes : getIndexesAsCallback;\n  getIndexes$$1(this, callback);\n});\nplugin.deleteIndex = toPromise(function (indexDef, callback) {\n  if (typeof indexDef !== 'object') {\n    return callback(new Error('you must provide an index to delete'));\n  }\n\n  var deleteIndex$$1 = isRemote(this) ? deleteIndex : deleteIndexAsCallback;\n  deleteIndex$$1(this, indexDef, callback);\n});\nexport default plugin;","map":{"version":3,"sources":["/Users/Hanzalah/Desktop/github/todo-offline/rxdb-hasura-demo/node_modules/pouchdb-find/lib/index-browser.es.js"],"names":["generateErrorFromResponse","Headers","abstractMapReduce","stringMd5","collate","getFieldFromDoc","setFieldInDoc","parseField","getKey","getValue","compare","massageSelector","filterInMemoryFields","clone","assign","nextTick","upsert","toPromise","isRemote","massageCreateIndexRequest","requestDef","index","forEach","key","fields","type","dbFetch","db","path","opts","callback","status","ok","headers","fetch","then","response","json","err","catch","createIndex","method","body","JSON","stringify","find","explain","getIndexes","deleteIndex","indexDef","ddoc","name","Error","url","map","encodeURIComponent","join","getArguments","fun","len","arguments","length","args","Array","i","call","callbackify","cb","pop","promise","apply","promisedCallback","res","reason","flatten","subArr","isArray","concat","push","mergeObjects","arr","pick","obj","parsedField","value","oneArrayIsSubArrayOfOther","left","right","Math","min","oneArrayIsStrictSubArrayOfOther","oneSetIsSubArrayOfOther","slice","field","leftIdx","indexOf","splice","arrayToObject","max","maxScore","element","score","arrayEquals","arr1","arr2","uniq","Object","keys","substring","createDeepMultiMapper","emit","doc","toEmit","iLen","j","jLen","createDeepSingleMapper","createShallowSingleMapper","createShallowMultiMapper","checkShallow","createMapper","isShallow","isSingle","mapper","mapFunDef","reducer","ddocValidator","viewName","view","views","_id","abstractMapper","abstractMapper$1","_customFindAbstractMapper","massageSort","sort","sorting","massageUseIndex","useIndex","cleanedUseIndex","replace","massageIndexDef","getKeyFromDoc","def","filterInclusiveStart","rows","targetValue","indexFields","row","docKey","abs","reverseOptions","newOpts","startkey","endkey","inclusive_start","inclusive_end","validateIndex","ascFields","filter","validateSort","defaultUsed","noneIdSorts","sortItem","validateFindRequest","selector","getUserFields","selectorFields","sortFields","userFields","Number","MAX_VALUE","rightIdx","sortOrder","createIndex$1","originalIndexDef","md5","getMd5","ddocName","ddocId","hasInvalidLanguage","viewExists","updateDdoc","_rev","language","reduce","options","constructor","signature","query","limit","id","result","getIndexes$1","allDocs","include_docs","allDocsRes","indexes","viewNames","undefined","total_rows","COLLATE_LO","COLLATE_HI","SHORT_CIRCUIT_QUERY","queryOpts","inMemoryFields","checkFieldInIndex","indexField","userOperatorLosesPrecision","matcher","userOperator","sortFieldsByIndex","a","b","aIdx","bIdx","getBasicInMemoryFields","needToFilterInMemory","getInMemoryFieldsFromNe","operator","getInMemoryFields","coreInMemoryFields","checkIndexFieldsMatch","sortMatches","selectorMatches","logicalMatchers","isNonLogicalMatcher","checkFieldsLogicallySound","firstField","isInvalidNe","checkIndexMatches","fieldsMatch","findMatchingIndexes","findBestMatchingIndex","matchingIndexes","error","message","defaultIndex","userFieldsMap","scoreIndex","useIndexDdoc","useIndexName","getSingleFieldQueryOptsFor","userValue","getSingleFieldCoreQueryPlan","userOperators","combinedOpts","newQueryOpts","getMultiFieldCoreQueryPlan","getMultiFieldQueryOpts","inclusiveStart","inclusiveEnd","finish","some","usingGtlt","previousKeys","previousWasEq","previousWasSame","gtltLostSpecificity","shouldShortCircuit","values","val","getDefaultQueryPlan","getCoreQueryPlan","planQuery","request","userFieldsRes","use_index","coreQueryPlan","indexToSignature","doAllDocs","originalOpts","descending","indexes_count","original_limit","test","find$1","getIndexesRes","queryPlan","indexToUse","docs","isDescending","skip","Promise","resolve","resp","warning","explain$1","dbname","range","start_key","end_key","bookmark","conflicts","r","deleteIndex$1","docId","deltaFun","_deleted","viewCleanup","createIndexAsCallback","findAsCallback","explainAsCallback","getIndexesAsCallback","deleteIndexAsCallback","plugin","createIndex$$1","find$$1","getIndexes$$1","deleteIndex$$1"],"mappings":"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","sourcesContent":["import { generateErrorFromResponse } from 'pouchdb-errors';\nimport { Headers } from 'pouchdb-fetch';\nimport abstractMapReduce from 'pouchdb-abstract-mapreduce';\nimport { stringMd5 } from 'pouchdb-md5';\nimport { collate } from 'pouchdb-collate';\nimport { getFieldFromDoc, setFieldInDoc, parseField, getKey, getValue, compare, massageSelector, filterInMemoryFields } from 'pouchdb-selector-core';\nimport { clone, assign, nextTick, upsert, toPromise, isRemote } from 'pouchdb-utils';\n\n// we restucture the supplied JSON considerably, because the official\n// Mango API is very particular about a lot of this stuff, but we like\n// to be liberal with what we accept in order to prevent mental\n// breakdowns in our users\nfunction massageCreateIndexRequest(requestDef) {\n  requestDef = clone(requestDef);\n\n  if (!requestDef.index) {\n    requestDef.index = {};\n  }\n\n  ['type', 'name', 'ddoc'].forEach(function (key) {\n    if (requestDef.index[key]) {\n      requestDef[key] = requestDef.index[key];\n      delete requestDef.index[key];\n    }\n  });\n\n  if (requestDef.fields) {\n    requestDef.index.fields = requestDef.fields;\n    delete requestDef.fields;\n  }\n\n  if (!requestDef.type) {\n    requestDef.type = 'json';\n  }\n  return requestDef;\n}\n\nfunction dbFetch(db, path, opts, callback) {\n  var status, ok;\n  opts.headers = new Headers({'Content-type': 'application/json'});\n  db.fetch(path, opts).then(function (response) {\n    status = response.status;\n    ok = response.ok;\n    return response.json();\n  }).then(function (json) {\n    if (!ok) {\n      json.status = status;\n      var err = generateErrorFromResponse(json);\n      callback(err);\n    } else {\n      callback(null, json);\n    }\n  }).catch(callback);\n}\n\nfunction createIndex(db, requestDef, callback) {\n  requestDef = massageCreateIndexRequest(requestDef);\n  dbFetch(db, '_index', {\n    method: 'POST',\n    body: JSON.stringify(requestDef)\n  }, callback);\n}\n\nfunction find(db, requestDef, callback) {\n  dbFetch(db, '_find', {\n    method: 'POST',\n    body: JSON.stringify(requestDef)\n  }, callback);\n}\n\nfunction explain(db, requestDef, callback) {\n  dbFetch(db, '_explain', {\n    method: 'POST',\n    body: JSON.stringify(requestDef)\n  }, callback);\n}\n\nfunction getIndexes(db, callback) {\n  dbFetch(db, '_index', {\n    method: 'GET'\n  }, callback);\n}\n\nfunction deleteIndex(db, indexDef, callback) {\n\n\n  var ddoc = indexDef.ddoc;\n  var type = indexDef.type || 'json';\n  var name = indexDef.name;\n\n  if (!ddoc) {\n    return callback(new Error('you must provide an index\\'s ddoc'));\n  }\n\n  if (!name) {\n    return callback(new Error('you must provide an index\\'s name'));\n  }\n\n  var url = '_index/' + [ddoc, type, name].map(encodeURIComponent).join('/');\n\n  dbFetch(db, url, {method: 'DELETE'}, callback);\n}\n\nfunction getArguments(fun) {\n  return function () {\n    var len = arguments.length;\n    var args = new Array(len);\n    var i = -1;\n    while (++i < len) {\n      args[i] = arguments[i];\n    }\n    return fun.call(this, args);\n  };\n}\n\nfunction callbackify(fun) {\n  return getArguments(function (args) {\n    var cb = args.pop();\n    var promise = fun.apply(this, args);\n    promisedCallback(promise, cb);\n    return promise;\n  });\n}\n\nfunction promisedCallback(promise, callback) {\n  promise.then(function (res) {\n    nextTick(function () {\n      callback(null, res);\n    });\n  }, function (reason) {\n    nextTick(function () {\n      callback(reason);\n    });\n  });\n  return promise;\n}\n\nvar flatten = getArguments(function (args) {\n  var res = [];\n  for (var i = 0, len = args.length; i < len; i++) {\n    var subArr = args[i];\n    if (Array.isArray(subArr)) {\n      res = res.concat(flatten.apply(null, subArr));\n    } else {\n      res.push(subArr);\n    }\n  }\n  return res;\n});\n\nfunction mergeObjects(arr) {\n  var res = {};\n  for (var i = 0, len = arr.length; i < len; i++) {\n    res = assign(res, arr[i]);\n  }\n  return res;\n}\n\n// Selects a list of fields defined in dot notation from one doc\n// and copies them to a new doc. Like underscore _.pick but supports nesting.\nfunction pick(obj, arr) {\n  var res = {};\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var parsedField = parseField(arr[i]);\n    var value = getFieldFromDoc(obj, parsedField);\n    if (typeof value !== 'undefined') {\n      setFieldInDoc(res, parsedField, value);\n    }\n  }\n  return res;\n}\n\n// e.g. ['a'], ['a', 'b'] is true, but ['b'], ['a', 'b'] is false\nfunction oneArrayIsSubArrayOfOther(left, right) {\n\n  for (var i = 0, len = Math.min(left.length, right.length); i < len; i++) {\n    if (left[i] !== right[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// e.g.['a', 'b', 'c'], ['a', 'b'] is false\nfunction oneArrayIsStrictSubArrayOfOther(left, right) {\n\n  if (left.length > right.length) {\n    return false;\n  }\n\n  return oneArrayIsSubArrayOfOther(left, right);\n}\n\n// same as above, but treat the left array as an unordered set\n// e.g. ['b', 'a'], ['a', 'b', 'c'] is true, but ['c'], ['a', 'b', 'c'] is false\nfunction oneSetIsSubArrayOfOther(left, right) {\n  left = left.slice();\n  for (var i = 0, len = right.length; i < len; i++) {\n    var field = right[i];\n    if (!left.length) {\n      break;\n    }\n    var leftIdx = left.indexOf(field);\n    if (leftIdx === -1) {\n      return false;\n    } else {\n      left.splice(leftIdx, 1);\n    }\n  }\n  return true;\n}\n\nfunction arrayToObject(arr) {\n  var res = {};\n  for (var i = 0, len = arr.length; i < len; i++) {\n    res[arr[i]] = true;\n  }\n  return res;\n}\n\nfunction max(arr, fun) {\n  var max = null;\n  var maxScore = -1;\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var element = arr[i];\n    var score = fun(element);\n    if (score > maxScore) {\n      maxScore = score;\n      max = element;\n    }\n  }\n  return max;\n}\n\nfunction arrayEquals(arr1, arr2) {\n  if (arr1.length !== arr2.length) {\n    return false;\n  }\n  for (var i = 0, len = arr1.length; i < len; i++) {\n    if (arr1[i] !== arr2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction uniq(arr) {\n  var obj = {};\n  for (var i = 0; i < arr.length; i++) {\n    obj['$' + arr[i]] = true;\n  }\n  return Object.keys(obj).map(function (key) {\n    return key.substring(1);\n  });\n}\n\n//\n// One thing about these mappers:\n//\n// Per the advice of John-David Dalton (http://youtu.be/NthmeLEhDDM),\n// what you want to do in this case is optimize for the smallest possible\n// function, since that's the thing that gets run over and over again.\n//\n// This code would be a lot simpler if all the if/elses were inside\n// the function, but it would also be a lot less performant.\n//\n\n\nfunction createDeepMultiMapper(fields, emit) {\n  return function (doc) {\n    var toEmit = [];\n    for (var i = 0, iLen = fields.length; i < iLen; i++) {\n      var parsedField = parseField(fields[i]);\n      var value = doc;\n      for (var j = 0, jLen = parsedField.length; j < jLen; j++) {\n        var key = parsedField[j];\n        value = value[key];\n        if (typeof value === 'undefined') {\n          return; // don't emit\n        }\n      }\n      toEmit.push(value);\n    }\n    emit(toEmit);\n  };\n}\n\nfunction createDeepSingleMapper(field, emit) {\n  var parsedField = parseField(field);\n  return function (doc) {\n    var value = doc;\n    for (var i = 0, len = parsedField.length; i < len; i++) {\n      var key = parsedField[i];\n      value = value[key];\n      if (typeof value === 'undefined') {\n        return; // do nothing\n      }\n    }\n    emit(value);\n  };\n}\n\nfunction createShallowSingleMapper(field, emit) {\n  return function (doc) {\n    emit(doc[field]);\n  };\n}\n\nfunction createShallowMultiMapper(fields, emit) {\n  return function (doc) {\n    var toEmit = [];\n    for (var i = 0, len = fields.length; i < len; i++) {\n      toEmit.push(doc[fields[i]]);\n    }\n    emit(toEmit);\n  };\n}\n\nfunction checkShallow(fields) {\n  for (var i = 0, len = fields.length; i < len; i++) {\n    var field = fields[i];\n    if (field.indexOf('.') !== -1) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction createMapper(fields, emit) {\n  var isShallow = checkShallow(fields);\n  var isSingle = fields.length === 1;\n\n  // notice we try to optimize for the most common case,\n  // i.e. single shallow indexes\n  if (isShallow) {\n    if (isSingle) {\n      return createShallowSingleMapper(fields[0], emit);\n    } else { // multi\n      return createShallowMultiMapper(fields, emit);\n    }\n  } else { // deep\n    if (isSingle) {\n      return createDeepSingleMapper(fields[0], emit);\n    } else { // multi\n      return createDeepMultiMapper(fields, emit);\n    }\n  }\n}\n\nfunction mapper(mapFunDef, emit) {\n  // mapFunDef is a list of fields\n\n  var fields = Object.keys(mapFunDef.fields);\n\n  return createMapper(fields, emit);\n}\n\n/* istanbul ignore next */\nfunction reducer(/*reduceFunDef*/) {\n  throw new Error('reduce not supported');\n}\n\nfunction ddocValidator(ddoc, viewName) {\n  var view = ddoc.views[viewName];\n  // This doesn't actually need to be here apparently, but\n  // I feel safer keeping it.\n  /* istanbul ignore if */\n  if (!view.map || !view.map.fields) {\n    throw new Error('ddoc ' + ddoc._id +' with view ' + viewName +\n      ' doesn\\'t have map.fields defined. ' +\n      'maybe it wasn\\'t created by this plugin?');\n  }\n}\n\nvar abstractMapper = abstractMapReduce(\n  /* localDocName */ 'indexes',\n  mapper,\n  reducer,\n  ddocValidator\n);\n\nfunction abstractMapper$1 (db) {\n  return db._customFindAbstractMapper || abstractMapper;\n}\n\n// normalize the \"sort\" value\nfunction massageSort(sort) {\n  if (!Array.isArray(sort)) {\n    throw new Error('invalid sort json - should be an array');\n  }\n  return sort.map(function (sorting) {\n    if (typeof sorting === 'string') {\n      var obj = {};\n      obj[sorting] = 'asc';\n      return obj;\n    } else {\n      return sorting;\n    }\n  });\n}\n\nfunction massageUseIndex(useIndex) {\n  var cleanedUseIndex = [];\n  if (typeof useIndex === 'string') {\n    cleanedUseIndex.push(useIndex);\n  } else {\n    cleanedUseIndex = useIndex;\n  }\n\n  return cleanedUseIndex.map(function (name) {\n    return name.replace('_design/', '');\n  });\n}\n\nfunction massageIndexDef(indexDef) {\n  indexDef.fields = indexDef.fields.map(function (field) {\n    if (typeof field === 'string') {\n      var obj = {};\n      obj[field] = 'asc';\n      return obj;\n    }\n    return field;\n  });\n  return indexDef;\n}\n\nfunction getKeyFromDoc(doc, index) {\n  var res = [];\n  for (var i = 0; i < index.def.fields.length; i++) {\n    var field = getKey(index.def.fields[i]);\n    res.push(doc[field]);\n  }\n  return res;\n}\n\n// have to do this manually because REASONS. I don't know why\n// CouchDB didn't implement inclusive_start\nfunction filterInclusiveStart(rows, targetValue, index) {\n  var indexFields = index.def.fields;\n  for (var i = 0, len = rows.length; i < len; i++) {\n    var row = rows[i];\n\n    // shave off any docs at the beginning that are <= the\n    // target value\n\n    var docKey = getKeyFromDoc(row.doc, index);\n    if (indexFields.length === 1) {\n      docKey = docKey[0]; // only one field, not multi-field\n    } else { // more than one field in index\n      // in the case where e.g. the user is searching {$gt: {a: 1}}\n      // but the index is [a, b], then we need to shorten the doc key\n      while (docKey.length > targetValue.length) {\n        docKey.pop();\n      }\n    }\n    //ABS as we just looking for values that don't match\n    if (Math.abs(collate(docKey, targetValue)) > 0) {\n      // no need to filter any further; we're past the key\n      break;\n    }\n  }\n  return i > 0 ? rows.slice(i) : rows;\n}\n\nfunction reverseOptions(opts) {\n  var newOpts = clone(opts);\n  delete newOpts.startkey;\n  delete newOpts.endkey;\n  delete newOpts.inclusive_start;\n  delete newOpts.inclusive_end;\n\n  if ('endkey' in opts) {\n    newOpts.startkey = opts.endkey;\n  }\n  if ('startkey' in opts) {\n    newOpts.endkey = opts.startkey;\n  }\n  if ('inclusive_start' in opts) {\n    newOpts.inclusive_end = opts.inclusive_start;\n  }\n  if ('inclusive_end' in opts) {\n    newOpts.inclusive_start = opts.inclusive_end;\n  }\n  return newOpts;\n}\n\nfunction validateIndex(index) {\n  var ascFields = index.fields.filter(function (field) {\n    return getValue(field) === 'asc';\n  });\n  if (ascFields.length !== 0 && ascFields.length !== index.fields.length) {\n    throw new Error('unsupported mixed sorting');\n  }\n}\n\nfunction validateSort(requestDef, index) {\n  if (index.defaultUsed && requestDef.sort) {\n    var noneIdSorts = requestDef.sort.filter(function (sortItem) {\n      return Object.keys(sortItem)[0] !== '_id';\n    }).map(function (sortItem) {\n      return Object.keys(sortItem)[0];\n    });\n\n    if (noneIdSorts.length > 0) {\n      throw new Error('Cannot sort on field(s) \"' + noneIdSorts.join(',') +\n      '\" when using the default index');\n    }\n  }\n\n  if (index.defaultUsed) {\n    return;\n  }\n}\n\nfunction validateFindRequest(requestDef) {\n  if (typeof requestDef.selector !== 'object') {\n    throw new Error('you must provide a selector when you find()');\n  }\n\n  /*var selectors = requestDef.selector['$and'] || [requestDef.selector];\n  for (var i = 0; i < selectors.length; i++) {\n    var selector = selectors[i];\n    var keys = Object.keys(selector);\n    if (keys.length === 0) {\n      throw new Error('invalid empty selector');\n    }\n    //var selection = selector[keys[0]];\n    /*if (Object.keys(selection).length !== 1) {\n      throw new Error('invalid selector: ' + JSON.stringify(selection) +\n        ' - it must have exactly one key/value');\n    }\n  }*/\n}\n\n// determine the maximum number of fields\n// we're going to need to query, e.g. if the user\n// has selection ['a'] and sorting ['a', 'b'], then we\n// need to use the longer of the two: ['a', 'b']\nfunction getUserFields(selector, sort) {\n  var selectorFields = Object.keys(selector);\n  var sortFields = sort? sort.map(getKey) : [];\n  var userFields;\n  if (selectorFields.length >= sortFields.length) {\n    userFields = selectorFields;\n  } else {\n    userFields = sortFields;\n  }\n\n  if (sortFields.length === 0) {\n    return {\n      fields: userFields\n    };\n  }\n\n  // sort according to the user's preferred sorting\n  userFields = userFields.sort(function (left, right) {\n    var leftIdx = sortFields.indexOf(left);\n    if (leftIdx === -1) {\n      leftIdx = Number.MAX_VALUE;\n    }\n    var rightIdx = sortFields.indexOf(right);\n    if (rightIdx === -1) {\n      rightIdx = Number.MAX_VALUE;\n    }\n    return leftIdx < rightIdx ? -1 : leftIdx > rightIdx ? 1 : 0;\n  });\n\n  return {\n    fields: userFields,\n    sortOrder: sort.map(getKey)\n  };\n}\n\nfunction createIndex$1(db, requestDef) {\n  requestDef = massageCreateIndexRequest(requestDef);\n  var originalIndexDef = clone(requestDef.index);\n  requestDef.index = massageIndexDef(requestDef.index);\n\n  validateIndex(requestDef.index);\n\n  // calculating md5 is expensive - memoize and only\n  // run if required\n  var md5;\n  function getMd5() {\n    return md5 || (md5 = stringMd5(JSON.stringify(requestDef)));\n  }\n\n  var viewName = requestDef.name || ('idx-' + getMd5());\n\n  var ddocName = requestDef.ddoc || ('idx-' + getMd5());\n  var ddocId = '_design/' + ddocName;\n\n  var hasInvalidLanguage = false;\n  var viewExists = false;\n\n  function updateDdoc(doc) {\n    if (doc._rev && doc.language !== 'query') {\n      hasInvalidLanguage = true;\n    }\n    doc.language = 'query';\n    doc.views = doc.views || {};\n\n    viewExists = !!doc.views[viewName];\n\n    if (viewExists) {\n      return false;\n    }\n\n    doc.views[viewName] = {\n      map: {\n        fields: mergeObjects(requestDef.index.fields)\n      },\n      reduce: '_count',\n      options: {\n        def: originalIndexDef\n      }\n    };\n\n    return doc;\n  }\n\n  db.constructor.emit('debug', ['find', 'creating index', ddocId]);\n\n  return upsert(db, ddocId, updateDdoc).then(function () {\n    if (hasInvalidLanguage) {\n      throw new Error('invalid language for ddoc with id \"' +\n      ddocId +\n      '\" (should be \"query\")');\n    }\n  }).then(function () {\n    // kick off a build\n    // TODO: abstract-pouchdb-mapreduce should support auto-updating\n    // TODO: should also use update_after, but pouchdb/pouchdb#3415 blocks me\n    var signature = ddocName + '/' + viewName;\n    return abstractMapper$1(db).query.call(db, signature, {\n      limit: 0,\n      reduce: false\n    }).then(function () {\n      return {\n        id: ddocId,\n        name: viewName,\n        result: viewExists ? 'exists' : 'created'\n      };\n    });\n  });\n}\n\nfunction getIndexes$1(db) {\n  // just search through all the design docs and filter in-memory.\n  // hopefully there aren't that many ddocs.\n  return db.allDocs({\n    startkey: '_design/',\n    endkey: '_design/\\uffff',\n    include_docs: true\n  }).then(function (allDocsRes) {\n    var res = {\n      indexes: [{\n        ddoc: null,\n        name: '_all_docs',\n        type: 'special',\n        def: {\n          fields: [{_id: 'asc'}]\n        }\n      }]\n    };\n\n    res.indexes = flatten(res.indexes, allDocsRes.rows.filter(function (row) {\n      return row.doc.language === 'query';\n    }).map(function (row) {\n      var viewNames = row.doc.views !== undefined ? Object.keys(row.doc.views) : [];\n\n      return viewNames.map(function (viewName) {\n        var view = row.doc.views[viewName];\n        return {\n          ddoc: row.id,\n          name: viewName,\n          type: 'json',\n          def: massageIndexDef(view.options.def)\n        };\n      });\n    }));\n\n    // these are sorted by view name for some reason\n    res.indexes.sort(function (left, right) {\n      return compare(left.name, right.name);\n    });\n    res.total_rows = res.indexes.length;\n    return res;\n  });\n}\n\n// couchdb lowest collation value\nvar COLLATE_LO = null;\n\n// couchdb highest collation value (TODO: well not really, but close enough amirite)\nvar COLLATE_HI = {\"\\uffff\": {}};\n\nconst SHORT_CIRCUIT_QUERY = {\n  queryOpts: { limit: 0, startkey: COLLATE_HI, endkey: COLLATE_LO },\n  inMemoryFields: [],\n};\n\n// couchdb second-lowest collation value\n\nfunction checkFieldInIndex(index, field) {\n  var indexFields = index.def.fields.map(getKey);\n  for (var i = 0, len = indexFields.length; i < len; i++) {\n    var indexField = indexFields[i];\n    if (field === indexField) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// so when you do e.g. $eq/$eq, we can do it entirely in the database.\n// but when you do e.g. $gt/$eq, the first part can be done\n// in the database, but the second part has to be done in-memory,\n// because $gt has forced us to lose precision.\n// so that's what this determines\nfunction userOperatorLosesPrecision(selector, field) {\n  var matcher = selector[field];\n  var userOperator = getKey(matcher);\n\n  return userOperator !== '$eq';\n}\n\n// sort the user fields by their position in the index,\n// if they're in the index\nfunction sortFieldsByIndex(userFields, index) {\n  var indexFields = index.def.fields.map(getKey);\n\n  return userFields.slice().sort(function (a, b) {\n    var aIdx = indexFields.indexOf(a);\n    var bIdx = indexFields.indexOf(b);\n    if (aIdx === -1) {\n      aIdx = Number.MAX_VALUE;\n    }\n    if (bIdx === -1) {\n      bIdx = Number.MAX_VALUE;\n    }\n    return compare(aIdx, bIdx);\n  });\n}\n\n// first pass to try to find fields that will need to be sorted in-memory\nfunction getBasicInMemoryFields(index, selector, userFields) {\n\n  userFields = sortFieldsByIndex(userFields, index);\n\n  // check if any of the user selectors lose precision\n  var needToFilterInMemory = false;\n  for (var i = 0, len = userFields.length; i < len; i++) {\n    var field = userFields[i];\n    if (needToFilterInMemory || !checkFieldInIndex(index, field)) {\n      return userFields.slice(i);\n    }\n    if (i < len - 1 && userOperatorLosesPrecision(selector, field)) {\n      needToFilterInMemory = true;\n    }\n  }\n  return [];\n}\n\nfunction getInMemoryFieldsFromNe(selector) {\n  var fields = [];\n  Object.keys(selector).forEach(function (field) {\n    var matcher = selector[field];\n    Object.keys(matcher).forEach(function (operator) {\n      if (operator === '$ne') {\n        fields.push(field);\n      }\n    });\n  });\n  return fields;\n}\n\nfunction getInMemoryFields(coreInMemoryFields, index, selector, userFields) {\n  var result = flatten(\n    // in-memory fields reported as necessary by the query planner\n    coreInMemoryFields,\n    // combine with another pass that checks for any we may have missed\n    getBasicInMemoryFields(index, selector, userFields),\n    // combine with another pass that checks for $ne's\n    getInMemoryFieldsFromNe(selector)\n  );\n\n  return sortFieldsByIndex(uniq(result), index);\n}\n\n// check that at least one field in the user's query is represented\n// in the index. order matters in the case of sorts\nfunction checkIndexFieldsMatch(indexFields, sortOrder, fields) {\n  if (sortOrder) {\n    // array has to be a strict subarray of index array. furthermore,\n    // the sortOrder fields need to all be represented in the index\n    var sortMatches = oneArrayIsStrictSubArrayOfOther(sortOrder, indexFields);\n    var selectorMatches = oneArrayIsSubArrayOfOther(fields, indexFields);\n\n    return sortMatches && selectorMatches;\n  }\n\n  // all of the user's specified fields still need to be\n  // on the left side of the index array, although the order\n  // doesn't matter\n  return oneSetIsSubArrayOfOther(fields, indexFields);\n}\n\nvar logicalMatchers = ['$eq', '$gt', '$gte', '$lt', '$lte'];\nfunction isNonLogicalMatcher(matcher) {\n  return logicalMatchers.indexOf(matcher) === -1;\n}\n\n// check all the index fields for usages of '$ne'\n// e.g. if the user queries {foo: {$ne: 'foo'}, bar: {$eq: 'bar'}},\n// then we can neither use an index on ['foo'] nor an index on\n// ['foo', 'bar'], but we can use an index on ['bar'] or ['bar', 'foo']\nfunction checkFieldsLogicallySound(indexFields, selector) {\n  var firstField = indexFields[0];\n  var matcher = selector[firstField];\n\n  if (typeof matcher === 'undefined') {\n    /* istanbul ignore next */\n    return true;\n  }\n\n  var isInvalidNe = Object.keys(matcher).length === 1 &&\n    getKey(matcher) === '$ne';\n\n  return !isInvalidNe;\n}\n\nfunction checkIndexMatches(index, sortOrder, fields, selector) {\n\n  var indexFields = index.def.fields.map(getKey);\n\n  var fieldsMatch = checkIndexFieldsMatch(indexFields, sortOrder, fields);\n\n  if (!fieldsMatch) {\n    return false;\n  }\n\n  return checkFieldsLogicallySound(indexFields, selector);\n}\n\n//\n// the algorithm is very simple:\n// take all the fields the user supplies, and if those fields\n// are a strict subset of the fields in some index,\n// then use that index\n//\n//\nfunction findMatchingIndexes(selector, userFields, sortOrder, indexes) {\n  return indexes.filter(function (index) {\n    return checkIndexMatches(index, sortOrder, userFields, selector);\n  });\n}\n\n// find the best index, i.e. the one that matches the most fields\n// in the user's query\nfunction findBestMatchingIndex(selector, userFields, sortOrder, indexes, useIndex) {\n\n  var matchingIndexes = findMatchingIndexes(selector, userFields, sortOrder, indexes);\n\n  if (matchingIndexes.length === 0) {\n    if (useIndex) {\n      throw {\n        error: \"no_usable_index\",\n        message: \"There is no index available for this selector.\"\n      };\n    }\n    //return `all_docs` as a default index;\n    //I'm assuming that _all_docs is always first\n    var defaultIndex = indexes[0];\n    defaultIndex.defaultUsed = true;\n    return defaultIndex;\n  }\n  if (matchingIndexes.length === 1 && !useIndex) {\n    return matchingIndexes[0];\n  }\n\n  var userFieldsMap = arrayToObject(userFields);\n\n  function scoreIndex(index) {\n    var indexFields = index.def.fields.map(getKey);\n    var score = 0;\n    for (var i = 0, len = indexFields.length; i < len; i++) {\n      var indexField = indexFields[i];\n      if (userFieldsMap[indexField]) {\n        score++;\n      }\n    }\n    return score;\n  }\n\n  if (useIndex) {\n    var useIndexDdoc = '_design/' + useIndex[0];\n    var useIndexName = useIndex.length === 2 ? useIndex[1] : false;\n    var index = matchingIndexes.find(function (index) {\n      if (useIndexName && index.ddoc === useIndexDdoc && useIndexName === index.name) {\n        return true;\n      }\n\n      if (index.ddoc === useIndexDdoc) {\n        /* istanbul ignore next */\n        return true;\n      }\n\n      return false;\n    });\n\n    if (!index) {\n      throw {\n        error: \"unknown_error\",\n        message: \"Could not find that index or could not use that index for the query\"\n      };\n    }\n    return index;\n  }\n\n  return max(matchingIndexes, scoreIndex);\n}\n\nfunction getSingleFieldQueryOptsFor(userOperator, userValue) {\n  switch (userOperator) {\n    case '$eq':\n      return {key: userValue};\n    case '$lte':\n      return {endkey: userValue};\n    case '$gte':\n      return {startkey: userValue};\n    case '$lt':\n      return {\n        endkey: userValue,\n        inclusive_end: false\n      };\n    case '$gt':\n      return {\n        startkey: userValue,\n        inclusive_start: false\n      };\n  }\n\n  return {\n    startkey: COLLATE_LO\n  };\n}\n\nfunction getSingleFieldCoreQueryPlan(selector, index) {\n  var field = getKey(index.def.fields[0]);\n  //ignoring this because the test to exercise the branch is skipped at the moment\n  /* istanbul ignore next */\n  var matcher = selector[field] || {};\n  var inMemoryFields = [];\n\n  var userOperators = Object.keys(matcher);\n\n  var combinedOpts;\n\n  userOperators.forEach(function (userOperator) {\n\n    if (isNonLogicalMatcher(userOperator)) {\n      inMemoryFields.push(field);\n    }\n\n    var userValue = matcher[userOperator];\n\n    var newQueryOpts = getSingleFieldQueryOptsFor(userOperator, userValue);\n\n    if (combinedOpts) {\n      combinedOpts = mergeObjects([combinedOpts, newQueryOpts]);\n    } else {\n      combinedOpts = newQueryOpts;\n    }\n  });\n\n  return {\n    queryOpts: combinedOpts,\n    inMemoryFields: inMemoryFields\n  };\n}\n\nfunction getMultiFieldCoreQueryPlan(userOperator, userValue) {\n  switch (userOperator) {\n    case '$eq':\n      return {\n        startkey: userValue,\n        endkey: userValue\n      };\n    case '$lte':\n      return {\n        endkey: userValue\n      };\n    case '$gte':\n      return {\n        startkey: userValue\n      };\n    case '$lt':\n      return {\n        endkey: userValue,\n        inclusive_end: false\n      };\n    case '$gt':\n      return {\n        startkey: userValue,\n        inclusive_start: false\n      };\n  }\n}\n\nfunction getMultiFieldQueryOpts(selector, index) {\n\n  var indexFields = index.def.fields.map(getKey);\n\n  var inMemoryFields = [];\n  var startkey = [];\n  var endkey = [];\n  var inclusiveStart;\n  var inclusiveEnd;\n\n\n  function finish(i) {\n\n    if (inclusiveStart !== false) {\n      startkey.push(COLLATE_LO);\n    }\n    if (inclusiveEnd !== false) {\n      endkey.push(COLLATE_HI);\n    }\n    // keep track of the fields where we lost specificity,\n    // and therefore need to filter in-memory\n    inMemoryFields = indexFields.slice(i);\n  }\n\n  for (var i = 0, len = indexFields.length; i < len; i++) {\n    var indexField = indexFields[i];\n\n    var matcher = selector[indexField];\n\n    if (!matcher || !Object.keys(matcher).length) { // fewer fields in user query than in index\n      finish(i);\n      break;\n    } else if (Object.keys(matcher).some(isNonLogicalMatcher)) { // non-logical are ignored\n      finish(i);\n      break;\n    } else if (i > 0) {\n      var usingGtlt = (\n        '$gt' in matcher || '$gte' in matcher ||\n        '$lt' in matcher || '$lte' in matcher);\n      var previousKeys = Object.keys(selector[indexFields[i - 1]]);\n      var previousWasEq = arrayEquals(previousKeys, ['$eq']);\n      var previousWasSame = arrayEquals(previousKeys, Object.keys(matcher));\n      var gtltLostSpecificity = usingGtlt && !previousWasEq && !previousWasSame;\n      if (gtltLostSpecificity) {\n        finish(i);\n        break;\n      }\n    }\n\n    var userOperators = Object.keys(matcher);\n\n    var combinedOpts = null;\n\n    for (var j = 0; j < userOperators.length; j++) {\n      var userOperator = userOperators[j];\n      var userValue = matcher[userOperator];\n\n      var newOpts = getMultiFieldCoreQueryPlan(userOperator, userValue);\n\n      if (combinedOpts) {\n        combinedOpts = mergeObjects([combinedOpts, newOpts]);\n      } else {\n        combinedOpts = newOpts;\n      }\n    }\n\n    startkey.push('startkey' in combinedOpts ? combinedOpts.startkey : COLLATE_LO);\n    endkey.push('endkey' in combinedOpts ? combinedOpts.endkey : COLLATE_HI);\n    if ('inclusive_start' in combinedOpts) {\n      inclusiveStart = combinedOpts.inclusive_start;\n    }\n    if ('inclusive_end' in combinedOpts) {\n      inclusiveEnd = combinedOpts.inclusive_end;\n    }\n  }\n\n  var res = {\n    startkey: startkey,\n    endkey: endkey\n  };\n\n  if (typeof inclusiveStart !== 'undefined') {\n    res.inclusive_start = inclusiveStart;\n  }\n  if (typeof inclusiveEnd !== 'undefined') {\n    res.inclusive_end = inclusiveEnd;\n  }\n\n  return {\n    queryOpts: res,\n    inMemoryFields: inMemoryFields\n  };\n}\n\nfunction shouldShortCircuit(selector) {\n  // We have a field to select from, but not a valid value\n  // this should result in a short circuited query \n  // just like the http adapter (couchdb) and mongodb\n  // see tests for issue #7810\n  \n  // @todo Use 'Object.values' when Node.js v6 support is dropped.\n  const values = Object.keys(selector).map(function (key) {\n    return selector[key];\n  });\n  return values.some(function (val) { \n    return typeof val === 'object' && Object.keys(val).length === 0;\n});\n}\n\nfunction getDefaultQueryPlan(selector) {\n  //using default index, so all fields need to be done in memory\n  return {\n    queryOpts: {startkey: null},\n    inMemoryFields: [Object.keys(selector)]\n  };\n}\n\nfunction getCoreQueryPlan(selector, index) {\n  if (index.defaultUsed) {\n    return getDefaultQueryPlan(selector, index);\n  }\n\n  if (index.def.fields.length === 1) {\n    // one field in index, so the value was indexed as a singleton\n    return getSingleFieldCoreQueryPlan(selector, index);\n  }\n  // else index has multiple fields, so the value was indexed as an array\n  return getMultiFieldQueryOpts(selector, index);\n}\n\nfunction planQuery(request, indexes) {\n\n  var selector = request.selector;\n  var sort = request.sort;\n\n  if (shouldShortCircuit(selector)) {\n    return assign({}, SHORT_CIRCUIT_QUERY, { index: indexes[0] });\n  }\n\n  var userFieldsRes = getUserFields(selector, sort);\n\n  var userFields = userFieldsRes.fields;\n  var sortOrder = userFieldsRes.sortOrder;\n  var index = findBestMatchingIndex(selector, userFields, sortOrder, indexes, request.use_index);\n\n  var coreQueryPlan = getCoreQueryPlan(selector, index);\n  var queryOpts = coreQueryPlan.queryOpts;\n  var coreInMemoryFields = coreQueryPlan.inMemoryFields;\n\n  var inMemoryFields = getInMemoryFields(coreInMemoryFields, index, selector, userFields);\n\n  var res = {\n    queryOpts: queryOpts,\n    index: index,\n    inMemoryFields: inMemoryFields\n  };\n  return res;\n}\n\nfunction indexToSignature(index) {\n  // remove '_design/'\n  return index.ddoc.substring(8) + '/' + index.name;\n}\n\nfunction doAllDocs(db, originalOpts) {\n  var opts = clone(originalOpts);\n\n  // CouchDB responds in weird ways when you provide a non-string to _id;\n  // we mimic the behavior for consistency. See issue66 tests for details.\n  if (opts.descending) {\n    if ('endkey' in opts && typeof opts.endkey !== 'string') {\n      opts.endkey = '';\n    }\n    if ('startkey' in opts && typeof opts.startkey !== 'string') {\n      opts.limit = 0;\n    }\n  } else {\n    if ('startkey' in opts && typeof opts.startkey !== 'string') {\n      opts.startkey = '';\n    }\n    if ('endkey' in opts && typeof opts.endkey !== 'string') {\n      opts.limit = 0;\n    }\n  }\n  if ('key' in opts && typeof opts.key !== 'string') {\n    opts.limit = 0;\n  }\n\n  if (opts.limit > 0 && opts.indexes_count) {\n    // brute force and quite naive impl.\n    // amp up the limit with the amount of (indexes) design docs\n    // or is this too naive? How about skip?\n    opts.original_limit = opts.limit;\n    opts.limit += opts.indexes_count;\n  }\n\n  return db.allDocs(opts)\n    .then(function (res) {\n      // filter out any design docs that _all_docs might return\n      res.rows = res.rows.filter(function (row) {\n        return !/^_design\\//.test(row.id);\n      });\n      // put back original limit\n      if (opts.original_limit) {\n        opts.limit = opts.original_limit;\n      }\n      // enforce the rows to respect the given limit\n      res.rows = res.rows.slice(0, opts.limit);\n      return res;\n    });\n}\n\nfunction find$1(db, requestDef, explain) {\n  if (requestDef.selector) {\n    requestDef.selector = massageSelector(requestDef.selector);\n  }\n\n  if (requestDef.sort) {\n    requestDef.sort = massageSort(requestDef.sort);\n  }\n\n  if (requestDef.use_index) {\n    requestDef.use_index = massageUseIndex(requestDef.use_index);\n  }\n\n  validateFindRequest(requestDef);\n\n  return getIndexes$1(db).then(function (getIndexesRes) {\n\n    db.constructor.emit('debug', ['find', 'planning query', requestDef]);\n    var queryPlan = planQuery(requestDef, getIndexesRes.indexes);\n    db.constructor.emit('debug', ['find', 'query plan', queryPlan]);\n    \n    var indexToUse = queryPlan.index;\n    \n    validateSort(requestDef, indexToUse);\n\n    var opts = assign({\n      include_docs: true,\n      reduce: false,\n      // Add amount of index for doAllDocs to use (related to issue #7810)\n      indexes_count: getIndexesRes.total_rows, \n    }, queryPlan.queryOpts);\n\n    if ('startkey' in opts && 'endkey' in opts &&\n        collate(opts.startkey, opts.endkey) > 0) {\n      // can't possibly return any results, startkey > endkey\n      /* istanbul ignore next */\n      return {docs: []};\n    }\n\n    var isDescending = requestDef.sort &&\n      typeof requestDef.sort[0] !== 'string' &&\n      getValue(requestDef.sort[0]) === 'desc';\n\n    if (isDescending) {\n      // either all descending or all ascending\n      opts.descending = true;\n      opts = reverseOptions(opts);\n    }\n\n    if (!queryPlan.inMemoryFields.length) {\n      // no in-memory filtering necessary, so we can let the\n      // database do the limit/skip for us\n      if ('limit' in requestDef) {\n        opts.limit = requestDef.limit;\n      }\n      if ('skip' in requestDef) {\n        opts.skip = requestDef.skip;\n      }\n    }\n\n    if (explain) {\n      return Promise.resolve(queryPlan, opts);\n    }\n\n    return Promise.resolve().then(function () {\n      if (indexToUse.name === '_all_docs') {\n        return doAllDocs(db, opts);\n      } else {\n        var signature = indexToSignature(indexToUse);\n        return abstractMapper$1(db).query.call(db, signature, opts);\n      }\n    }).then(function (res) {\n      if (opts.inclusive_start === false) {\n        // may have to manually filter the first one,\n        // since couchdb has no true inclusive_start option\n        res.rows = filterInclusiveStart(res.rows, opts.startkey, indexToUse);\n      }\n\n      if (queryPlan.inMemoryFields.length) {\n        // need to filter some stuff in-memory\n        res.rows = filterInMemoryFields(res.rows, requestDef, queryPlan.inMemoryFields);\n      }\n\n      var resp = {\n        docs: res.rows.map(function (row) {\n          var doc = row.doc;\n          if (requestDef.fields) {\n            return pick(doc, requestDef.fields);\n          }\n          return doc;\n        })\n      };\n\n      if (indexToUse.defaultUsed) {\n        resp.warning = 'No matching index found, create an index to optimize query time.';\n      }\n\n      return resp;\n    });\n  });\n}\n\nfunction explain$1(db, requestDef) {\n  return find$1(db, requestDef, true)\n  .then(function (queryPlan) {\n    return {\n      dbname: db.name,\n      index: queryPlan.index,\n      selector: requestDef.selector,\n      range: {\n        start_key: queryPlan.queryOpts.startkey,\n        end_key: queryPlan.queryOpts.endkey,\n      },\n      opts: {\n        use_index: requestDef.use_index || [],\n        bookmark: \"nil\", //hardcoded to match CouchDB since its not supported,\n        limit: requestDef.limit,\n        skip: requestDef.skip,\n        sort: requestDef.sort || {},\n        fields: requestDef.fields,\n        conflicts: false, //hardcoded to match CouchDB since its not supported,\n        r: [49], // hardcoded to match CouchDB since its not support\n      },\n      limit: requestDef.limit,\n      skip: requestDef.skip || 0,\n      fields: requestDef.fields,\n    };\n  });\n}\n\nfunction deleteIndex$1(db, index) {\n\n  if (!index.ddoc) {\n    throw new Error('you must supply an index.ddoc when deleting');\n  }\n\n  if (!index.name) {\n    throw new Error('you must supply an index.name when deleting');\n  }\n\n  var docId = index.ddoc;\n  var viewName = index.name;\n\n  function deltaFun(doc) {\n    if (Object.keys(doc.views).length === 1 && doc.views[viewName]) {\n      // only one view in this ddoc, delete the whole ddoc\n      return {_id: docId, _deleted: true};\n    }\n    // more than one view here, just remove the view\n    delete doc.views[viewName];\n    return doc;\n  }\n\n  return upsert(db, docId, deltaFun).then(function () {\n    return abstractMapper$1(db).viewCleanup.apply(db);\n  }).then(function () {\n    return {ok: true};\n  });\n}\n\nvar createIndexAsCallback = callbackify(createIndex$1);\nvar findAsCallback = callbackify(find$1);\nvar explainAsCallback = callbackify(explain$1);\nvar getIndexesAsCallback = callbackify(getIndexes$1);\nvar deleteIndexAsCallback = callbackify(deleteIndex$1);\n\nvar plugin = {};\nplugin.createIndex = toPromise(function (requestDef, callback) {\n\n  if (typeof requestDef !== 'object') {\n    return callback(new Error('you must provide an index to create'));\n  }\n\n  var createIndex$$1 = isRemote(this) ?\n    createIndex : createIndexAsCallback;\n  createIndex$$1(this, requestDef, callback);\n});\n\nplugin.find = toPromise(function (requestDef, callback) {\n\n  if (typeof callback === 'undefined') {\n    callback = requestDef;\n    requestDef = undefined;\n  }\n\n  if (typeof requestDef !== 'object') {\n    return callback(new Error('you must provide search parameters to find()'));\n  }\n\n  var find$$1 = isRemote(this) ? find : findAsCallback;\n  find$$1(this, requestDef, callback);\n});\n\nplugin.explain = toPromise(function (requestDef, callback) {\n\n  if (typeof callback === 'undefined') {\n    callback = requestDef;\n    requestDef = undefined;\n  }\n\n  if (typeof requestDef !== 'object') {\n    return callback(new Error('you must provide search parameters to explain()'));\n  }\n\n  var find$$1 = isRemote(this) ? explain : explainAsCallback;\n  find$$1(this, requestDef, callback);\n});\n\nplugin.getIndexes = toPromise(function (callback) {\n\n  var getIndexes$$1 = isRemote(this) ? getIndexes : getIndexesAsCallback;\n  getIndexes$$1(this, callback);\n});\n\nplugin.deleteIndex = toPromise(function (indexDef, callback) {\n\n  if (typeof indexDef !== 'object') {\n    return callback(new Error('you must provide an index to delete'));\n  }\n\n  var deleteIndex$$1 = isRemote(this) ?\n    deleteIndex : deleteIndexAsCallback;\n  deleteIndex$$1(this, indexDef, callback);\n});\n\nexport default plugin;\n"]},"metadata":{},"sourceType":"module"}
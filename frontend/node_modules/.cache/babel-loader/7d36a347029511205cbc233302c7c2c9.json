{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function sent() {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) {\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [op[0] & 2, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function next() {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n      ar.push(r.value);\n    }\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nimport { createBddFromTruthTable } from './create-bdd-from-truth-table';\nimport { firstKeyOfMap, shuffleArray, lastOfArray } from './util';\n/**\n * returns the bdd with less nodes\n */\n\nexport var defaultCompareResults = function defaultCompareResults(a, b) {\n  if (a.countNodes() <= b.countNodes()) {\n    return a;\n  } else {\n    return b;\n  }\n};\n/**\n * optimises the ordering of the boolean functions\n * by randomly sorting the array\n * and checking the resulting bdd\n */\n\nexport function optimizeBruteForce(_a) {\n  var truthTable = _a.truthTable,\n      _b = _a.iterations,\n      iterations = _b === void 0 ? Infinity : _b,\n      _c = _a.onBetterBdd,\n      onBetterBdd = _c === void 0 ? function () {\n    return null;\n  } : _c,\n      _d = _a.compareResults,\n      compareResults = _d === void 0 ? defaultCompareResults : _d,\n      _e = _a.afterBddCreation,\n      afterBddCreation = _e === void 0 ? function () {\n    return null;\n  } : _e,\n      _f = _a.log,\n      log = _f === void 0 ? false : _f;\n  return __awaiter(this, void 0, void 0, function () {\n    var initialBdd, currentBestResult, t, _loop_1;\n\n    return __generator(this, function (_g) {\n      switch (_g.label) {\n        case 0:\n          initialBdd = createBddFromTruthTable(truthTable);\n          afterBddCreation(initialBdd);\n          initialBdd.minimize();\n          currentBestResult = {\n            truthTable: truthTable,\n            bdd: initialBdd\n          };\n\n          if (log) {\n            initialBdd.log();\n            console.log('initial nodes amount: ' + initialBdd.countNodes());\n          }\n\n          t = 0;\n\n          _loop_1 = function _loop_1() {\n            var shuffledOrdering, nextBdd, newNodesByLevel, lastLevel, newSortedLevels, lastLevelSet, betterBdd;\n            return __generator(this, function (_a) {\n              switch (_a.label) {\n                case 0:\n                  t++;\n\n                  if (log) {\n                    console.log('-'.repeat(50));\n                    console.log('optimizeBruteForce() itterate once');\n                  }\n\n                  shuffledOrdering = shuffleBooleanOrdering(truthTable);\n                  nextBdd = createBddFromTruthTable(shuffledOrdering.newTable);\n                  newNodesByLevel = new Map();\n                  lastLevel = lastOfArray(nextBdd.getLevels());\n                  newSortedLevels = [];\n                  nextBdd.getLevels().filter(function (level) {\n                    return level !== lastLevel;\n                  }).forEach(function (level) {\n                    var newLevel = shuffledOrdering.mappingBeforeToAfter[level];\n                    newSortedLevels.push(newLevel);\n                    var levelSet = new Set();\n                    newNodesByLevel.set(newLevel, levelSet);\n                    nextBdd.getNodesOfLevel(level).forEach(function (node) {\n                      node.level = newLevel;\n                      levelSet.add(node);\n                    });\n                  });\n                  lastLevelSet = new Set();\n                  nextBdd.getNodesOfLevel(lastLevel).forEach(function (node) {\n                    return lastLevelSet.add(node);\n                  });\n                  newNodesByLevel.set(lastLevel, lastLevelSet);\n                  newSortedLevels.push(lastLevel);\n                  nextBdd.nodesByLevel = newNodesByLevel;\n                  nextBdd.levels = newSortedLevels;\n                  afterBddCreation(nextBdd);\n                  nextBdd.minimize();\n\n                  if (log) {\n                    console.log('got new bdd with nodes amount of ' + nextBdd.countNodes()); //            nextBdd.log();\n\n                    console.dir(shuffledOrdering.mappingBeforeToAfter);\n                  }\n\n                  return [4\n                  /*yield*/\n                  , compareResults(currentBestResult.bdd, nextBdd)];\n\n                case 1:\n                  betterBdd = _a.sent();\n\n                  if (betterBdd.type !== 'RootNode') {\n                    throw new Error('compareResults did not return a bdd');\n                  }\n\n                  if (betterBdd === nextBdd) {\n                    if (log) {\n                      console.log('#'.repeat(50));\n                      console.log('found better bdd ' + nextBdd.countNodes());\n                    }\n\n                    currentBestResult = {\n                      bdd: nextBdd,\n                      truthTable: shuffledOrdering.newTable\n                    };\n                    onBetterBdd(currentBestResult);\n                  }\n\n                  return [2\n                  /*return*/\n                  ];\n              }\n            });\n          };\n\n          _g.label = 1;\n\n        case 1:\n          if (!(t < iterations)) return [3\n          /*break*/\n          , 3];\n          return [5\n          /*yield**/\n          , _loop_1()];\n\n        case 2:\n          _g.sent();\n\n          return [3\n          /*break*/\n          , 1];\n\n        case 3:\n          return [2\n          /*return*/\n          , currentBestResult];\n      }\n    });\n  });\n}\nexport function shuffleBooleanOrdering(truthTable) {\n  var e_1, _a;\n\n  var firstKey = firstKeyOfMap(truthTable);\n  var arrayWithIndexes = getArrayWithIndexes(firstKey.length);\n  var shuffled = shuffleArray(arrayWithIndexes);\n  var mapping = {};\n  var mappingBeforeToAfter = {};\n  shuffled.forEach(function (indexBefore, indexAfter) {\n    mapping[indexAfter] = indexBefore;\n    mappingBeforeToAfter[indexBefore] = indexAfter;\n  });\n  var newTable = new Map();\n\n  try {\n    for (var _b = __values(truthTable.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {\n      var _d = __read(_c.value, 2),\n          key = _d[0],\n          value = _d[1];\n\n      var newKey = changeKeyOrder(key, mapping);\n      newTable.set(newKey, value);\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n\n  return {\n    newTable: newTable,\n    mapping: mapping,\n    mappingBeforeToAfter: mappingBeforeToAfter\n  };\n}\nexport function changeKeyOrder(oldKey, mappingBeforeToAfter) {\n  var chars = oldKey.split('').map(function (char, indexBefore) {\n    return {\n      char: char,\n      indexBefore: indexBefore,\n      indexAfter: mappingBeforeToAfter[indexBefore]\n    };\n  }).sort(function (a, b) {\n    return a.indexAfter - b.indexAfter;\n  }).map(function (charObj) {\n    return charObj.char;\n  }).join('');\n  return chars;\n}\nexport function getArrayWithIndexes(size) {\n  var ret = [];\n  var last = 0;\n\n  while (last < size) {\n    ret.push(last);\n    last++;\n  }\n\n  return ret;\n}","map":{"version":3,"sources":["../../src/optimize-brute-force.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nimport { createBddFromTruthTable } from './create-bdd-from-truth-table';\nimport { firstKeyOfMap, shuffleArray, lastOfArray } from './util';\n/**\n * returns the bdd with less nodes\n */\nexport var defaultCompareResults = function (a, b) {\n    if (a.countNodes() <= b.countNodes()) {\n        return a;\n    }\n    else {\n        return b;\n    }\n};\n/**\n * optimises the ordering of the boolean functions\n * by randomly sorting the array\n * and checking the resulting bdd\n */\nexport function optimizeBruteForce(_a) {\n    var truthTable = _a.truthTable, _b = _a.iterations, iterations = _b === void 0 ? Infinity : _b, _c = _a.onBetterBdd, onBetterBdd = _c === void 0 ? function () { return null; } : _c, _d = _a.compareResults, compareResults = _d === void 0 ? defaultCompareResults : _d, _e = _a.afterBddCreation, afterBddCreation = _e === void 0 ? function () { return null; } : _e, _f = _a.log, log = _f === void 0 ? false : _f;\n    return __awaiter(this, void 0, void 0, function () {\n        var initialBdd, currentBestResult, t, _loop_1;\n        return __generator(this, function (_g) {\n            switch (_g.label) {\n                case 0:\n                    initialBdd = createBddFromTruthTable(truthTable);\n                    afterBddCreation(initialBdd);\n                    initialBdd.minimize();\n                    currentBestResult = {\n                        truthTable: truthTable,\n                        bdd: initialBdd\n                    };\n                    if (log) {\n                        initialBdd.log();\n                        console.log('initial nodes amount: ' + initialBdd.countNodes());\n                    }\n                    t = 0;\n                    _loop_1 = function () {\n                        var shuffledOrdering, nextBdd, newNodesByLevel, lastLevel, newSortedLevels, lastLevelSet, betterBdd;\n                        return __generator(this, function (_a) {\n                            switch (_a.label) {\n                                case 0:\n                                    t++;\n                                    if (log) {\n                                        console.log('-'.repeat(50));\n                                        console.log('optimizeBruteForce() itterate once');\n                                    }\n                                    shuffledOrdering = shuffleBooleanOrdering(truthTable);\n                                    nextBdd = createBddFromTruthTable(shuffledOrdering.newTable);\n                                    newNodesByLevel = new Map();\n                                    lastLevel = lastOfArray(nextBdd.getLevels());\n                                    newSortedLevels = [];\n                                    nextBdd.getLevels()\n                                        .filter(function (level) { return level !== lastLevel; })\n                                        .forEach(function (level) {\n                                        var newLevel = shuffledOrdering.mappingBeforeToAfter[level];\n                                        newSortedLevels.push(newLevel);\n                                        var levelSet = new Set();\n                                        newNodesByLevel.set(newLevel, levelSet);\n                                        nextBdd.getNodesOfLevel(level).forEach(function (node) {\n                                            node.level = newLevel;\n                                            levelSet.add(node);\n                                        });\n                                    });\n                                    lastLevelSet = new Set();\n                                    nextBdd.getNodesOfLevel(lastLevel).forEach(function (node) { return lastLevelSet.add(node); });\n                                    newNodesByLevel.set(lastLevel, lastLevelSet);\n                                    newSortedLevels.push(lastLevel);\n                                    nextBdd.nodesByLevel = newNodesByLevel;\n                                    nextBdd.levels = newSortedLevels;\n                                    afterBddCreation(nextBdd);\n                                    nextBdd.minimize();\n                                    if (log) {\n                                        console.log('got new bdd with nodes amount of ' + nextBdd.countNodes());\n                                        //            nextBdd.log();\n                                        console.dir(shuffledOrdering.mappingBeforeToAfter);\n                                    }\n                                    return [4 /*yield*/, compareResults(currentBestResult.bdd, nextBdd)];\n                                case 1:\n                                    betterBdd = _a.sent();\n                                    if (betterBdd.type !== 'RootNode') {\n                                        throw new Error('compareResults did not return a bdd');\n                                    }\n                                    if (betterBdd === nextBdd) {\n                                        if (log) {\n                                            console.log('#'.repeat(50));\n                                            console.log('found better bdd ' + nextBdd.countNodes());\n                                        }\n                                        currentBestResult = {\n                                            bdd: nextBdd,\n                                            truthTable: shuffledOrdering.newTable\n                                        };\n                                        onBetterBdd(currentBestResult);\n                                    }\n                                    return [2 /*return*/];\n                            }\n                        });\n                    };\n                    _g.label = 1;\n                case 1:\n                    if (!(t < iterations)) return [3 /*break*/, 3];\n                    return [5 /*yield**/, _loop_1()];\n                case 2:\n                    _g.sent();\n                    return [3 /*break*/, 1];\n                case 3: return [2 /*return*/, currentBestResult];\n            }\n        });\n    });\n}\nexport function shuffleBooleanOrdering(truthTable) {\n    var e_1, _a;\n    var firstKey = firstKeyOfMap(truthTable);\n    var arrayWithIndexes = getArrayWithIndexes(firstKey.length);\n    var shuffled = shuffleArray(arrayWithIndexes);\n    var mapping = {};\n    var mappingBeforeToAfter = {};\n    shuffled.forEach(function (indexBefore, indexAfter) {\n        mapping[indexAfter] = indexBefore;\n        mappingBeforeToAfter[indexBefore] = indexAfter;\n    });\n    var newTable = new Map();\n    try {\n        for (var _b = __values(truthTable.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var _d = __read(_c.value, 2), key = _d[0], value = _d[1];\n            var newKey = changeKeyOrder(key, mapping);\n            newTable.set(newKey, value);\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return {\n        newTable: newTable,\n        mapping: mapping,\n        mappingBeforeToAfter: mappingBeforeToAfter\n    };\n}\nexport function changeKeyOrder(oldKey, mappingBeforeToAfter) {\n    var chars = oldKey\n        .split('')\n        .map(function (char, indexBefore) {\n        return {\n            char: char,\n            indexBefore: indexBefore,\n            indexAfter: mappingBeforeToAfter[indexBefore]\n        };\n    })\n        .sort(function (a, b) { return a.indexAfter - b.indexAfter; })\n        .map(function (charObj) { return charObj.char; })\n        .join('');\n    return chars;\n}\nexport function getArrayWithIndexes(size) {\n    var ret = [];\n    var last = 0;\n    while (last < size) {\n        ret.push(last);\n        last++;\n    }\n    return ret;\n}\n//# sourceMappingURL=optimize-brute-force.js.map"]},"metadata":{},"sourceType":"module"}
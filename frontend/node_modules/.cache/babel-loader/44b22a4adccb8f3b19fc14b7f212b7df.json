{"ast":null,"code":"var __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function next() {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n      ar.push(r.value);\n    }\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nimport { RootNode } from './root-node';\nimport { lastChar } from './util';\nimport { InternalNode } from './internal-node';\nimport { LeafNode } from './leaf-node';\nexport function createBddFromTruthTable(truthTable) {\n  var e_1, _a;\n\n  var root = new RootNode();\n  var firstKey = truthTable.keys().next().value;\n  var keyLength = firstKey.length;\n  var mustBeSize = Math.pow(2, keyLength);\n\n  if (truthTable.size !== mustBeSize) {\n    throw new Error('truth table has missing entries');\n  }\n\n  try {\n    for (var truthTable_1 = __values(truthTable), truthTable_1_1 = truthTable_1.next(); !truthTable_1_1.done; truthTable_1_1 = truthTable_1.next()) {\n      var _b = __read(truthTable_1_1.value, 2),\n          stateSet = _b[0],\n          value = _b[1];\n\n      var lastNode = root; // itterate over each char of the state\n\n      for (var i = 0; i < stateSet.length - 1; i++) {\n        var level = i + 1;\n        var state = stateSet.charAt(i); // if node for this state-char not exists, add new one\n\n        if (!lastNode.branches.getBranch(state)) {\n          lastNode.branches.setBranch(state, new InternalNode(level, root, lastNode));\n        }\n\n        lastNode = lastNode.branches.getBranch(state);\n      } // last node is leaf-node\n\n\n      var lastState = lastChar(stateSet);\n\n      if (lastNode.branches.getBranch(lastState)) {\n        throw new Error('leafNode already exists, this should not happen');\n      }\n\n      lastNode.branches.setBranch(lastState, new LeafNode(stateSet.length, root, value, lastNode));\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (truthTable_1_1 && !truthTable_1_1.done && (_a = truthTable_1.return)) _a.call(truthTable_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n\n  return root;\n}","map":{"version":3,"sources":["../../src/create-bdd-from-truth-table.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAAS,QAAT,QAAyB,aAAzB;AACA,SAAS,QAAT,QAAyB,QAAzB;AACA,SAAS,YAAT,QAA6B,iBAA7B;AACA,SAAS,QAAT,QAAyB,aAAzB;AAGA,OAAM,SAAU,uBAAV,CACF,UADE,EACoB;;;AAEtB,MAAM,IAAI,GAAG,IAAI,QAAJ,EAAb;AAEA,MAAM,QAAQ,GAAG,UAAU,CAAC,IAAX,GAAkB,IAAlB,GAAyB,KAA1C;AACA,MAAM,SAAS,GAAG,QAAQ,CAAC,MAA3B;AACA,MAAM,UAAU,GAAG,IAAI,CAAC,GAAL,CAAS,CAAT,EAAY,SAAZ,CAAnB;;AACA,MAAI,UAAU,CAAC,IAAX,KAAoB,UAAxB,EAAoC;AAChC,UAAM,IAAI,KAAJ,CAAU,iCAAV,CAAN;AACH;;;AAGD,SAAgC,IAAA,YAAA,GAAA,QAAA,CAAA,UAAA,CAAA,EAAU,cAAA,GAAA,YAAA,CAAA,IAAA,EAA1C,EAA0C,CAAA,cAAA,CAAA,IAA1C,EAA0C,cAAA,GAAA,YAAA,CAAA,IAAA,EAA1C,EAA4C;AAAjC,UAAA,EAAA,GAAA,MAAA,CAAA,cAAA,CAAA,KAAA,EAAA,CAAA,CAAA;AAAA,UAAC,QAAA,GAAA,EAAA,CAAA,CAAA,CAAD;AAAA,UAAW,KAAA,GAAA,EAAA,CAAA,CAAA,CAAX;;AACP,UAAI,QAAQ,GAAgB,IAA5B,CADwC,CAGxC;;AACA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAI,QAAQ,CAAC,MAAT,GAAkB,CAAvC,EAA2C,CAAC,EAA5C,EAAgD;AAC5C,YAAM,KAAK,GAAG,CAAC,GAAG,CAAlB;AACA,YAAM,KAAK,GAAkB,QAAQ,CAAC,MAAT,CAAgB,CAAhB,CAA7B,CAF4C,CAI5C;;AACA,YAAI,CAAC,QAAQ,CAAC,QAAT,CAAkB,SAAlB,CAA4B,KAA5B,CAAL,EAAyC;AACrC,UAAA,QAAQ,CAAC,QAAT,CAAkB,SAAlB,CACI,KADJ,EAEI,IAAI,YAAJ,CACI,KADJ,EAEI,IAFJ,EAGI,QAHJ,CAFJ;AAQH;;AACD,QAAA,QAAQ,GAAG,QAAQ,CAAC,QAAT,CAAkB,SAAlB,CAA4B,KAA5B,CAAX;AACH,OApBuC,CAsBxC;;;AACA,UAAM,SAAS,GAAG,QAAQ,CAAC,QAAD,CAA1B;;AACA,UAAI,QAAQ,CAAC,QAAT,CAAkB,SAAlB,CAA4B,SAA5B,CAAJ,EAA4C;AACxC,cAAM,IAAI,KAAJ,CAAU,iDAAV,CAAN;AACH;;AACD,MAAA,QAAQ,CAAC,QAAT,CAAkB,SAAlB,CACI,SADJ,EAEI,IAAI,QAAJ,CACI,QAAQ,CAAC,MADb,EAEI,IAFJ,EAGI,KAHJ,EAII,QAJJ,CAFJ;AASH;;;;;;;;;;;;;AAED,SAAO,IAAP;AACH","sourceRoot":"","sourcesContent":["var __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nimport { RootNode } from './root-node';\nimport { lastChar } from './util';\nimport { InternalNode } from './internal-node';\nimport { LeafNode } from './leaf-node';\nexport function createBddFromTruthTable(truthTable) {\n    var e_1, _a;\n    var root = new RootNode();\n    var firstKey = truthTable.keys().next().value;\n    var keyLength = firstKey.length;\n    var mustBeSize = Math.pow(2, keyLength);\n    if (truthTable.size !== mustBeSize) {\n        throw new Error('truth table has missing entries');\n    }\n    try {\n        for (var truthTable_1 = __values(truthTable), truthTable_1_1 = truthTable_1.next(); !truthTable_1_1.done; truthTable_1_1 = truthTable_1.next()) {\n            var _b = __read(truthTable_1_1.value, 2), stateSet = _b[0], value = _b[1];\n            var lastNode = root;\n            // itterate over each char of the state\n            for (var i = 0; i < (stateSet.length - 1); i++) {\n                var level = i + 1;\n                var state = stateSet.charAt(i);\n                // if node for this state-char not exists, add new one\n                if (!lastNode.branches.getBranch(state)) {\n                    lastNode.branches.setBranch(state, new InternalNode(level, root, lastNode));\n                }\n                lastNode = lastNode.branches.getBranch(state);\n            }\n            // last node is leaf-node\n            var lastState = lastChar(stateSet);\n            if (lastNode.branches.getBranch(lastState)) {\n                throw new Error('leafNode already exists, this should not happen');\n            }\n            lastNode.branches.setBranch(lastState, new LeafNode(stateSet.length, root, value, lastNode));\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (truthTable_1_1 && !truthTable_1_1.done && (_a = truthTable_1.return)) _a.call(truthTable_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return root;\n}\n//# sourceMappingURL=create-bdd-from-truth-table.js.map"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { clone } from 'pouchdb-utils';\nimport { collate } from 'pouchdb-collate'; // this would just be \"return doc[field]\", but fields\n// can be \"deep\" due to dot notation\n\nfunction getFieldFromDoc(doc, parsedField) {\n  var value = doc;\n\n  for (var i = 0, len = parsedField.length; i < len; i++) {\n    var key = parsedField[i];\n    value = value[key];\n\n    if (!value) {\n      break;\n    }\n  }\n\n  return value;\n}\n\nfunction setFieldInDoc(doc, parsedField, value) {\n  for (var i = 0, len = parsedField.length; i < len - 1; i++) {\n    var elem = parsedField[i];\n    doc = doc[elem] = doc[elem] || {};\n  }\n\n  doc[parsedField[len - 1]] = value;\n}\n\nfunction compare(left, right) {\n  return left < right ? -1 : left > right ? 1 : 0;\n} // Converts a string in dot notation to an array of its components, with backslash escaping\n\n\nfunction parseField(fieldName) {\n  // fields may be deep (e.g. \"foo.bar.baz\"), so parse\n  var fields = [];\n  var current = '';\n\n  for (var i = 0, len = fieldName.length; i < len; i++) {\n    var ch = fieldName[i];\n\n    if (ch === '.') {\n      if (i > 0 && fieldName[i - 1] === '\\\\') {\n        // escaped delimiter\n        current = current.substring(0, current.length - 1) + '.';\n      } else {\n        // not escaped, so delimiter\n        fields.push(current);\n        current = '';\n      }\n    } else {\n      // normal character\n      current += ch;\n    }\n  }\n\n  fields.push(current);\n  return fields;\n}\n\nvar combinationFields = ['$or', '$nor', '$not'];\n\nfunction isCombinationalField(field) {\n  return combinationFields.indexOf(field) > -1;\n}\n\nfunction getKey(obj) {\n  return Object.keys(obj)[0];\n}\n\nfunction getValue(obj) {\n  return obj[getKey(obj)];\n} // flatten an array of selectors joined by an $and operator\n\n\nfunction mergeAndedSelectors(selectors) {\n  // sort to ensure that e.g. if the user specified\n  // $and: [{$gt: 'a'}, {$gt: 'b'}], then it's collapsed into\n  // just {$gt: 'b'}\n  var res = {};\n  selectors.forEach(function (selector) {\n    Object.keys(selector).forEach(function (field) {\n      var matcher = selector[field];\n\n      if (typeof matcher !== 'object') {\n        matcher = {\n          $eq: matcher\n        };\n      }\n\n      if (isCombinationalField(field)) {\n        if (matcher instanceof Array) {\n          res[field] = matcher.map(function (m) {\n            return mergeAndedSelectors([m]);\n          });\n        } else {\n          res[field] = mergeAndedSelectors([matcher]);\n        }\n      } else {\n        var fieldMatchers = res[field] = res[field] || {};\n        Object.keys(matcher).forEach(function (operator) {\n          var value = matcher[operator];\n\n          if (operator === '$gt' || operator === '$gte') {\n            return mergeGtGte(operator, value, fieldMatchers);\n          } else if (operator === '$lt' || operator === '$lte') {\n            return mergeLtLte(operator, value, fieldMatchers);\n          } else if (operator === '$ne') {\n            return mergeNe(value, fieldMatchers);\n          } else if (operator === '$eq') {\n            return mergeEq(value, fieldMatchers);\n          }\n\n          fieldMatchers[operator] = value;\n        });\n      }\n    });\n  });\n  return res;\n} // collapse logically equivalent gt/gte values\n\n\nfunction mergeGtGte(operator, value, fieldMatchers) {\n  if (typeof fieldMatchers.$eq !== 'undefined') {\n    return; // do nothing\n  }\n\n  if (typeof fieldMatchers.$gte !== 'undefined') {\n    if (operator === '$gte') {\n      if (value > fieldMatchers.$gte) {\n        // more specificity\n        fieldMatchers.$gte = value;\n      }\n    } else {\n      // operator === '$gt'\n      if (value >= fieldMatchers.$gte) {\n        // more specificity\n        delete fieldMatchers.$gte;\n        fieldMatchers.$gt = value;\n      }\n    }\n  } else if (typeof fieldMatchers.$gt !== 'undefined') {\n    if (operator === '$gte') {\n      if (value > fieldMatchers.$gt) {\n        // more specificity\n        delete fieldMatchers.$gt;\n        fieldMatchers.$gte = value;\n      }\n    } else {\n      // operator === '$gt'\n      if (value > fieldMatchers.$gt) {\n        // more specificity\n        fieldMatchers.$gt = value;\n      }\n    }\n  } else {\n    fieldMatchers[operator] = value;\n  }\n} // collapse logically equivalent lt/lte values\n\n\nfunction mergeLtLte(operator, value, fieldMatchers) {\n  if (typeof fieldMatchers.$eq !== 'undefined') {\n    return; // do nothing\n  }\n\n  if (typeof fieldMatchers.$lte !== 'undefined') {\n    if (operator === '$lte') {\n      if (value < fieldMatchers.$lte) {\n        // more specificity\n        fieldMatchers.$lte = value;\n      }\n    } else {\n      // operator === '$gt'\n      if (value <= fieldMatchers.$lte) {\n        // more specificity\n        delete fieldMatchers.$lte;\n        fieldMatchers.$lt = value;\n      }\n    }\n  } else if (typeof fieldMatchers.$lt !== 'undefined') {\n    if (operator === '$lte') {\n      if (value < fieldMatchers.$lt) {\n        // more specificity\n        delete fieldMatchers.$lt;\n        fieldMatchers.$lte = value;\n      }\n    } else {\n      // operator === '$gt'\n      if (value < fieldMatchers.$lt) {\n        // more specificity\n        fieldMatchers.$lt = value;\n      }\n    }\n  } else {\n    fieldMatchers[operator] = value;\n  }\n} // combine $ne values into one array\n\n\nfunction mergeNe(value, fieldMatchers) {\n  if ('$ne' in fieldMatchers) {\n    // there are many things this could \"not\" be\n    fieldMatchers.$ne.push(value);\n  } else {\n    // doesn't exist yet\n    fieldMatchers.$ne = [value];\n  }\n} // add $eq into the mix\n\n\nfunction mergeEq(value, fieldMatchers) {\n  // these all have less specificity than the $eq\n  // TODO: check for user errors here\n  delete fieldMatchers.$gt;\n  delete fieldMatchers.$gte;\n  delete fieldMatchers.$lt;\n  delete fieldMatchers.$lte;\n  delete fieldMatchers.$ne;\n  fieldMatchers.$eq = value;\n} //#7458: execute function mergeAndedSelectors on nested $and\n\n\nfunction mergeAndedSelectorsNested(obj) {\n  for (var prop in obj) {\n    if (Array.isArray(obj)) {\n      for (var i in obj) {\n        if (obj[i]['$and']) {\n          obj[i] = mergeAndedSelectors(obj[i]['$and']);\n        }\n      }\n    }\n\n    var value = obj[prop];\n\n    if (typeof value === 'object') {\n      mergeAndedSelectorsNested(value); // <- recursive call\n    }\n  }\n\n  return obj;\n} //#7458: determine id $and is present in selector (at any level)\n\n\nfunction isAndInSelector(obj, isAnd) {\n  for (var prop in obj) {\n    if (prop === '$and') {\n      isAnd = true;\n    }\n\n    var value = obj[prop];\n\n    if (typeof value === 'object') {\n      isAnd = isAndInSelector(value, isAnd); // <- recursive call\n    }\n  }\n\n  return isAnd;\n} //\n// normalize the selector\n//\n\n\nfunction massageSelector(input) {\n  var result = clone(input);\n  var wasAnded = false; //#7458: if $and is present in selector (at any level) merge nested $and\n\n  if (isAndInSelector(result, false)) {\n    result = mergeAndedSelectorsNested(result);\n\n    if ('$and' in result) {\n      result = mergeAndedSelectors(result['$and']);\n    }\n\n    wasAnded = true;\n  }\n\n  ['$or', '$nor'].forEach(function (orOrNor) {\n    if (orOrNor in result) {\n      // message each individual selector\n      // e.g. {foo: 'bar'} becomes {foo: {$eq: 'bar'}}\n      result[orOrNor].forEach(function (subSelector) {\n        var fields = Object.keys(subSelector);\n\n        for (var i = 0; i < fields.length; i++) {\n          var field = fields[i];\n          var matcher = subSelector[field];\n\n          if (typeof matcher !== 'object' || matcher === null) {\n            subSelector[field] = {\n              $eq: matcher\n            };\n          }\n        }\n      });\n    }\n  });\n\n  if ('$not' in result) {\n    //This feels a little like forcing, but it will work for now,\n    //I would like to come back to this and make the merging of selectors a little more generic\n    result['$not'] = mergeAndedSelectors([result['$not']]);\n  }\n\n  var fields = Object.keys(result);\n\n  for (var i = 0; i < fields.length; i++) {\n    var field = fields[i];\n    var matcher = result[field];\n\n    if (typeof matcher !== 'object' || matcher === null) {\n      matcher = {\n        $eq: matcher\n      };\n    } else if ('$ne' in matcher && !wasAnded) {\n      // I put these in an array, since there may be more than one\n      // but in the \"mergeAnded\" operation, I already take care of that\n      matcher.$ne = [matcher.$ne];\n    }\n\n    result[field] = matcher;\n  }\n\n  return result;\n} // create a comparator based on the sort object\n\n\nfunction createFieldSorter(sort) {\n  function getFieldValuesAsArray(doc) {\n    return sort.map(function (sorting) {\n      var fieldName = getKey(sorting);\n      var parsedField = parseField(fieldName);\n      var docFieldValue = getFieldFromDoc(doc, parsedField);\n      return docFieldValue;\n    });\n  }\n\n  return function (aRow, bRow) {\n    var aFieldValues = getFieldValuesAsArray(aRow.doc);\n    var bFieldValues = getFieldValuesAsArray(bRow.doc);\n    var collation = collate(aFieldValues, bFieldValues);\n\n    if (collation !== 0) {\n      return collation;\n    } // this is what mango seems to do\n\n\n    return compare(aRow.doc._id, bRow.doc._id);\n  };\n}\n\nfunction filterInMemoryFields(rows, requestDef, inMemoryFields) {\n  rows = rows.filter(function (row) {\n    return rowFilter(row.doc, requestDef.selector, inMemoryFields);\n  });\n\n  if (requestDef.sort) {\n    // in-memory sort\n    var fieldSorter = createFieldSorter(requestDef.sort);\n    rows = rows.sort(fieldSorter);\n\n    if (typeof requestDef.sort[0] !== 'string' && getValue(requestDef.sort[0]) === 'desc') {\n      rows = rows.reverse();\n    }\n  }\n\n  if ('limit' in requestDef || 'skip' in requestDef) {\n    // have to do the limit in-memory\n    var skip = requestDef.skip || 0;\n    var limit = ('limit' in requestDef ? requestDef.limit : rows.length) + skip;\n    rows = rows.slice(skip, limit);\n  }\n\n  return rows;\n}\n\nfunction rowFilter(doc, selector, inMemoryFields) {\n  return inMemoryFields.every(function (field) {\n    var matcher = selector[field];\n    var parsedField = parseField(field);\n    var docFieldValue = getFieldFromDoc(doc, parsedField);\n\n    if (isCombinationalField(field)) {\n      return matchCominationalSelector(field, matcher, doc);\n    }\n\n    return matchSelector(matcher, doc, parsedField, docFieldValue);\n  });\n}\n\nfunction matchSelector(matcher, doc, parsedField, docFieldValue) {\n  if (!matcher) {\n    // no filtering necessary; this field is just needed for sorting\n    return true;\n  } // is matcher an object, if so continue recursion\n\n\n  if (typeof matcher === 'object') {\n    return Object.keys(matcher).every(function (userOperator) {\n      var userValue = matcher[userOperator];\n      return match(userOperator, doc, userValue, parsedField, docFieldValue);\n    });\n  } // no more depth, No need to recurse further\n\n\n  return matcher === docFieldValue;\n}\n\nfunction matchCominationalSelector(field, matcher, doc) {\n  if (field === '$or') {\n    return matcher.some(function (orMatchers) {\n      return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n    });\n  }\n\n  if (field === '$not') {\n    return !rowFilter(doc, matcher, Object.keys(matcher));\n  } //`$nor`\n\n\n  return !matcher.find(function (orMatchers) {\n    return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n  });\n}\n\nfunction match(userOperator, doc, userValue, parsedField, docFieldValue) {\n  if (!matchers[userOperator]) {\n    throw new Error('unknown operator \"' + userOperator + '\" - should be one of $eq, $lte, $lt, $gt, $gte, $exists, $ne, $in, ' + '$nin, $size, $mod, $regex, $elemMatch, $type, $allMatch or $all');\n  }\n\n  return matchers[userOperator](doc, userValue, parsedField, docFieldValue);\n}\n\nfunction fieldExists(docFieldValue) {\n  return typeof docFieldValue !== 'undefined' && docFieldValue !== null;\n}\n\nfunction fieldIsNotUndefined(docFieldValue) {\n  return typeof docFieldValue !== 'undefined';\n}\n\nfunction modField(docFieldValue, userValue) {\n  var divisor = userValue[0];\n  var mod = userValue[1];\n\n  if (divisor === 0) {\n    throw new Error('Bad divisor, cannot divide by zero');\n  }\n\n  if (parseInt(divisor, 10) !== divisor) {\n    throw new Error('Divisor is not an integer');\n  }\n\n  if (parseInt(mod, 10) !== mod) {\n    throw new Error('Modulus is not an integer');\n  }\n\n  if (parseInt(docFieldValue, 10) !== docFieldValue) {\n    return false;\n  }\n\n  return docFieldValue % divisor === mod;\n}\n\nfunction arrayContainsValue(docFieldValue, userValue) {\n  return userValue.some(function (val) {\n    if (docFieldValue instanceof Array) {\n      return docFieldValue.indexOf(val) > -1;\n    }\n\n    return docFieldValue === val;\n  });\n}\n\nfunction arrayContainsAllValues(docFieldValue, userValue) {\n  return userValue.every(function (val) {\n    return docFieldValue.indexOf(val) > -1;\n  });\n}\n\nfunction arraySize(docFieldValue, userValue) {\n  return docFieldValue.length === userValue;\n}\n\nfunction regexMatch(docFieldValue, userValue) {\n  var re = new RegExp(userValue);\n  return re.test(docFieldValue);\n}\n\nfunction typeMatch(docFieldValue, userValue) {\n  switch (userValue) {\n    case 'null':\n      return docFieldValue === null;\n\n    case 'boolean':\n      return typeof docFieldValue === 'boolean';\n\n    case 'number':\n      return typeof docFieldValue === 'number';\n\n    case 'string':\n      return typeof docFieldValue === 'string';\n\n    case 'array':\n      return docFieldValue instanceof Array;\n\n    case 'object':\n      return {}.toString.call(docFieldValue) === '[object Object]';\n  }\n\n  throw new Error(userValue + ' not supported as a type.' + 'Please use one of object, string, array, number, boolean or null.');\n}\n\nvar matchers = {\n  '$elemMatch': function $elemMatch(doc, userValue, parsedField, docFieldValue) {\n    if (!Array.isArray(docFieldValue)) {\n      return false;\n    }\n\n    if (docFieldValue.length === 0) {\n      return false;\n    }\n\n    if (typeof docFieldValue[0] === 'object') {\n      return docFieldValue.some(function (val) {\n        return rowFilter(val, userValue, Object.keys(userValue));\n      });\n    }\n\n    return docFieldValue.some(function (val) {\n      return matchSelector(userValue, doc, parsedField, val);\n    });\n  },\n  '$allMatch': function $allMatch(doc, userValue, parsedField, docFieldValue) {\n    if (!Array.isArray(docFieldValue)) {\n      return false;\n    }\n    /* istanbul ignore next */\n\n\n    if (docFieldValue.length === 0) {\n      return false;\n    }\n\n    if (typeof docFieldValue[0] === 'object') {\n      return docFieldValue.every(function (val) {\n        return rowFilter(val, userValue, Object.keys(userValue));\n      });\n    }\n\n    return docFieldValue.every(function (val) {\n      return matchSelector(userValue, doc, parsedField, val);\n    });\n  },\n  '$eq': function $eq(doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) === 0;\n  },\n  '$gte': function $gte(doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) >= 0;\n  },\n  '$gt': function $gt(doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) > 0;\n  },\n  '$lte': function $lte(doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) <= 0;\n  },\n  '$lt': function $lt(doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) < 0;\n  },\n  '$exists': function $exists(doc, userValue, parsedField, docFieldValue) {\n    //a field that is null is still considered to exist\n    if (userValue) {\n      return fieldIsNotUndefined(docFieldValue);\n    }\n\n    return !fieldIsNotUndefined(docFieldValue);\n  },\n  '$mod': function $mod(doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && modField(docFieldValue, userValue);\n  },\n  '$ne': function $ne(doc, userValue, parsedField, docFieldValue) {\n    return userValue.every(function (neValue) {\n      return collate(docFieldValue, neValue) !== 0;\n    });\n  },\n  '$in': function $in(doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && arrayContainsValue(docFieldValue, userValue);\n  },\n  '$nin': function $nin(doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && !arrayContainsValue(docFieldValue, userValue);\n  },\n  '$size': function $size(doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && arraySize(docFieldValue, userValue);\n  },\n  '$all': function $all(doc, userValue, parsedField, docFieldValue) {\n    return Array.isArray(docFieldValue) && arrayContainsAllValues(docFieldValue, userValue);\n  },\n  '$regex': function $regex(doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && regexMatch(docFieldValue, userValue);\n  },\n  '$type': function $type(doc, userValue, parsedField, docFieldValue) {\n    return typeMatch(docFieldValue, userValue);\n  }\n}; // return true if the given doc matches the supplied selector\n\nfunction matchesSelector(doc, selector) {\n  /* istanbul ignore if */\n  if (typeof selector !== 'object') {\n    // match the CouchDB error message\n    throw new Error('Selector error: expected a JSON object');\n  }\n\n  selector = massageSelector(selector);\n  var row = {\n    'doc': doc\n  };\n  var rowsMatched = filterInMemoryFields([row], {\n    'selector': selector\n  }, Object.keys(selector));\n  return rowsMatched && rowsMatched.length === 1;\n}\n\nexport { massageSelector, matchesSelector, filterInMemoryFields, createFieldSorter, rowFilter, isCombinationalField, getKey, getValue, getFieldFromDoc, setFieldInDoc, compare, parseField };","map":{"version":3,"sources":["/Users/Hanzalah/Desktop/github/todo-offline/rxdb-hasura-demo/node_modules/pouchdb-selector-core/lib/index.es.js"],"names":["clone","collate","getFieldFromDoc","doc","parsedField","value","i","len","length","key","setFieldInDoc","elem","compare","left","right","parseField","fieldName","fields","current","ch","substring","push","combinationFields","isCombinationalField","field","indexOf","getKey","obj","Object","keys","getValue","mergeAndedSelectors","selectors","res","forEach","selector","matcher","$eq","Array","map","m","fieldMatchers","operator","mergeGtGte","mergeLtLte","mergeNe","mergeEq","$gte","$gt","$lte","$lt","$ne","mergeAndedSelectorsNested","prop","isArray","isAndInSelector","isAnd","massageSelector","input","result","wasAnded","orOrNor","subSelector","createFieldSorter","sort","getFieldValuesAsArray","sorting","docFieldValue","aRow","bRow","aFieldValues","bFieldValues","collation","_id","filterInMemoryFields","rows","requestDef","inMemoryFields","filter","row","rowFilter","fieldSorter","reverse","skip","limit","slice","every","matchCominationalSelector","matchSelector","userOperator","userValue","match","some","orMatchers","find","matchers","Error","fieldExists","fieldIsNotUndefined","modField","divisor","mod","parseInt","arrayContainsValue","val","arrayContainsAllValues","arraySize","regexMatch","re","RegExp","test","typeMatch","toString","call","neValue","matchesSelector","rowsMatched"],"mappings":"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","sourcesContent":["import { clone } from 'pouchdb-utils';\nimport { collate } from 'pouchdb-collate';\n\n// this would just be \"return doc[field]\", but fields\n// can be \"deep\" due to dot notation\nfunction getFieldFromDoc(doc, parsedField) {\n  var value = doc;\n  for (var i = 0, len = parsedField.length; i < len; i++) {\n    var key = parsedField[i];\n    value = value[key];\n    if (!value) {\n      break;\n    }\n  }\n  return value;\n}\n\nfunction setFieldInDoc(doc, parsedField, value) {\n  for (var i = 0, len = parsedField.length; i < len-1; i++) {\n    var elem = parsedField[i];\n    doc = doc[elem] = doc[elem] || {};\n  }\n  doc[parsedField[len-1]] = value;\n}\n\nfunction compare(left, right) {\n  return left < right ? -1 : left > right ? 1 : 0;\n}\n\n// Converts a string in dot notation to an array of its components, with backslash escaping\nfunction parseField(fieldName) {\n  // fields may be deep (e.g. \"foo.bar.baz\"), so parse\n  var fields = [];\n  var current = '';\n  for (var i = 0, len = fieldName.length; i < len; i++) {\n    var ch = fieldName[i];\n    if (ch === '.') {\n      if (i > 0 && fieldName[i - 1] === '\\\\') { // escaped delimiter\n        current = current.substring(0, current.length - 1) + '.';\n      } else { // not escaped, so delimiter\n        fields.push(current);\n        current = '';\n      }\n    } else { // normal character\n      current += ch;\n    }\n  }\n  fields.push(current);\n  return fields;\n}\n\nvar combinationFields = ['$or', '$nor', '$not'];\nfunction isCombinationalField(field) {\n  return combinationFields.indexOf(field) > -1;\n}\n\nfunction getKey(obj) {\n  return Object.keys(obj)[0];\n}\n\nfunction getValue(obj) {\n  return obj[getKey(obj)];\n}\n\n\n// flatten an array of selectors joined by an $and operator\nfunction mergeAndedSelectors(selectors) {\n\n  // sort to ensure that e.g. if the user specified\n  // $and: [{$gt: 'a'}, {$gt: 'b'}], then it's collapsed into\n  // just {$gt: 'b'}\n  var res = {};\n\n  selectors.forEach(function (selector) {\n    Object.keys(selector).forEach(function (field) {\n      var matcher = selector[field];\n      if (typeof matcher !== 'object') {\n        matcher = {$eq: matcher};\n      }\n\n      if (isCombinationalField(field)) {\n        if (matcher instanceof Array) {\n          res[field] = matcher.map(function (m) {\n            return mergeAndedSelectors([m]);\n          });\n        } else {\n          res[field] = mergeAndedSelectors([matcher]);\n        }\n      } else {\n        var fieldMatchers = res[field] = res[field] || {};\n        Object.keys(matcher).forEach(function (operator) {\n          var value = matcher[operator];\n\n          if (operator === '$gt' || operator === '$gte') {\n            return mergeGtGte(operator, value, fieldMatchers);\n          } else if (operator === '$lt' || operator === '$lte') {\n            return mergeLtLte(operator, value, fieldMatchers);\n          } else if (operator === '$ne') {\n            return mergeNe(value, fieldMatchers);\n          } else if (operator === '$eq') {\n            return mergeEq(value, fieldMatchers);\n          }\n          fieldMatchers[operator] = value;\n        });\n      }\n    });\n  });\n\n  return res;\n}\n\n\n\n// collapse logically equivalent gt/gte values\nfunction mergeGtGte(operator, value, fieldMatchers) {\n  if (typeof fieldMatchers.$eq !== 'undefined') {\n    return; // do nothing\n  }\n  if (typeof fieldMatchers.$gte !== 'undefined') {\n    if (operator === '$gte') {\n      if (value > fieldMatchers.$gte) { // more specificity\n        fieldMatchers.$gte = value;\n      }\n    } else { // operator === '$gt'\n      if (value >= fieldMatchers.$gte) { // more specificity\n        delete fieldMatchers.$gte;\n        fieldMatchers.$gt = value;\n      }\n    }\n  } else if (typeof fieldMatchers.$gt !== 'undefined') {\n    if (operator === '$gte') {\n      if (value > fieldMatchers.$gt) { // more specificity\n        delete fieldMatchers.$gt;\n        fieldMatchers.$gte = value;\n      }\n    } else { // operator === '$gt'\n      if (value > fieldMatchers.$gt) { // more specificity\n        fieldMatchers.$gt = value;\n      }\n    }\n  } else {\n    fieldMatchers[operator] = value;\n  }\n}\n\n// collapse logically equivalent lt/lte values\nfunction mergeLtLte(operator, value, fieldMatchers) {\n  if (typeof fieldMatchers.$eq !== 'undefined') {\n    return; // do nothing\n  }\n  if (typeof fieldMatchers.$lte !== 'undefined') {\n    if (operator === '$lte') {\n      if (value < fieldMatchers.$lte) { // more specificity\n        fieldMatchers.$lte = value;\n      }\n    } else { // operator === '$gt'\n      if (value <= fieldMatchers.$lte) { // more specificity\n        delete fieldMatchers.$lte;\n        fieldMatchers.$lt = value;\n      }\n    }\n  } else if (typeof fieldMatchers.$lt !== 'undefined') {\n    if (operator === '$lte') {\n      if (value < fieldMatchers.$lt) { // more specificity\n        delete fieldMatchers.$lt;\n        fieldMatchers.$lte = value;\n      }\n    } else { // operator === '$gt'\n      if (value < fieldMatchers.$lt) { // more specificity\n        fieldMatchers.$lt = value;\n      }\n    }\n  } else {\n    fieldMatchers[operator] = value;\n  }\n}\n\n// combine $ne values into one array\nfunction mergeNe(value, fieldMatchers) {\n  if ('$ne' in fieldMatchers) {\n    // there are many things this could \"not\" be\n    fieldMatchers.$ne.push(value);\n  } else { // doesn't exist yet\n    fieldMatchers.$ne = [value];\n  }\n}\n\n// add $eq into the mix\nfunction mergeEq(value, fieldMatchers) {\n  // these all have less specificity than the $eq\n  // TODO: check for user errors here\n  delete fieldMatchers.$gt;\n  delete fieldMatchers.$gte;\n  delete fieldMatchers.$lt;\n  delete fieldMatchers.$lte;\n  delete fieldMatchers.$ne;\n  fieldMatchers.$eq = value;\n}\n\n//#7458: execute function mergeAndedSelectors on nested $and\nfunction mergeAndedSelectorsNested(obj) {\n    for (var prop in obj) {\n        if (Array.isArray(obj)) {\n            for (var i in obj) {\n                if (obj[i]['$and']) {\n                    obj[i] = mergeAndedSelectors(obj[i]['$and']);\n                }\n            }\n        }\n        var value = obj[prop];\n        if (typeof value === 'object') {\n            mergeAndedSelectorsNested(value); // <- recursive call\n        }\n    }\n    return obj;\n}\n\n//#7458: determine id $and is present in selector (at any level)\nfunction isAndInSelector(obj, isAnd) {\n    for (var prop in obj) {\n        if (prop === '$and') {\n            isAnd = true;\n        }\n        var value = obj[prop];\n        if (typeof value === 'object') {\n            isAnd = isAndInSelector(value, isAnd); // <- recursive call\n        }\n    }\n    return isAnd;\n}\n\n//\n// normalize the selector\n//\nfunction massageSelector(input) {\n  var result = clone(input);\n  var wasAnded = false;\n    //#7458: if $and is present in selector (at any level) merge nested $and\n    if (isAndInSelector(result, false)) {\n        result = mergeAndedSelectorsNested(result);\n        if ('$and' in result) {\n            result = mergeAndedSelectors(result['$and']);\n        }\n        wasAnded = true;\n    }\n\n  ['$or', '$nor'].forEach(function (orOrNor) {\n    if (orOrNor in result) {\n      // message each individual selector\n      // e.g. {foo: 'bar'} becomes {foo: {$eq: 'bar'}}\n      result[orOrNor].forEach(function (subSelector) {\n        var fields = Object.keys(subSelector);\n        for (var i = 0; i < fields.length; i++) {\n          var field = fields[i];\n          var matcher = subSelector[field];\n          if (typeof matcher !== 'object' || matcher === null) {\n            subSelector[field] = {$eq: matcher};\n          }\n        }\n      });\n    }\n  });\n\n  if ('$not' in result) {\n    //This feels a little like forcing, but it will work for now,\n    //I would like to come back to this and make the merging of selectors a little more generic\n    result['$not'] = mergeAndedSelectors([result['$not']]);\n  }\n\n  var fields = Object.keys(result);\n\n  for (var i = 0; i < fields.length; i++) {\n    var field = fields[i];\n    var matcher = result[field];\n\n    if (typeof matcher !== 'object' || matcher === null) {\n      matcher = {$eq: matcher};\n    } else if ('$ne' in matcher && !wasAnded) {\n      // I put these in an array, since there may be more than one\n      // but in the \"mergeAnded\" operation, I already take care of that\n      matcher.$ne = [matcher.$ne];\n    }\n    result[field] = matcher;\n  }\n\n  return result;\n}\n\n// create a comparator based on the sort object\nfunction createFieldSorter(sort) {\n\n  function getFieldValuesAsArray(doc) {\n    return sort.map(function (sorting) {\n      var fieldName = getKey(sorting);\n      var parsedField = parseField(fieldName);\n      var docFieldValue = getFieldFromDoc(doc, parsedField);\n      return docFieldValue;\n    });\n  }\n\n  return function (aRow, bRow) {\n    var aFieldValues = getFieldValuesAsArray(aRow.doc);\n    var bFieldValues = getFieldValuesAsArray(bRow.doc);\n    var collation = collate(aFieldValues, bFieldValues);\n    if (collation !== 0) {\n      return collation;\n    }\n    // this is what mango seems to do\n    return compare(aRow.doc._id, bRow.doc._id);\n  };\n}\n\nfunction filterInMemoryFields(rows, requestDef, inMemoryFields) {\n  rows = rows.filter(function (row) {\n    return rowFilter(row.doc, requestDef.selector, inMemoryFields);\n  });\n\n  if (requestDef.sort) {\n    // in-memory sort\n    var fieldSorter = createFieldSorter(requestDef.sort);\n    rows = rows.sort(fieldSorter);\n    if (typeof requestDef.sort[0] !== 'string' &&\n        getValue(requestDef.sort[0]) === 'desc') {\n      rows = rows.reverse();\n    }\n  }\n\n  if ('limit' in requestDef || 'skip' in requestDef) {\n    // have to do the limit in-memory\n    var skip = requestDef.skip || 0;\n    var limit = ('limit' in requestDef ? requestDef.limit : rows.length) + skip;\n    rows = rows.slice(skip, limit);\n  }\n  return rows;\n}\n\nfunction rowFilter(doc, selector, inMemoryFields) {\n  return inMemoryFields.every(function (field) {\n    var matcher = selector[field];\n    var parsedField = parseField(field);\n    var docFieldValue = getFieldFromDoc(doc, parsedField);\n    if (isCombinationalField(field)) {\n      return matchCominationalSelector(field, matcher, doc);\n    }\n\n    return matchSelector(matcher, doc, parsedField, docFieldValue);\n  });\n}\n\nfunction matchSelector(matcher, doc, parsedField, docFieldValue) {\n  if (!matcher) {\n    // no filtering necessary; this field is just needed for sorting\n    return true;\n  }\n\n  // is matcher an object, if so continue recursion\n  if (typeof matcher === 'object') {\n    return Object.keys(matcher).every(function (userOperator) {\n      var userValue = matcher[userOperator];\n      return match(userOperator, doc, userValue, parsedField, docFieldValue);\n    });\n  }\n\n  // no more depth, No need to recurse further\n  return matcher === docFieldValue;\n}\n\nfunction matchCominationalSelector(field, matcher, doc) {\n\n  if (field === '$or') {\n    return matcher.some(function (orMatchers) {\n      return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n    });\n  }\n\n  if (field === '$not') {\n    return !rowFilter(doc, matcher, Object.keys(matcher));\n  }\n\n  //`$nor`\n  return !matcher.find(function (orMatchers) {\n    return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n  });\n\n}\n\nfunction match(userOperator, doc, userValue, parsedField, docFieldValue) {\n  if (!matchers[userOperator]) {\n    throw new Error('unknown operator \"' + userOperator +\n      '\" - should be one of $eq, $lte, $lt, $gt, $gte, $exists, $ne, $in, ' +\n      '$nin, $size, $mod, $regex, $elemMatch, $type, $allMatch or $all');\n  }\n  return matchers[userOperator](doc, userValue, parsedField, docFieldValue);\n}\n\nfunction fieldExists(docFieldValue) {\n  return typeof docFieldValue !== 'undefined' && docFieldValue !== null;\n}\n\nfunction fieldIsNotUndefined(docFieldValue) {\n  return typeof docFieldValue !== 'undefined';\n}\n\nfunction modField(docFieldValue, userValue) {\n  var divisor = userValue[0];\n  var mod = userValue[1];\n  if (divisor === 0) {\n    throw new Error('Bad divisor, cannot divide by zero');\n  }\n\n  if (parseInt(divisor, 10) !== divisor ) {\n    throw new Error('Divisor is not an integer');\n  }\n\n  if (parseInt(mod, 10) !== mod ) {\n    throw new Error('Modulus is not an integer');\n  }\n\n  if (parseInt(docFieldValue, 10) !== docFieldValue) {\n    return false;\n  }\n\n  return docFieldValue % divisor === mod;\n}\n\nfunction arrayContainsValue(docFieldValue, userValue) {\n  return userValue.some(function (val) {\n    if (docFieldValue instanceof Array) {\n      return docFieldValue.indexOf(val) > -1;\n    }\n\n    return docFieldValue === val;\n  });\n}\n\nfunction arrayContainsAllValues(docFieldValue, userValue) {\n  return userValue.every(function (val) {\n    return docFieldValue.indexOf(val) > -1;\n  });\n}\n\nfunction arraySize(docFieldValue, userValue) {\n  return docFieldValue.length === userValue;\n}\n\nfunction regexMatch(docFieldValue, userValue) {\n  var re = new RegExp(userValue);\n\n  return re.test(docFieldValue);\n}\n\nfunction typeMatch(docFieldValue, userValue) {\n\n  switch (userValue) {\n    case 'null':\n      return docFieldValue === null;\n    case 'boolean':\n      return typeof (docFieldValue) === 'boolean';\n    case 'number':\n      return typeof (docFieldValue) === 'number';\n    case 'string':\n      return typeof (docFieldValue) === 'string';\n    case 'array':\n      return docFieldValue instanceof Array;\n    case 'object':\n      return ({}).toString.call(docFieldValue) === '[object Object]';\n  }\n\n  throw new Error(userValue + ' not supported as a type.' +\n                  'Please use one of object, string, array, number, boolean or null.');\n\n}\n\nvar matchers = {\n\n  '$elemMatch': function (doc, userValue, parsedField, docFieldValue) {\n    if (!Array.isArray(docFieldValue)) {\n      return false;\n    }\n\n    if (docFieldValue.length === 0) {\n      return false;\n    }\n\n    if (typeof docFieldValue[0] === 'object') {\n      return docFieldValue.some(function (val) {\n        return rowFilter(val, userValue, Object.keys(userValue));\n      });\n    }\n\n    return docFieldValue.some(function (val) {\n      return matchSelector(userValue, doc, parsedField, val);\n    });\n  },\n\n  '$allMatch': function (doc, userValue, parsedField, docFieldValue) {\n    if (!Array.isArray(docFieldValue)) {\n      return false;\n    }\n\n    /* istanbul ignore next */\n    if (docFieldValue.length === 0) {\n      return false;\n    }\n\n    if (typeof docFieldValue[0] === 'object') {\n      return docFieldValue.every(function (val) {\n        return rowFilter(val, userValue, Object.keys(userValue));\n      });\n    }\n\n    return docFieldValue.every(function (val) {\n      return matchSelector(userValue, doc, parsedField, val);\n    });\n  },\n\n  '$eq': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) === 0;\n  },\n\n  '$gte': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) >= 0;\n  },\n\n  '$gt': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) > 0;\n  },\n\n  '$lte': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) <= 0;\n  },\n\n  '$lt': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) < 0;\n  },\n\n  '$exists': function (doc, userValue, parsedField, docFieldValue) {\n    //a field that is null is still considered to exist\n    if (userValue) {\n      return fieldIsNotUndefined(docFieldValue);\n    }\n\n    return !fieldIsNotUndefined(docFieldValue);\n  },\n\n  '$mod': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && modField(docFieldValue, userValue);\n  },\n\n  '$ne': function (doc, userValue, parsedField, docFieldValue) {\n    return userValue.every(function (neValue) {\n      return collate(docFieldValue, neValue) !== 0;\n    });\n  },\n  '$in': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && arrayContainsValue(docFieldValue, userValue);\n  },\n\n  '$nin': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && !arrayContainsValue(docFieldValue, userValue);\n  },\n\n  '$size': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && arraySize(docFieldValue, userValue);\n  },\n\n  '$all': function (doc, userValue, parsedField, docFieldValue) {\n    return Array.isArray(docFieldValue) && arrayContainsAllValues(docFieldValue, userValue);\n  },\n\n  '$regex': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && regexMatch(docFieldValue, userValue);\n  },\n\n  '$type': function (doc, userValue, parsedField, docFieldValue) {\n    return typeMatch(docFieldValue, userValue);\n  }\n};\n\n// return true if the given doc matches the supplied selector\nfunction matchesSelector(doc, selector) {\n  /* istanbul ignore if */\n  if (typeof selector !== 'object') {\n    // match the CouchDB error message\n    throw new Error('Selector error: expected a JSON object');\n  }\n\n  selector = massageSelector(selector);\n  var row = {\n    'doc': doc\n  };\n\n  var rowsMatched = filterInMemoryFields([row], { 'selector': selector }, Object.keys(selector));\n  return rowsMatched && rowsMatched.length === 1;\n}\n\nexport { massageSelector, matchesSelector, filterInMemoryFields, createFieldSorter, rowFilter, isCombinationalField, getKey, getValue, getFieldFromDoc, setFieldInDoc, compare, parseField };\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { nextNodeId } from './util';\nimport { findSimilarNode } from './find-similar-node';\n\nvar AbstractNode =\n/** @class */\nfunction () {\n  function AbstractNode(level, rootNode, type) {\n    this.level = level;\n    this.id = nextNodeId();\n    this.deleted = false;\n    this.type = type;\n    this.rootNode = rootNode;\n\n    if (rootNode) {\n      this.rootNode.addNode(this);\n    }\n  }\n\n  AbstractNode.prototype.isEqualToOtherNode = function (otherNode, // optimisation shortcut, is faster if own string already known\n  ownString) {\n    if (ownString === void 0) {\n      ownString = this.toString();\n    }\n\n    var ret = ownString === otherNode.toString();\n    return ret;\n  }; // deletes the whole node\n\n\n  AbstractNode.prototype.remove = function () {\n    this.ensureNotDeleted('remove'); // console.log('AbstractNode().remove() node: ' + this.id);\n    // console.log(this.toJSON(true));\n\n    if (this.isInternalNode()) {\n      var useNode = this;\n\n      if (useNode.parents.size > 0) {\n        throw new Error('cannot remove node with parents ' + this.id);\n      }\n    }\n\n    if (this.branches) {\n      var useNode = this;\n\n      if (useNode.branches.areBranchesStrictEqual()) {\n        useNode.branches.getBranch('0').parents.remove(useNode);\n      } else {\n        useNode.branches.getBranch('0').parents.remove(useNode);\n        useNode.branches.getBranch('1').parents.remove(useNode);\n      }\n    }\n\n    this.deleted = true;\n    this.rootNode.removeNode(this);\n  };\n\n  AbstractNode.prototype.toJSON = function (withId) {\n    if (withId === void 0) {\n      withId = false;\n    }\n\n    var ret = {\n      id: withId ? this.id : undefined,\n      deleted: withId ? this.deleted : undefined,\n      type: this.type,\n      level: this.level\n    };\n\n    if (withId && this.parents) {\n      ret.parents = this.parents.toString();\n    }\n\n    if (this.isLeafNode()) {\n      ret.value = this.asLeafNode().value;\n    }\n\n    if (this.branches && !this.branches.deleted) {\n      var branches = this.branches;\n      ret.branches = {\n        '0': branches.getBranch('0').toJSON(withId),\n        '1': branches.getBranch('1').toJSON(withId)\n      };\n    }\n\n    return ret;\n  }; // a strange string-representation\n  // to make an equal check between nodes\n\n\n  AbstractNode.prototype.toString = function () {\n    var ret = '' + '<' + this.type + ':' + this.level;\n\n    if (this.branches) {\n      var branches = this.branches;\n      ret += '|0:' + branches.getBranch('0');\n      ret += '|1:' + branches.getBranch('1');\n    }\n\n    if (this.isLeafNode()) {\n      ret += '|v:' + this.asLeafNode().value;\n    }\n\n    ret += '>';\n    return ret;\n  };\n\n  AbstractNode.prototype.isRootNode = function () {\n    return this.type === 'RootNode';\n  };\n\n  AbstractNode.prototype.isInternalNode = function () {\n    return this.type === 'InternalNode';\n  };\n\n  AbstractNode.prototype.isLeafNode = function () {\n    return this.type === 'LeafNode';\n  };\n\n  AbstractNode.prototype.asRootNode = function () {\n    if (!this.isRootNode()) {\n      throw new Error('ouch');\n    }\n\n    return this;\n  };\n\n  AbstractNode.prototype.asInternalNode = function () {\n    if (!this.isInternalNode()) {\n      throw new Error('ouch');\n    }\n\n    return this;\n  };\n\n  AbstractNode.prototype.asLeafNode = function () {\n    if (!this.isLeafNode()) {\n      throw new Error('ouch');\n    }\n\n    return this;\n  };\n\n  AbstractNode.prototype.ensureNotDeleted = function (op) {\n    if (op === void 0) {\n      op = 'unknown';\n    }\n\n    if (this.deleted) {\n      throw new Error('forbidden operation ' + op + ' on deleted node ' + this.id);\n    }\n  };\n\n  AbstractNode.prototype.log = function () {\n    console.log(JSON.stringify(this.toJSON(true), null, 2));\n  };\n  /**\n  * by the elimination-rule of bdd,\n  * if two branches of the same level are equal,\n  * one can be removed\n  *\n  * See page 21 at:\n  * @link https://people.eecs.berkeley.edu/~sseshia/219c/lectures/BinaryDecisionDiagrams.pdf\n  */\n\n\n  AbstractNode.prototype.applyEliminationRule = function ( // can be provided for better performance\n  nodesOfSameLevel) {\n    var _this = this;\n\n    this.ensureNotDeleted('applyEliminationRule');\n\n    if (!nodesOfSameLevel) {\n      nodesOfSameLevel = this.rootNode.getNodesOfLevel(this.level);\n    }\n\n    var other = findSimilarNode(this, nodesOfSameLevel);\n\n    if (other) {\n      // console.log('applyEliminationRule() remove:' + this.id + '; other: ' + other.id);\n      // keep 'other', remove 'this'\n      // move own parents to other\n      var ownParents = this.parents.getAll();\n      var parentsWithStrictEqualBranches_1 = [];\n      ownParents.forEach(function (parent) {\n        // console.log('ownParent: ' + parent.id);\n        var branchKey = parent.branches.getKeyOfNode(_this); // console.log('branchKey: ' + branchKey);\n\n        parent.branches.setBranch(branchKey, other);\n\n        if (parent.branches.areBranchesStrictEqual()) {\n          parentsWithStrictEqualBranches_1.push(parent);\n        } // remove parents from own list\n        // this will auto-remove the connection to the other '1'-branch\n\n\n        _this.parents.remove(parent);\n      }); // parents that now have equal branches, must be removed again\n\n      parentsWithStrictEqualBranches_1.forEach(function (node) {\n        if (node.isInternalNode()) {\n          // console.log('trigger applyReductionRule from applyEliminationRule');\n          node.applyReductionRule();\n        }\n      });\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  return AbstractNode;\n}();\n\nexport { AbstractNode };","map":{"version":3,"sources":["../../src/abstract-node.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { nextNodeId } from './util';\nimport { findSimilarNode } from './find-similar-node';\nvar AbstractNode = /** @class */ (function () {\n    function AbstractNode(level, rootNode, type) {\n        this.level = level;\n        this.id = nextNodeId();\n        this.deleted = false;\n        this.type = type;\n        this.rootNode = rootNode;\n        if (rootNode) {\n            this.rootNode.addNode(this);\n        }\n    }\n    AbstractNode.prototype.isEqualToOtherNode = function (otherNode, \n    // optimisation shortcut, is faster if own string already known\n    ownString) {\n        if (ownString === void 0) { ownString = this.toString(); }\n        var ret = ownString === otherNode.toString();\n        return ret;\n    };\n    // deletes the whole node\n    AbstractNode.prototype.remove = function () {\n        this.ensureNotDeleted('remove');\n        // console.log('AbstractNode().remove() node: ' + this.id);\n        // console.log(this.toJSON(true));\n        if (this.isInternalNode()) {\n            var useNode = this;\n            if (useNode.parents.size > 0) {\n                throw new Error('cannot remove node with parents ' + this.id);\n            }\n        }\n        if (this.branches) {\n            var useNode = this;\n            if (useNode.branches.areBranchesStrictEqual()) {\n                useNode.branches.getBranch('0').parents.remove(useNode);\n            }\n            else {\n                useNode.branches.getBranch('0').parents.remove(useNode);\n                useNode.branches.getBranch('1').parents.remove(useNode);\n            }\n        }\n        this.deleted = true;\n        this.rootNode.removeNode(this);\n    };\n    AbstractNode.prototype.toJSON = function (withId) {\n        if (withId === void 0) { withId = false; }\n        var ret = {\n            id: withId ? this.id : undefined,\n            deleted: withId ? this.deleted : undefined,\n            type: this.type,\n            level: this.level\n        };\n        if (withId && this.parents) {\n            ret.parents = this.parents.toString();\n        }\n        if (this.isLeafNode()) {\n            ret.value = this.asLeafNode().value;\n        }\n        if (this.branches && !this.branches.deleted) {\n            var branches = this.branches;\n            ret.branches = {\n                '0': branches.getBranch('0').toJSON(withId),\n                '1': branches.getBranch('1').toJSON(withId)\n            };\n        }\n        return ret;\n    };\n    // a strange string-representation\n    // to make an equal check between nodes\n    AbstractNode.prototype.toString = function () {\n        var ret = '' +\n            '<' +\n            this.type + ':' + this.level;\n        if (this.branches) {\n            var branches = this.branches;\n            ret += '|0:' + branches.getBranch('0');\n            ret += '|1:' + branches.getBranch('1');\n        }\n        if (this.isLeafNode()) {\n            ret += '|v:' + this.asLeafNode().value;\n        }\n        ret += '>';\n        return ret;\n    };\n    AbstractNode.prototype.isRootNode = function () {\n        return this.type === 'RootNode';\n    };\n    AbstractNode.prototype.isInternalNode = function () {\n        return this.type === 'InternalNode';\n    };\n    AbstractNode.prototype.isLeafNode = function () {\n        return this.type === 'LeafNode';\n    };\n    AbstractNode.prototype.asRootNode = function () {\n        if (!this.isRootNode()) {\n            throw new Error('ouch');\n        }\n        return this;\n    };\n    AbstractNode.prototype.asInternalNode = function () {\n        if (!this.isInternalNode()) {\n            throw new Error('ouch');\n        }\n        return this;\n    };\n    AbstractNode.prototype.asLeafNode = function () {\n        if (!this.isLeafNode()) {\n            throw new Error('ouch');\n        }\n        return this;\n    };\n    AbstractNode.prototype.ensureNotDeleted = function (op) {\n        if (op === void 0) { op = 'unknown'; }\n        if (this.deleted) {\n            throw new Error('forbidden operation ' + op + ' on deleted node ' + this.id);\n        }\n    };\n    AbstractNode.prototype.log = function () {\n        console.log(JSON.stringify(this.toJSON(true), null, 2));\n    };\n    /**\n * by the elimination-rule of bdd,\n * if two branches of the same level are equal,\n * one can be removed\n *\n * See page 21 at:\n * @link https://people.eecs.berkeley.edu/~sseshia/219c/lectures/BinaryDecisionDiagrams.pdf\n */\n    AbstractNode.prototype.applyEliminationRule = function (\n    // can be provided for better performance\n    nodesOfSameLevel) {\n        var _this = this;\n        this.ensureNotDeleted('applyEliminationRule');\n        if (!nodesOfSameLevel) {\n            nodesOfSameLevel = this.rootNode.getNodesOfLevel(this.level);\n        }\n        var other = findSimilarNode(this, nodesOfSameLevel);\n        if (other) {\n            // console.log('applyEliminationRule() remove:' + this.id + '; other: ' + other.id);\n            // keep 'other', remove 'this'\n            // move own parents to other\n            var ownParents = this.parents.getAll();\n            var parentsWithStrictEqualBranches_1 = [];\n            ownParents.forEach(function (parent) {\n                // console.log('ownParent: ' + parent.id);\n                var branchKey = parent.branches.getKeyOfNode(_this);\n                // console.log('branchKey: ' + branchKey);\n                parent.branches.setBranch(branchKey, other);\n                if (parent.branches.areBranchesStrictEqual()) {\n                    parentsWithStrictEqualBranches_1.push(parent);\n                }\n                // remove parents from own list\n                // this will auto-remove the connection to the other '1'-branch\n                _this.parents.remove(parent);\n            });\n            // parents that now have equal branches, must be removed again\n            parentsWithStrictEqualBranches_1.forEach(function (node) {\n                if (node.isInternalNode()) {\n                    // console.log('trigger applyReductionRule from applyEliminationRule');\n                    node.applyReductionRule();\n                }\n            });\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    return AbstractNode;\n}());\nexport { AbstractNode };\n//# sourceMappingURL=abstract-node.js.map"]},"metadata":{},"sourceType":"module"}
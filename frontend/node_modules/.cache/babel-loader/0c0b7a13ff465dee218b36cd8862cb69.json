{"ast":null,"code":"import { preprocessAttachments, processDocs, isLocalId, parseDoc } from 'pouchdb-adapter-utils';\nimport { safeJsonParse, safeJsonStringify } from 'pouchdb-json';\nimport { compactTree, collectConflicts, isDeleted, isLocalId as isLocalId$1, traverseRevTree, winningRev, latest } from 'pouchdb-merge';\nimport { btoa, readAsBinaryString, base64StringToBlobOrBuffer, blob } from 'pouchdb-binary-utils';\nimport { createError, IDB_ERROR, MISSING_STUB, MISSING_DOC, REV_CONFLICT } from 'pouchdb-errors';\nimport { Map, Set } from 'pouchdb-collections';\nimport { assign, pick, changesHandler, nextTick, clone, filterChange, uuid, guardedConsole, toPromise, hasLocalStorage } from 'pouchdb-utils'; // IndexedDB requires a versioned database structure, so we use the\n// version here to manage migrations.\n\nvar ADAPTER_VERSION = 5; // The object stores created for each database\n// DOC_STORE stores the document meta data, its revision history and state\n// Keyed by document id\n\nvar DOC_STORE = 'document-store'; // BY_SEQ_STORE stores a particular version of a document, keyed by its\n// sequence id\n\nvar BY_SEQ_STORE = 'by-sequence'; // Where we store attachments\n\nvar ATTACH_STORE = 'attach-store'; // Where we store many-to-many relations\n// between attachment digests and seqs\n\nvar ATTACH_AND_SEQ_STORE = 'attach-seq-store'; // Where we store database-wide meta data in a single record\n// keyed by id: META_STORE\n\nvar META_STORE = 'meta-store'; // Where we store local documents\n\nvar LOCAL_STORE = 'local-store'; // Where we detect blob support\n\nvar DETECT_BLOB_SUPPORT_STORE = 'detect-blob-support';\n\nfunction idbError(callback) {\n  return function (evt) {\n    var message = 'unknown_error';\n\n    if (evt.target && evt.target.error) {\n      message = evt.target.error.name || evt.target.error.message;\n    }\n\n    callback(createError(IDB_ERROR, message, evt.type));\n  };\n} // Unfortunately, the metadata has to be stringified\n// when it is put into the database, because otherwise\n// IndexedDB can throw errors for deeply-nested objects.\n// Originally we just used JSON.parse/JSON.stringify; now\n// we use this custom vuvuzela library that avoids recursion.\n// If we could do it all over again, we'd probably use a\n// format for the revision trees other than JSON.\n\n\nfunction encodeMetadata(metadata, winningRev$$1, deleted) {\n  return {\n    data: safeJsonStringify(metadata),\n    winningRev: winningRev$$1,\n    deletedOrLocal: deleted ? '1' : '0',\n    seq: metadata.seq,\n    // highest seq for this doc\n    id: metadata.id\n  };\n}\n\nfunction decodeMetadata(storedObject) {\n  if (!storedObject) {\n    return null;\n  }\n\n  var metadata = safeJsonParse(storedObject.data);\n  metadata.winningRev = storedObject.winningRev;\n  metadata.deleted = storedObject.deletedOrLocal === '1';\n  metadata.seq = storedObject.seq;\n  return metadata;\n} // read the doc back out from the database. we don't store the\n// _id or _rev because we already have _doc_id_rev.\n\n\nfunction decodeDoc(doc) {\n  if (!doc) {\n    return doc;\n  }\n\n  var idx = doc._doc_id_rev.lastIndexOf(':');\n\n  doc._id = doc._doc_id_rev.substring(0, idx - 1);\n  doc._rev = doc._doc_id_rev.substring(idx + 1);\n  delete doc._doc_id_rev;\n  return doc;\n} // Read a blob from the database, encoding as necessary\n// and translating from base64 if the IDB doesn't support\n// native Blobs\n\n\nfunction readBlobData(body, type, asBlob, callback) {\n  if (asBlob) {\n    if (!body) {\n      callback(blob([''], {\n        type: type\n      }));\n    } else if (typeof body !== 'string') {\n      // we have blob support\n      callback(body);\n    } else {\n      // no blob support\n      callback(base64StringToBlobOrBuffer(body, type));\n    }\n  } else {\n    // as base64 string\n    if (!body) {\n      callback('');\n    } else if (typeof body !== 'string') {\n      // we have blob support\n      readAsBinaryString(body, function (binary) {\n        callback(btoa(binary));\n      });\n    } else {\n      // no blob support\n      callback(body);\n    }\n  }\n}\n\nfunction fetchAttachmentsIfNecessary(doc, opts, txn, cb) {\n  var attachments = Object.keys(doc._attachments || {});\n\n  if (!attachments.length) {\n    return cb && cb();\n  }\n\n  var numDone = 0;\n\n  function checkDone() {\n    if (++numDone === attachments.length && cb) {\n      cb();\n    }\n  }\n\n  function fetchAttachment(doc, att) {\n    var attObj = doc._attachments[att];\n    var digest = attObj.digest;\n    var req = txn.objectStore(ATTACH_STORE).get(digest);\n\n    req.onsuccess = function (e) {\n      attObj.body = e.target.result.body;\n      checkDone();\n    };\n  }\n\n  attachments.forEach(function (att) {\n    if (opts.attachments && opts.include_docs) {\n      fetchAttachment(doc, att);\n    } else {\n      doc._attachments[att].stub = true;\n      checkDone();\n    }\n  });\n} // IDB-specific postprocessing necessary because\n// we don't know whether we stored a true Blob or\n// a base64-encoded string, and if it's a Blob it\n// needs to be read outside of the transaction context\n\n\nfunction postProcessAttachments(results, asBlob) {\n  return Promise.all(results.map(function (row) {\n    if (row.doc && row.doc._attachments) {\n      var attNames = Object.keys(row.doc._attachments);\n      return Promise.all(attNames.map(function (att) {\n        var attObj = row.doc._attachments[att];\n\n        if (!('body' in attObj)) {\n          // already processed\n          return;\n        }\n\n        var body = attObj.body;\n        var type = attObj.content_type;\n        return new Promise(function (resolve) {\n          readBlobData(body, type, asBlob, function (data) {\n            row.doc._attachments[att] = assign(pick(attObj, ['digest', 'content_type']), {\n              data: data\n            });\n            resolve();\n          });\n        });\n      }));\n    }\n  }));\n}\n\nfunction compactRevs(revs, docId, txn) {\n  var possiblyOrphanedDigests = [];\n  var seqStore = txn.objectStore(BY_SEQ_STORE);\n  var attStore = txn.objectStore(ATTACH_STORE);\n  var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n  var count = revs.length;\n\n  function checkDone() {\n    count--;\n\n    if (!count) {\n      // done processing all revs\n      deleteOrphanedAttachments();\n    }\n  }\n\n  function deleteOrphanedAttachments() {\n    if (!possiblyOrphanedDigests.length) {\n      return;\n    }\n\n    possiblyOrphanedDigests.forEach(function (digest) {\n      var countReq = attAndSeqStore.index('digestSeq').count(IDBKeyRange.bound(digest + '::', digest + \"::\\uFFFF\", false, false));\n\n      countReq.onsuccess = function (e) {\n        var count = e.target.result;\n\n        if (!count) {\n          // orphaned\n          attStore.delete(digest);\n        }\n      };\n    });\n  }\n\n  revs.forEach(function (rev) {\n    var index = seqStore.index('_doc_id_rev');\n    var key = docId + \"::\" + rev;\n\n    index.getKey(key).onsuccess = function (e) {\n      var seq = e.target.result;\n\n      if (typeof seq !== 'number') {\n        return checkDone();\n      }\n\n      seqStore.delete(seq);\n      var cursor = attAndSeqStore.index('seq').openCursor(IDBKeyRange.only(seq));\n\n      cursor.onsuccess = function (event) {\n        var cursor = event.target.result;\n\n        if (cursor) {\n          var digest = cursor.value.digestSeq.split('::')[0];\n          possiblyOrphanedDigests.push(digest);\n          attAndSeqStore.delete(cursor.primaryKey);\n          cursor.continue();\n        } else {\n          // done\n          checkDone();\n        }\n      };\n    };\n  });\n}\n\nfunction openTransactionSafely(idb, stores, mode) {\n  try {\n    return {\n      txn: idb.transaction(stores, mode)\n    };\n  } catch (err) {\n    return {\n      error: err\n    };\n  }\n}\n\nvar changesHandler$1 = new changesHandler();\n\nfunction idbBulkDocs(dbOpts, req, opts, api, idb, callback) {\n  var docInfos = req.docs;\n  var txn;\n  var docStore;\n  var bySeqStore;\n  var attachStore;\n  var attachAndSeqStore;\n  var metaStore;\n  var docInfoError;\n  var metaDoc;\n\n  for (var i = 0, len = docInfos.length; i < len; i++) {\n    var doc = docInfos[i];\n\n    if (doc._id && isLocalId(doc._id)) {\n      continue;\n    }\n\n    doc = docInfos[i] = parseDoc(doc, opts.new_edits, dbOpts);\n\n    if (doc.error && !docInfoError) {\n      docInfoError = doc;\n    }\n  }\n\n  if (docInfoError) {\n    return callback(docInfoError);\n  }\n\n  var allDocsProcessed = false;\n  var docCountDelta = 0;\n  var results = new Array(docInfos.length);\n  var fetchedDocs = new Map();\n  var preconditionErrored = false;\n  var blobType = api._meta.blobSupport ? 'blob' : 'base64';\n  preprocessAttachments(docInfos, blobType, function (err) {\n    if (err) {\n      return callback(err);\n    }\n\n    startTransaction();\n  });\n\n  function startTransaction() {\n    var stores = [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE, LOCAL_STORE, ATTACH_AND_SEQ_STORE, META_STORE];\n    var txnResult = openTransactionSafely(idb, stores, 'readwrite');\n\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n\n    txn = txnResult.txn;\n    txn.onabort = idbError(callback);\n    txn.ontimeout = idbError(callback);\n    txn.oncomplete = complete;\n    docStore = txn.objectStore(DOC_STORE);\n    bySeqStore = txn.objectStore(BY_SEQ_STORE);\n    attachStore = txn.objectStore(ATTACH_STORE);\n    attachAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n    metaStore = txn.objectStore(META_STORE);\n\n    metaStore.get(META_STORE).onsuccess = function (e) {\n      metaDoc = e.target.result;\n      updateDocCountIfReady();\n    };\n\n    verifyAttachments(function (err) {\n      if (err) {\n        preconditionErrored = true;\n        return callback(err);\n      }\n\n      fetchExistingDocs();\n    });\n  }\n\n  function onAllDocsProcessed() {\n    allDocsProcessed = true;\n    updateDocCountIfReady();\n  }\n\n  function idbProcessDocs() {\n    processDocs(dbOpts.revs_limit, docInfos, api, fetchedDocs, txn, results, writeDoc, opts, onAllDocsProcessed);\n  }\n\n  function updateDocCountIfReady() {\n    if (!metaDoc || !allDocsProcessed) {\n      return;\n    } // caching the docCount saves a lot of time in allDocs() and\n    // info(), which is why we go to all the trouble of doing this\n\n\n    metaDoc.docCount += docCountDelta;\n    metaStore.put(metaDoc);\n  }\n\n  function fetchExistingDocs() {\n    if (!docInfos.length) {\n      return;\n    }\n\n    var numFetched = 0;\n\n    function checkDone() {\n      if (++numFetched === docInfos.length) {\n        idbProcessDocs();\n      }\n    }\n\n    function readMetadata(event) {\n      var metadata = decodeMetadata(event.target.result);\n\n      if (metadata) {\n        fetchedDocs.set(metadata.id, metadata);\n      }\n\n      checkDone();\n    }\n\n    for (var i = 0, len = docInfos.length; i < len; i++) {\n      var docInfo = docInfos[i];\n\n      if (docInfo._id && isLocalId(docInfo._id)) {\n        checkDone(); // skip local docs\n\n        continue;\n      }\n\n      var req = docStore.get(docInfo.metadata.id);\n      req.onsuccess = readMetadata;\n    }\n  }\n\n  function complete() {\n    if (preconditionErrored) {\n      return;\n    }\n\n    changesHandler$1.notify(api._meta.name);\n    callback(null, results);\n  }\n\n  function verifyAttachment(digest, callback) {\n    var req = attachStore.get(digest);\n\n    req.onsuccess = function (e) {\n      if (!e.target.result) {\n        var err = createError(MISSING_STUB, 'unknown stub attachment with digest ' + digest);\n        err.status = 412;\n        callback(err);\n      } else {\n        callback();\n      }\n    };\n  }\n\n  function verifyAttachments(finish) {\n    var digests = [];\n    docInfos.forEach(function (docInfo) {\n      if (docInfo.data && docInfo.data._attachments) {\n        Object.keys(docInfo.data._attachments).forEach(function (filename) {\n          var att = docInfo.data._attachments[filename];\n\n          if (att.stub) {\n            digests.push(att.digest);\n          }\n        });\n      }\n    });\n\n    if (!digests.length) {\n      return finish();\n    }\n\n    var numDone = 0;\n    var err;\n\n    function checkDone() {\n      if (++numDone === digests.length) {\n        finish(err);\n      }\n    }\n\n    digests.forEach(function (digest) {\n      verifyAttachment(digest, function (attErr) {\n        if (attErr && !err) {\n          err = attErr;\n        }\n\n        checkDone();\n      });\n    });\n  }\n\n  function writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted, isUpdate, delta, resultsIdx, callback) {\n    docInfo.metadata.winningRev = winningRev$$1;\n    docInfo.metadata.deleted = winningRevIsDeleted;\n    var doc = docInfo.data;\n    doc._id = docInfo.metadata.id;\n    doc._rev = docInfo.metadata.rev;\n\n    if (newRevIsDeleted) {\n      doc._deleted = true;\n    }\n\n    var hasAttachments = doc._attachments && Object.keys(doc._attachments).length;\n\n    if (hasAttachments) {\n      return writeAttachments(docInfo, winningRev$$1, winningRevIsDeleted, isUpdate, resultsIdx, callback);\n    }\n\n    docCountDelta += delta;\n    updateDocCountIfReady();\n    finishDoc(docInfo, winningRev$$1, winningRevIsDeleted, isUpdate, resultsIdx, callback);\n  }\n\n  function finishDoc(docInfo, winningRev$$1, winningRevIsDeleted, isUpdate, resultsIdx, callback) {\n    var doc = docInfo.data;\n    var metadata = docInfo.metadata;\n    doc._doc_id_rev = metadata.id + '::' + metadata.rev;\n    delete doc._id;\n    delete doc._rev;\n\n    function afterPutDoc(e) {\n      var revsToDelete = docInfo.stemmedRevs || [];\n\n      if (isUpdate && api.auto_compaction) {\n        revsToDelete = revsToDelete.concat(compactTree(docInfo.metadata));\n      }\n\n      if (revsToDelete && revsToDelete.length) {\n        compactRevs(revsToDelete, docInfo.metadata.id, txn);\n      }\n\n      metadata.seq = e.target.result; // Current _rev is calculated from _rev_tree on read\n      // delete metadata.rev;\n\n      var metadataToStore = encodeMetadata(metadata, winningRev$$1, winningRevIsDeleted);\n      var metaDataReq = docStore.put(metadataToStore);\n      metaDataReq.onsuccess = afterPutMetadata;\n    }\n\n    function afterPutDocError(e) {\n      // ConstraintError, need to update, not put (see #1638 for details)\n      e.preventDefault(); // avoid transaction abort\n\n      e.stopPropagation(); // avoid transaction onerror\n\n      var index = bySeqStore.index('_doc_id_rev');\n      var getKeyReq = index.getKey(doc._doc_id_rev);\n\n      getKeyReq.onsuccess = function (e) {\n        var putReq = bySeqStore.put(doc, e.target.result);\n        putReq.onsuccess = afterPutDoc;\n      };\n    }\n\n    function afterPutMetadata() {\n      results[resultsIdx] = {\n        ok: true,\n        id: metadata.id,\n        rev: metadata.rev\n      };\n      fetchedDocs.set(docInfo.metadata.id, docInfo.metadata);\n      insertAttachmentMappings(docInfo, metadata.seq, callback);\n    }\n\n    var putReq = bySeqStore.put(doc);\n    putReq.onsuccess = afterPutDoc;\n    putReq.onerror = afterPutDocError;\n  }\n\n  function writeAttachments(docInfo, winningRev$$1, winningRevIsDeleted, isUpdate, resultsIdx, callback) {\n    var doc = docInfo.data;\n    var numDone = 0;\n    var attachments = Object.keys(doc._attachments);\n\n    function collectResults() {\n      if (numDone === attachments.length) {\n        finishDoc(docInfo, winningRev$$1, winningRevIsDeleted, isUpdate, resultsIdx, callback);\n      }\n    }\n\n    function attachmentSaved() {\n      numDone++;\n      collectResults();\n    }\n\n    attachments.forEach(function (key) {\n      var att = docInfo.data._attachments[key];\n\n      if (!att.stub) {\n        var data = att.data;\n        delete att.data;\n        att.revpos = parseInt(winningRev$$1, 10);\n        var digest = att.digest;\n        saveAttachment(digest, data, attachmentSaved);\n      } else {\n        numDone++;\n        collectResults();\n      }\n    });\n  } // map seqs to attachment digests, which\n  // we will need later during compaction\n\n\n  function insertAttachmentMappings(docInfo, seq, callback) {\n    var attsAdded = 0;\n    var attsToAdd = Object.keys(docInfo.data._attachments || {});\n\n    if (!attsToAdd.length) {\n      return callback();\n    }\n\n    function checkDone() {\n      if (++attsAdded === attsToAdd.length) {\n        callback();\n      }\n    }\n\n    function add(att) {\n      var digest = docInfo.data._attachments[att].digest;\n      var req = attachAndSeqStore.put({\n        seq: seq,\n        digestSeq: digest + '::' + seq\n      });\n      req.onsuccess = checkDone;\n\n      req.onerror = function (e) {\n        // this callback is for a constaint error, which we ignore\n        // because this docid/rev has already been associated with\n        // the digest (e.g. when new_edits == false)\n        e.preventDefault(); // avoid transaction abort\n\n        e.stopPropagation(); // avoid transaction onerror\n\n        checkDone();\n      };\n    }\n\n    for (var i = 0; i < attsToAdd.length; i++) {\n      add(attsToAdd[i]); // do in parallel\n    }\n  }\n\n  function saveAttachment(digest, data, callback) {\n    var getKeyReq = attachStore.count(digest);\n\n    getKeyReq.onsuccess = function (e) {\n      var count = e.target.result;\n\n      if (count) {\n        return callback(); // already exists\n      }\n\n      var newAtt = {\n        digest: digest,\n        body: data\n      };\n      var putReq = attachStore.put(newAtt);\n      putReq.onsuccess = callback;\n    };\n  }\n} // Abstraction over IDBCursor and getAll()/getAllKeys() that allows us to batch our operations\n// while falling back to a normal IDBCursor operation on browsers that don't support getAll() or\n// getAllKeys(). This allows for a much faster implementation than just straight-up cursors, because\n// we're not processing each document one-at-a-time.\n\n\nfunction runBatchedCursor(objectStore, keyRange, descending, batchSize, onBatch) {\n  if (batchSize === -1) {\n    batchSize = 1000;\n  } // Bail out of getAll()/getAllKeys() in the following cases:\n  // 1) either method is unsupported - we need both\n  // 2) batchSize is 1 (might as well use IDBCursor)\n  // 3) descending â€“ no real way to do this via getAll()/getAllKeys()\n\n\n  var useGetAll = typeof objectStore.getAll === 'function' && typeof objectStore.getAllKeys === 'function' && batchSize > 1 && !descending;\n  var keysBatch;\n  var valuesBatch;\n  var pseudoCursor;\n\n  function onGetAll(e) {\n    valuesBatch = e.target.result;\n\n    if (keysBatch) {\n      onBatch(keysBatch, valuesBatch, pseudoCursor);\n    }\n  }\n\n  function onGetAllKeys(e) {\n    keysBatch = e.target.result;\n\n    if (valuesBatch) {\n      onBatch(keysBatch, valuesBatch, pseudoCursor);\n    }\n  }\n\n  function continuePseudoCursor() {\n    if (!keysBatch.length) {\n      // no more results\n      return onBatch();\n    } // fetch next batch, exclusive start\n\n\n    var lastKey = keysBatch[keysBatch.length - 1];\n    var newKeyRange;\n\n    if (keyRange && keyRange.upper) {\n      try {\n        newKeyRange = IDBKeyRange.bound(lastKey, keyRange.upper, true, keyRange.upperOpen);\n      } catch (e) {\n        if (e.name === \"DataError\" && e.code === 0) {\n          return onBatch(); // we're done, startkey and endkey are equal\n        }\n      }\n    } else {\n      newKeyRange = IDBKeyRange.lowerBound(lastKey, true);\n    }\n\n    keyRange = newKeyRange;\n    keysBatch = null;\n    valuesBatch = null;\n    objectStore.getAll(keyRange, batchSize).onsuccess = onGetAll;\n    objectStore.getAllKeys(keyRange, batchSize).onsuccess = onGetAllKeys;\n  }\n\n  function onCursor(e) {\n    var cursor = e.target.result;\n\n    if (!cursor) {\n      // done\n      return onBatch();\n    } // regular IDBCursor acts like a batch where batch size is always 1\n\n\n    onBatch([cursor.key], [cursor.value], cursor);\n  }\n\n  if (useGetAll) {\n    pseudoCursor = {\n      \"continue\": continuePseudoCursor\n    };\n    objectStore.getAll(keyRange, batchSize).onsuccess = onGetAll;\n    objectStore.getAllKeys(keyRange, batchSize).onsuccess = onGetAllKeys;\n  } else if (descending) {\n    objectStore.openCursor(keyRange, 'prev').onsuccess = onCursor;\n  } else {\n    objectStore.openCursor(keyRange).onsuccess = onCursor;\n  }\n} // simple shim for objectStore.getAll(), falling back to IDBCursor\n\n\nfunction getAll(objectStore, keyRange, onSuccess) {\n  if (typeof objectStore.getAll === 'function') {\n    // use native getAll\n    objectStore.getAll(keyRange).onsuccess = onSuccess;\n    return;\n  } // fall back to cursors\n\n\n  var values = [];\n\n  function onCursor(e) {\n    var cursor = e.target.result;\n\n    if (cursor) {\n      values.push(cursor.value);\n      cursor.continue();\n    } else {\n      onSuccess({\n        target: {\n          result: values\n        }\n      });\n    }\n  }\n\n  objectStore.openCursor(keyRange).onsuccess = onCursor;\n}\n\nfunction allDocsKeys(keys, docStore, onBatch) {\n  // It's not guaranted to be returned in right order  \n  var valuesBatch = new Array(keys.length);\n  var count = 0;\n  keys.forEach(function (key, index) {\n    docStore.get(key).onsuccess = function (event) {\n      if (event.target.result) {\n        valuesBatch[index] = event.target.result;\n      } else {\n        valuesBatch[index] = {\n          key: key,\n          error: 'not_found'\n        };\n      }\n\n      count++;\n\n      if (count === keys.length) {\n        onBatch(keys, valuesBatch, {});\n      }\n    };\n  });\n}\n\nfunction createKeyRange(start, end, inclusiveEnd, key, descending) {\n  try {\n    if (start && end) {\n      if (descending) {\n        return IDBKeyRange.bound(end, start, !inclusiveEnd, false);\n      } else {\n        return IDBKeyRange.bound(start, end, false, !inclusiveEnd);\n      }\n    } else if (start) {\n      if (descending) {\n        return IDBKeyRange.upperBound(start);\n      } else {\n        return IDBKeyRange.lowerBound(start);\n      }\n    } else if (end) {\n      if (descending) {\n        return IDBKeyRange.lowerBound(end, !inclusiveEnd);\n      } else {\n        return IDBKeyRange.upperBound(end, !inclusiveEnd);\n      }\n    } else if (key) {\n      return IDBKeyRange.only(key);\n    }\n  } catch (e) {\n    return {\n      error: e\n    };\n  }\n\n  return null;\n}\n\nfunction idbAllDocs(opts, idb, callback) {\n  var start = 'startkey' in opts ? opts.startkey : false;\n  var end = 'endkey' in opts ? opts.endkey : false;\n  var key = 'key' in opts ? opts.key : false;\n  var keys = 'keys' in opts ? opts.keys : false;\n  var skip = opts.skip || 0;\n  var limit = typeof opts.limit === 'number' ? opts.limit : -1;\n  var inclusiveEnd = opts.inclusive_end !== false;\n  var keyRange;\n  var keyRangeError;\n\n  if (!keys) {\n    keyRange = createKeyRange(start, end, inclusiveEnd, key, opts.descending);\n    keyRangeError = keyRange && keyRange.error;\n\n    if (keyRangeError && !(keyRangeError.name === \"DataError\" && keyRangeError.code === 0)) {\n      // DataError with error code 0 indicates start is less than end, so\n      // can just do an empty query. Else need to throw\n      return callback(createError(IDB_ERROR, keyRangeError.name, keyRangeError.message));\n    }\n  }\n\n  var stores = [DOC_STORE, BY_SEQ_STORE, META_STORE];\n\n  if (opts.attachments) {\n    stores.push(ATTACH_STORE);\n  }\n\n  var txnResult = openTransactionSafely(idb, stores, 'readonly');\n\n  if (txnResult.error) {\n    return callback(txnResult.error);\n  }\n\n  var txn = txnResult.txn;\n  txn.oncomplete = onTxnComplete;\n  txn.onabort = idbError(callback);\n  var docStore = txn.objectStore(DOC_STORE);\n  var seqStore = txn.objectStore(BY_SEQ_STORE);\n  var metaStore = txn.objectStore(META_STORE);\n  var docIdRevIndex = seqStore.index('_doc_id_rev');\n  var results = [];\n  var docCount;\n  var updateSeq;\n\n  metaStore.get(META_STORE).onsuccess = function (e) {\n    docCount = e.target.result.docCount;\n  };\n  /* istanbul ignore if */\n\n\n  if (opts.update_seq) {\n    getMaxUpdateSeq(seqStore, function (e) {\n      if (e.target.result && e.target.result.length > 0) {\n        updateSeq = e.target.result[0];\n      }\n    });\n  }\n\n  function getMaxUpdateSeq(objectStore, onSuccess) {\n    function onCursor(e) {\n      var cursor = e.target.result;\n      var maxKey = undefined;\n\n      if (cursor && cursor.key) {\n        maxKey = cursor.key;\n      }\n\n      return onSuccess({\n        target: {\n          result: [maxKey]\n        }\n      });\n    }\n\n    objectStore.openCursor(null, 'prev').onsuccess = onCursor;\n  } // if the user specifies include_docs=true, then we don't\n  // want to block the main cursor while we're fetching the doc\n\n\n  function fetchDocAsynchronously(metadata, row, winningRev$$1) {\n    var key = metadata.id + \"::\" + winningRev$$1;\n\n    docIdRevIndex.get(key).onsuccess = function onGetDoc(e) {\n      row.doc = decodeDoc(e.target.result) || {};\n\n      if (opts.conflicts) {\n        var conflicts = collectConflicts(metadata);\n\n        if (conflicts.length) {\n          row.doc._conflicts = conflicts;\n        }\n      }\n\n      fetchAttachmentsIfNecessary(row.doc, opts, txn);\n    };\n  }\n\n  function allDocsInner(winningRev$$1, metadata) {\n    var row = {\n      id: metadata.id,\n      key: metadata.id,\n      value: {\n        rev: winningRev$$1\n      }\n    };\n    var deleted = metadata.deleted;\n\n    if (deleted) {\n      if (keys) {\n        results.push(row); // deleted docs are okay with \"keys\" requests\n\n        row.value.deleted = true;\n        row.doc = null;\n      }\n    } else if (skip-- <= 0) {\n      results.push(row);\n\n      if (opts.include_docs) {\n        fetchDocAsynchronously(metadata, row, winningRev$$1);\n      }\n    }\n  }\n\n  function processBatch(batchValues) {\n    for (var i = 0, len = batchValues.length; i < len; i++) {\n      if (results.length === limit) {\n        break;\n      }\n\n      var batchValue = batchValues[i];\n\n      if (batchValue.error && keys) {\n        // key was not found with \"keys\" requests\n        results.push(batchValue);\n        continue;\n      }\n\n      var metadata = decodeMetadata(batchValue);\n      var winningRev$$1 = metadata.winningRev;\n      allDocsInner(winningRev$$1, metadata);\n    }\n  }\n\n  function onBatch(batchKeys, batchValues, cursor) {\n    if (!cursor) {\n      return;\n    }\n\n    processBatch(batchValues);\n\n    if (results.length < limit) {\n      cursor.continue();\n    }\n  }\n\n  function onGetAll(e) {\n    var values = e.target.result;\n\n    if (opts.descending) {\n      values = values.reverse();\n    }\n\n    processBatch(values);\n  }\n\n  function onResultsReady() {\n    var returnVal = {\n      total_rows: docCount,\n      offset: opts.skip,\n      rows: results\n    };\n    /* istanbul ignore if */\n\n    if (opts.update_seq && updateSeq !== undefined) {\n      returnVal.update_seq = updateSeq;\n    }\n\n    callback(null, returnVal);\n  }\n\n  function onTxnComplete() {\n    if (opts.attachments) {\n      postProcessAttachments(results, opts.binary).then(onResultsReady);\n    } else {\n      onResultsReady();\n    }\n  } // don't bother doing any requests if start > end or limit === 0\n\n\n  if (keyRangeError || limit === 0) {\n    return;\n  }\n\n  if (keys) {\n    return allDocsKeys(opts.keys, docStore, onBatch);\n  }\n\n  if (limit === -1) {\n    // just fetch everything\n    return getAll(docStore, keyRange, onGetAll);\n  } // else do a cursor\n  // choose a batch size based on the skip, since we'll need to skip that many\n\n\n  runBatchedCursor(docStore, keyRange, opts.descending, limit + skip, onBatch);\n} //\n// Blobs are not supported in all versions of IndexedDB, notably\n// Chrome <37 and Android <5. In those versions, storing a blob will throw.\n//\n// Various other blob bugs exist in Chrome v37-42 (inclusive).\n// Detecting them is expensive and confusing to users, and Chrome 37-42\n// is at very low usage worldwide, so we do a hacky userAgent check instead.\n//\n// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120\n// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916\n// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836\n//\n\n\nfunction checkBlobSupport(txn) {\n  return new Promise(function (resolve) {\n    var blob$$1 = blob(['']);\n    var req = txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob$$1, 'key');\n\n    req.onsuccess = function () {\n      var matchedChrome = navigator.userAgent.match(/Chrome\\/(\\d+)/);\n      var matchedEdge = navigator.userAgent.match(/Edge\\//); // MS Edge pretends to be Chrome 42:\n      // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx\n\n      resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);\n    };\n\n    req.onerror = txn.onabort = function (e) {\n      // If the transaction aborts now its due to not being able to\n      // write to the database, likely due to the disk being full\n      e.preventDefault();\n      e.stopPropagation();\n      resolve(false);\n    };\n  }).catch(function () {\n    return false; // error, so assume unsupported\n  });\n}\n\nfunction countDocs(txn, cb) {\n  var index = txn.objectStore(DOC_STORE).index('deletedOrLocal');\n\n  index.count(IDBKeyRange.only('0')).onsuccess = function (e) {\n    cb(e.target.result);\n  };\n} // This task queue ensures that IDB open calls are done in their own tick\n\n\nvar running = false;\nvar queue = [];\n\nfunction tryCode(fun, err, res, PouchDB) {\n  try {\n    fun(err, res);\n  } catch (err) {\n    // Shouldn't happen, but in some odd cases\n    // IndexedDB implementations might throw a sync\n    // error, in which case this will at least log it.\n    PouchDB.emit('error', err);\n  }\n}\n\nfunction applyNext() {\n  if (running || !queue.length) {\n    return;\n  }\n\n  running = true;\n  queue.shift()();\n}\n\nfunction enqueueTask(action, callback, PouchDB) {\n  queue.push(function runAction() {\n    action(function runCallback(err, res) {\n      tryCode(callback, err, res, PouchDB);\n      running = false;\n      nextTick(function runNext() {\n        applyNext(PouchDB);\n      });\n    });\n  });\n  applyNext();\n}\n\nfunction changes(opts, api, dbName, idb) {\n  opts = clone(opts);\n\n  if (opts.continuous) {\n    var id = dbName + ':' + uuid();\n    changesHandler$1.addListener(dbName, id, api, opts);\n    changesHandler$1.notify(dbName);\n    return {\n      cancel: function cancel() {\n        changesHandler$1.removeListener(dbName, id);\n      }\n    };\n  }\n\n  var docIds = opts.doc_ids && new Set(opts.doc_ids);\n  opts.since = opts.since || 0;\n  var lastSeq = opts.since;\n  var limit = 'limit' in opts ? opts.limit : -1;\n\n  if (limit === 0) {\n    limit = 1; // per CouchDB _changes spec\n  }\n\n  var results = [];\n  var numResults = 0;\n  var filter = filterChange(opts);\n  var docIdsToMetadata = new Map();\n  var txn;\n  var bySeqStore;\n  var docStore;\n  var docIdRevIndex;\n\n  function onBatch(batchKeys, batchValues, cursor) {\n    if (!cursor || !batchKeys.length) {\n      // done\n      return;\n    }\n\n    var winningDocs = new Array(batchKeys.length);\n    var metadatas = new Array(batchKeys.length);\n\n    function processMetadataAndWinningDoc(metadata, winningDoc) {\n      var change = opts.processChange(winningDoc, metadata, opts);\n      lastSeq = change.seq = metadata.seq;\n      var filtered = filter(change);\n\n      if (typeof filtered === 'object') {\n        // anything but true/false indicates error\n        return Promise.reject(filtered);\n      }\n\n      if (!filtered) {\n        return Promise.resolve();\n      }\n\n      numResults++;\n\n      if (opts.return_docs) {\n        results.push(change);\n      } // process the attachment immediately\n      // for the benefit of live listeners\n\n\n      if (opts.attachments && opts.include_docs) {\n        return new Promise(function (resolve) {\n          fetchAttachmentsIfNecessary(winningDoc, opts, txn, function () {\n            postProcessAttachments([change], opts.binary).then(function () {\n              resolve(change);\n            });\n          });\n        });\n      } else {\n        return Promise.resolve(change);\n      }\n    }\n\n    function onBatchDone() {\n      var promises = [];\n\n      for (var i = 0, len = winningDocs.length; i < len; i++) {\n        if (numResults === limit) {\n          break;\n        }\n\n        var winningDoc = winningDocs[i];\n\n        if (!winningDoc) {\n          continue;\n        }\n\n        var metadata = metadatas[i];\n        promises.push(processMetadataAndWinningDoc(metadata, winningDoc));\n      }\n\n      Promise.all(promises).then(function (changes) {\n        for (var i = 0, len = changes.length; i < len; i++) {\n          if (changes[i]) {\n            opts.onChange(changes[i]);\n          }\n        }\n      }).catch(opts.complete);\n\n      if (numResults !== limit) {\n        cursor.continue();\n      }\n    } // Fetch all metadatas/winningdocs from this batch in parallel, then process\n    // them all only once all data has been collected. This is done in parallel\n    // because it's faster than doing it one-at-a-time.\n\n\n    var numDone = 0;\n    batchValues.forEach(function (value, i) {\n      var doc = decodeDoc(value);\n      var seq = batchKeys[i];\n      fetchWinningDocAndMetadata(doc, seq, function (metadata, winningDoc) {\n        metadatas[i] = metadata;\n        winningDocs[i] = winningDoc;\n\n        if (++numDone === batchKeys.length) {\n          onBatchDone();\n        }\n      });\n    });\n  }\n\n  function onGetMetadata(doc, seq, metadata, cb) {\n    if (metadata.seq !== seq) {\n      // some other seq is later\n      return cb();\n    }\n\n    if (metadata.winningRev === doc._rev) {\n      // this is the winning doc\n      return cb(metadata, doc);\n    } // fetch winning doc in separate request\n\n\n    var docIdRev = doc._id + '::' + metadata.winningRev;\n    var req = docIdRevIndex.get(docIdRev);\n\n    req.onsuccess = function (e) {\n      cb(metadata, decodeDoc(e.target.result));\n    };\n  }\n\n  function fetchWinningDocAndMetadata(doc, seq, cb) {\n    if (docIds && !docIds.has(doc._id)) {\n      return cb();\n    }\n\n    var metadata = docIdsToMetadata.get(doc._id);\n\n    if (metadata) {\n      // cached\n      return onGetMetadata(doc, seq, metadata, cb);\n    } // metadata not cached, have to go fetch it\n\n\n    docStore.get(doc._id).onsuccess = function (e) {\n      metadata = decodeMetadata(e.target.result);\n      docIdsToMetadata.set(doc._id, metadata);\n      onGetMetadata(doc, seq, metadata, cb);\n    };\n  }\n\n  function finish() {\n    opts.complete(null, {\n      results: results,\n      last_seq: lastSeq\n    });\n  }\n\n  function onTxnComplete() {\n    if (!opts.continuous && opts.attachments) {\n      // cannot guarantee that postProcessing was already done,\n      // so do it again\n      postProcessAttachments(results).then(finish);\n    } else {\n      finish();\n    }\n  }\n\n  var objectStores = [DOC_STORE, BY_SEQ_STORE];\n\n  if (opts.attachments) {\n    objectStores.push(ATTACH_STORE);\n  }\n\n  var txnResult = openTransactionSafely(idb, objectStores, 'readonly');\n\n  if (txnResult.error) {\n    return opts.complete(txnResult.error);\n  }\n\n  txn = txnResult.txn;\n  txn.onabort = idbError(opts.complete);\n  txn.oncomplete = onTxnComplete;\n  bySeqStore = txn.objectStore(BY_SEQ_STORE);\n  docStore = txn.objectStore(DOC_STORE);\n  docIdRevIndex = bySeqStore.index('_doc_id_rev');\n  var keyRange = opts.since && !opts.descending ? IDBKeyRange.lowerBound(opts.since, true) : null;\n  runBatchedCursor(bySeqStore, keyRange, opts.descending, limit, onBatch);\n}\n\nvar cachedDBs = new Map();\nvar blobSupportPromise;\nvar openReqList = new Map();\n\nfunction IdbPouch(opts, callback) {\n  var api = this;\n  enqueueTask(function (thisCallback) {\n    init(api, opts, thisCallback);\n  }, callback, api.constructor);\n}\n\nfunction init(api, opts, callback) {\n  var dbName = opts.name;\n  var idb = null;\n  api._meta = null; // called when creating a fresh new database\n\n  function createSchema(db) {\n    var docStore = db.createObjectStore(DOC_STORE, {\n      keyPath: 'id'\n    });\n    db.createObjectStore(BY_SEQ_STORE, {\n      autoIncrement: true\n    }).createIndex('_doc_id_rev', '_doc_id_rev', {\n      unique: true\n    });\n    db.createObjectStore(ATTACH_STORE, {\n      keyPath: 'digest'\n    });\n    db.createObjectStore(META_STORE, {\n      keyPath: 'id',\n      autoIncrement: false\n    });\n    db.createObjectStore(DETECT_BLOB_SUPPORT_STORE); // added in v2\n\n    docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {\n      unique: false\n    }); // added in v3\n\n    db.createObjectStore(LOCAL_STORE, {\n      keyPath: '_id'\n    }); // added in v4\n\n    var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE, {\n      autoIncrement: true\n    });\n    attAndSeqStore.createIndex('seq', 'seq');\n    attAndSeqStore.createIndex('digestSeq', 'digestSeq', {\n      unique: true\n    });\n  } // migration to version 2\n  // unfortunately \"deletedOrLocal\" is a misnomer now that we no longer\n  // store local docs in the main doc-store, but whaddyagonnado\n\n\n  function addDeletedOrLocalIndex(txn, callback) {\n    var docStore = txn.objectStore(DOC_STORE);\n    docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {\n      unique: false\n    });\n\n    docStore.openCursor().onsuccess = function (event) {\n      var cursor = event.target.result;\n\n      if (cursor) {\n        var metadata = cursor.value;\n        var deleted = isDeleted(metadata);\n        metadata.deletedOrLocal = deleted ? \"1\" : \"0\";\n        docStore.put(metadata);\n        cursor.continue();\n      } else {\n        callback();\n      }\n    };\n  } // migration to version 3 (part 1)\n\n\n  function createLocalStoreSchema(db) {\n    db.createObjectStore(LOCAL_STORE, {\n      keyPath: '_id'\n    }).createIndex('_doc_id_rev', '_doc_id_rev', {\n      unique: true\n    });\n  } // migration to version 3 (part 2)\n\n\n  function migrateLocalStore(txn, cb) {\n    var localStore = txn.objectStore(LOCAL_STORE);\n    var docStore = txn.objectStore(DOC_STORE);\n    var seqStore = txn.objectStore(BY_SEQ_STORE);\n    var cursor = docStore.openCursor();\n\n    cursor.onsuccess = function (event) {\n      var cursor = event.target.result;\n\n      if (cursor) {\n        var metadata = cursor.value;\n        var docId = metadata.id;\n        var local = isLocalId$1(docId);\n        var rev = winningRev(metadata);\n\n        if (local) {\n          var docIdRev = docId + \"::\" + rev; // remove all seq entries\n          // associated with this docId\n\n          var start = docId + \"::\";\n          var end = docId + \"::~\";\n          var index = seqStore.index('_doc_id_rev');\n          var range = IDBKeyRange.bound(start, end, false, false);\n          var seqCursor = index.openCursor(range);\n\n          seqCursor.onsuccess = function (e) {\n            seqCursor = e.target.result;\n\n            if (!seqCursor) {\n              // done\n              docStore.delete(cursor.primaryKey);\n              cursor.continue();\n            } else {\n              var data = seqCursor.value;\n\n              if (data._doc_id_rev === docIdRev) {\n                localStore.put(data);\n              }\n\n              seqStore.delete(seqCursor.primaryKey);\n              seqCursor.continue();\n            }\n          };\n        } else {\n          cursor.continue();\n        }\n      } else if (cb) {\n        cb();\n      }\n    };\n  } // migration to version 4 (part 1)\n\n\n  function addAttachAndSeqStore(db) {\n    var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE, {\n      autoIncrement: true\n    });\n    attAndSeqStore.createIndex('seq', 'seq');\n    attAndSeqStore.createIndex('digestSeq', 'digestSeq', {\n      unique: true\n    });\n  } // migration to version 4 (part 2)\n\n\n  function migrateAttsAndSeqs(txn, callback) {\n    var seqStore = txn.objectStore(BY_SEQ_STORE);\n    var attStore = txn.objectStore(ATTACH_STORE);\n    var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE); // need to actually populate the table. this is the expensive part,\n    // so as an optimization, check first that this database even\n    // contains attachments\n\n    var req = attStore.count();\n\n    req.onsuccess = function (e) {\n      var count = e.target.result;\n\n      if (!count) {\n        return callback(); // done\n      }\n\n      seqStore.openCursor().onsuccess = function (e) {\n        var cursor = e.target.result;\n\n        if (!cursor) {\n          return callback(); // done\n        }\n\n        var doc = cursor.value;\n        var seq = cursor.primaryKey;\n        var atts = Object.keys(doc._attachments || {});\n        var digestMap = {};\n\n        for (var j = 0; j < atts.length; j++) {\n          var att = doc._attachments[atts[j]];\n          digestMap[att.digest] = true; // uniq digests, just in case\n        }\n\n        var digests = Object.keys(digestMap);\n\n        for (j = 0; j < digests.length; j++) {\n          var digest = digests[j];\n          attAndSeqStore.put({\n            seq: seq,\n            digestSeq: digest + '::' + seq\n          });\n        }\n\n        cursor.continue();\n      };\n    };\n  } // migration to version 5\n  // Instead of relying on on-the-fly migration of metadata,\n  // this brings the doc-store to its modern form:\n  // - metadata.winningrev\n  // - metadata.seq\n  // - stringify the metadata when storing it\n\n\n  function migrateMetadata(txn) {\n    function decodeMetadataCompat(storedObject) {\n      if (!storedObject.data) {\n        // old format, when we didn't store it stringified\n        storedObject.deleted = storedObject.deletedOrLocal === '1';\n        return storedObject;\n      }\n\n      return decodeMetadata(storedObject);\n    } // ensure that every metadata has a winningRev and seq,\n    // which was previously created on-the-fly but better to migrate\n\n\n    var bySeqStore = txn.objectStore(BY_SEQ_STORE);\n    var docStore = txn.objectStore(DOC_STORE);\n    var cursor = docStore.openCursor();\n\n    cursor.onsuccess = function (e) {\n      var cursor = e.target.result;\n\n      if (!cursor) {\n        return; // done\n      }\n\n      var metadata = decodeMetadataCompat(cursor.value);\n      metadata.winningRev = metadata.winningRev || winningRev(metadata);\n\n      function fetchMetadataSeq() {\n        // metadata.seq was added post-3.2.0, so if it's missing,\n        // we need to fetch it manually\n        var start = metadata.id + '::';\n        var end = metadata.id + \"::\\uFFFF\";\n        var req = bySeqStore.index('_doc_id_rev').openCursor(IDBKeyRange.bound(start, end));\n        var metadataSeq = 0;\n\n        req.onsuccess = function (e) {\n          var cursor = e.target.result;\n\n          if (!cursor) {\n            metadata.seq = metadataSeq;\n            return onGetMetadataSeq();\n          }\n\n          var seq = cursor.primaryKey;\n\n          if (seq > metadataSeq) {\n            metadataSeq = seq;\n          }\n\n          cursor.continue();\n        };\n      }\n\n      function onGetMetadataSeq() {\n        var metadataToStore = encodeMetadata(metadata, metadata.winningRev, metadata.deleted);\n        var req = docStore.put(metadataToStore);\n\n        req.onsuccess = function () {\n          cursor.continue();\n        };\n      }\n\n      if (metadata.seq) {\n        return onGetMetadataSeq();\n      }\n\n      fetchMetadataSeq();\n    };\n  }\n\n  api._remote = false;\n\n  api.type = function () {\n    return 'idb';\n  };\n\n  api._id = toPromise(function (callback) {\n    callback(null, api._meta.instanceId);\n  });\n\n  api._bulkDocs = function idb_bulkDocs(req, reqOpts, callback) {\n    idbBulkDocs(opts, req, reqOpts, api, idb, callback);\n  }; // First we look up the metadata in the ids database, then we fetch the\n  // current revision(s) from the by sequence store\n\n\n  api._get = function idb_get(id, opts, callback) {\n    var doc;\n    var metadata;\n    var err;\n    var txn = opts.ctx;\n\n    if (!txn) {\n      var txnResult = openTransactionSafely(idb, [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');\n\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n\n      txn = txnResult.txn;\n    }\n\n    function finish() {\n      callback(err, {\n        doc: doc,\n        metadata: metadata,\n        ctx: txn\n      });\n    }\n\n    txn.objectStore(DOC_STORE).get(id).onsuccess = function (e) {\n      metadata = decodeMetadata(e.target.result); // we can determine the result here if:\n      // 1. there is no such document\n      // 2. the document is deleted and we don't ask about specific rev\n      // When we ask with opts.rev we expect the answer to be either\n      // doc (possibly with _deleted=true) or missing error\n\n      if (!metadata) {\n        err = createError(MISSING_DOC, 'missing');\n        return finish();\n      }\n\n      var rev;\n\n      if (!opts.rev) {\n        rev = metadata.winningRev;\n        var deleted = isDeleted(metadata);\n\n        if (deleted) {\n          err = createError(MISSING_DOC, \"deleted\");\n          return finish();\n        }\n      } else {\n        rev = opts.latest ? latest(opts.rev, metadata) : opts.rev;\n      }\n\n      var objectStore = txn.objectStore(BY_SEQ_STORE);\n      var key = metadata.id + '::' + rev;\n\n      objectStore.index('_doc_id_rev').get(key).onsuccess = function (e) {\n        doc = e.target.result;\n\n        if (doc) {\n          doc = decodeDoc(doc);\n        }\n\n        if (!doc) {\n          err = createError(MISSING_DOC, 'missing');\n          return finish();\n        }\n\n        finish();\n      };\n    };\n  };\n\n  api._getAttachment = function (docId, attachId, attachment, opts, callback) {\n    var txn;\n\n    if (opts.ctx) {\n      txn = opts.ctx;\n    } else {\n      var txnResult = openTransactionSafely(idb, [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');\n\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n\n      txn = txnResult.txn;\n    }\n\n    var digest = attachment.digest;\n    var type = attachment.content_type;\n\n    txn.objectStore(ATTACH_STORE).get(digest).onsuccess = function (e) {\n      var body = e.target.result.body;\n      readBlobData(body, type, opts.binary, function (blobData) {\n        callback(null, blobData);\n      });\n    };\n  };\n\n  api._info = function idb_info(callback) {\n    var updateSeq;\n    var docCount;\n    var txnResult = openTransactionSafely(idb, [META_STORE, BY_SEQ_STORE], 'readonly');\n\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n\n    var txn = txnResult.txn;\n\n    txn.objectStore(META_STORE).get(META_STORE).onsuccess = function (e) {\n      docCount = e.target.result.docCount;\n    };\n\n    txn.objectStore(BY_SEQ_STORE).openCursor(null, 'prev').onsuccess = function (e) {\n      var cursor = e.target.result;\n      updateSeq = cursor ? cursor.key : 0;\n    };\n\n    txn.oncomplete = function () {\n      callback(null, {\n        doc_count: docCount,\n        update_seq: updateSeq,\n        // for debugging\n        idb_attachment_format: api._meta.blobSupport ? 'binary' : 'base64'\n      });\n    };\n  };\n\n  api._allDocs = function idb_allDocs(opts, callback) {\n    idbAllDocs(opts, idb, callback);\n  };\n\n  api._changes = function idbChanges(opts) {\n    return changes(opts, api, dbName, idb);\n  };\n\n  api._close = function (callback) {\n    // https://developer.mozilla.org/en-US/docs/IndexedDB/IDBDatabase#close\n    // \"Returns immediately and closes the connection in a separate thread...\"\n    idb.close();\n    cachedDBs.delete(dbName);\n    callback();\n  };\n\n  api._getRevisionTree = function (docId, callback) {\n    var txnResult = openTransactionSafely(idb, [DOC_STORE], 'readonly');\n\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n\n    var txn = txnResult.txn;\n    var req = txn.objectStore(DOC_STORE).get(docId);\n\n    req.onsuccess = function (event) {\n      var doc = decodeMetadata(event.target.result);\n\n      if (!doc) {\n        callback(createError(MISSING_DOC));\n      } else {\n        callback(null, doc.rev_tree);\n      }\n    };\n  }; // This function removes revisions of document docId\n  // which are listed in revs and sets this document\n  // revision to to rev_tree\n\n\n  api._doCompaction = function (docId, revs, callback) {\n    var stores = [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE, ATTACH_AND_SEQ_STORE];\n    var txnResult = openTransactionSafely(idb, stores, 'readwrite');\n\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n\n    var txn = txnResult.txn;\n    var docStore = txn.objectStore(DOC_STORE);\n\n    docStore.get(docId).onsuccess = function (event) {\n      var metadata = decodeMetadata(event.target.result);\n      traverseRevTree(metadata.rev_tree, function (isLeaf, pos, revHash, ctx, opts) {\n        var rev = pos + '-' + revHash;\n\n        if (revs.indexOf(rev) !== -1) {\n          opts.status = 'missing';\n        }\n      });\n      compactRevs(revs, docId, txn);\n      var winningRev$$1 = metadata.winningRev;\n      var deleted = metadata.deleted;\n      txn.objectStore(DOC_STORE).put(encodeMetadata(metadata, winningRev$$1, deleted));\n    };\n\n    txn.onabort = idbError(callback);\n\n    txn.oncomplete = function () {\n      callback();\n    };\n  };\n\n  api._getLocal = function (id, callback) {\n    var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readonly');\n\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n\n    var tx = txnResult.txn;\n    var req = tx.objectStore(LOCAL_STORE).get(id);\n    req.onerror = idbError(callback);\n\n    req.onsuccess = function (e) {\n      var doc = e.target.result;\n\n      if (!doc) {\n        callback(createError(MISSING_DOC));\n      } else {\n        delete doc['_doc_id_rev']; // for backwards compat\n\n        callback(null, doc);\n      }\n    };\n  };\n\n  api._putLocal = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    delete doc._revisions; // ignore this, trust the rev\n\n    var oldRev = doc._rev;\n    var id = doc._id;\n\n    if (!oldRev) {\n      doc._rev = '0-1';\n    } else {\n      doc._rev = '0-' + (parseInt(oldRev.split('-')[1], 10) + 1);\n    }\n\n    var tx = opts.ctx;\n    var ret;\n\n    if (!tx) {\n      var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');\n\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n\n      tx = txnResult.txn;\n      tx.onerror = idbError(callback);\n\n      tx.oncomplete = function () {\n        if (ret) {\n          callback(null, ret);\n        }\n      };\n    }\n\n    var oStore = tx.objectStore(LOCAL_STORE);\n    var req;\n\n    if (oldRev) {\n      req = oStore.get(id);\n\n      req.onsuccess = function (e) {\n        var oldDoc = e.target.result;\n\n        if (!oldDoc || oldDoc._rev !== oldRev) {\n          callback(createError(REV_CONFLICT));\n        } else {\n          // update\n          var req = oStore.put(doc);\n\n          req.onsuccess = function () {\n            ret = {\n              ok: true,\n              id: doc._id,\n              rev: doc._rev\n            };\n\n            if (opts.ctx) {\n              // return immediately\n              callback(null, ret);\n            }\n          };\n        }\n      };\n    } else {\n      // new doc\n      req = oStore.add(doc);\n\n      req.onerror = function (e) {\n        // constraint error, already exists\n        callback(createError(REV_CONFLICT));\n        e.preventDefault(); // avoid transaction abort\n\n        e.stopPropagation(); // avoid transaction onerror\n      };\n\n      req.onsuccess = function () {\n        ret = {\n          ok: true,\n          id: doc._id,\n          rev: doc._rev\n        };\n\n        if (opts.ctx) {\n          // return immediately\n          callback(null, ret);\n        }\n      };\n    }\n  };\n\n  api._removeLocal = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    var tx = opts.ctx;\n\n    if (!tx) {\n      var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');\n\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n\n      tx = txnResult.txn;\n\n      tx.oncomplete = function () {\n        if (ret) {\n          callback(null, ret);\n        }\n      };\n    }\n\n    var ret;\n    var id = doc._id;\n    var oStore = tx.objectStore(LOCAL_STORE);\n    var req = oStore.get(id);\n    req.onerror = idbError(callback);\n\n    req.onsuccess = function (e) {\n      var oldDoc = e.target.result;\n\n      if (!oldDoc || oldDoc._rev !== doc._rev) {\n        callback(createError(MISSING_DOC));\n      } else {\n        oStore.delete(id);\n        ret = {\n          ok: true,\n          id: id,\n          rev: '0-0'\n        };\n\n        if (opts.ctx) {\n          // return immediately\n          callback(null, ret);\n        }\n      }\n    };\n  };\n\n  api._destroy = function (opts, callback) {\n    changesHandler$1.removeAllListeners(dbName); //Close open request for \"dbName\" database to fix ie delay.\n\n    var openReq = openReqList.get(dbName);\n\n    if (openReq && openReq.result) {\n      openReq.result.close();\n      cachedDBs.delete(dbName);\n    }\n\n    var req = indexedDB.deleteDatabase(dbName);\n\n    req.onsuccess = function () {\n      //Remove open request from the list.\n      openReqList.delete(dbName);\n\n      if (hasLocalStorage() && dbName in localStorage) {\n        delete localStorage[dbName];\n      }\n\n      callback(null, {\n        'ok': true\n      });\n    };\n\n    req.onerror = idbError(callback);\n  };\n\n  var cached = cachedDBs.get(dbName);\n\n  if (cached) {\n    idb = cached.idb;\n    api._meta = cached.global;\n    return nextTick(function () {\n      callback(null, api);\n    });\n  }\n\n  var req = indexedDB.open(dbName, ADAPTER_VERSION);\n  openReqList.set(dbName, req);\n\n  req.onupgradeneeded = function (e) {\n    var db = e.target.result;\n\n    if (e.oldVersion < 1) {\n      return createSchema(db); // new db, initial schema\n    } // do migrations\n\n\n    var txn = e.currentTarget.transaction; // these migrations have to be done in this function, before\n    // control is returned to the event loop, because IndexedDB\n\n    if (e.oldVersion < 3) {\n      createLocalStoreSchema(db); // v2 -> v3\n    }\n\n    if (e.oldVersion < 4) {\n      addAttachAndSeqStore(db); // v3 -> v4\n    }\n\n    var migrations = [addDeletedOrLocalIndex, // v1 -> v2\n    migrateLocalStore, // v2 -> v3\n    migrateAttsAndSeqs, // v3 -> v4\n    migrateMetadata // v4 -> v5\n    ];\n    var i = e.oldVersion;\n\n    function next() {\n      var migration = migrations[i - 1];\n      i++;\n\n      if (migration) {\n        migration(txn, next);\n      }\n    }\n\n    next();\n  };\n\n  req.onsuccess = function (e) {\n    idb = e.target.result;\n\n    idb.onversionchange = function () {\n      idb.close();\n      cachedDBs.delete(dbName);\n    };\n\n    idb.onabort = function (e) {\n      guardedConsole('error', 'Database has a global failure', e.target.error);\n      idb.close();\n      cachedDBs.delete(dbName);\n    }; // Do a few setup operations (in parallel as much as possible):\n    // 1. Fetch meta doc\n    // 2. Check blob support\n    // 3. Calculate docCount\n    // 4. Generate an instanceId if necessary\n    // 5. Store docCount and instanceId on meta doc\n\n\n    var txn = idb.transaction([META_STORE, DETECT_BLOB_SUPPORT_STORE, DOC_STORE], 'readwrite');\n    var storedMetaDoc = false;\n    var metaDoc;\n    var docCount;\n    var blobSupport;\n    var instanceId;\n\n    function completeSetup() {\n      if (typeof blobSupport === 'undefined' || !storedMetaDoc) {\n        return;\n      }\n\n      api._meta = {\n        name: dbName,\n        instanceId: instanceId,\n        blobSupport: blobSupport\n      };\n      cachedDBs.set(dbName, {\n        idb: idb,\n        global: api._meta\n      });\n      callback(null, api);\n    }\n\n    function storeMetaDocIfReady() {\n      if (typeof docCount === 'undefined' || typeof metaDoc === 'undefined') {\n        return;\n      }\n\n      var instanceKey = dbName + '_id';\n\n      if (instanceKey in metaDoc) {\n        instanceId = metaDoc[instanceKey];\n      } else {\n        metaDoc[instanceKey] = instanceId = uuid();\n      }\n\n      metaDoc.docCount = docCount;\n      txn.objectStore(META_STORE).put(metaDoc);\n    } //\n    // fetch or generate the instanceId\n    //\n\n\n    txn.objectStore(META_STORE).get(META_STORE).onsuccess = function (e) {\n      metaDoc = e.target.result || {\n        id: META_STORE\n      };\n      storeMetaDocIfReady();\n    }; //\n    // countDocs\n    //\n\n\n    countDocs(txn, function (count) {\n      docCount = count;\n      storeMetaDocIfReady();\n    }); //\n    // check blob support\n    //\n\n    if (!blobSupportPromise) {\n      // make sure blob support is only checked once\n      blobSupportPromise = checkBlobSupport(txn);\n    }\n\n    blobSupportPromise.then(function (val) {\n      blobSupport = val;\n      completeSetup();\n    }); // only when the metadata put transaction has completed,\n    // consider the setup done\n\n    txn.oncomplete = function () {\n      storedMetaDoc = true;\n      completeSetup();\n    };\n\n    txn.onabort = idbError(callback);\n  };\n\n  req.onerror = function (e) {\n    var msg = e.target.error && e.target.error.message;\n\n    if (!msg) {\n      msg = 'Failed to open indexedDB, are you in private browsing mode?';\n    } else if (msg.indexOf(\"stored database is a higher version\") !== -1) {\n      msg = new Error('This DB was created with the newer \"indexeddb\" adapter, but you are trying to open it with the older \"idb\" adapter');\n    }\n\n    guardedConsole('error', msg);\n    callback(createError(IDB_ERROR, msg));\n  };\n}\n\nIdbPouch.valid = function () {\n  // Following #7085 buggy idb versions (typically Safari < 10.1) are\n  // considered valid.\n  // On Firefox SecurityError is thrown while referencing indexedDB if cookies\n  // are not allowed. `typeof indexedDB` also triggers the error.\n  try {\n    // some outdated implementations of IDB that appear on Samsung\n    // and HTC Android devices <4.4 are missing IDBKeyRange\n    return typeof indexedDB !== 'undefined' && typeof IDBKeyRange !== 'undefined';\n  } catch (e) {\n    return false;\n  }\n};\n\nfunction index(PouchDB) {\n  PouchDB.adapter('idb', IdbPouch, true);\n}\n\nexport default index;","map":{"version":3,"sources":["/Users/Hanzalah/Desktop/github/todo-offline/rxdb-hasura-demo/node_modules/pouchdb-adapter-idb/lib/index.es.js"],"names":["preprocessAttachments","processDocs","isLocalId","parseDoc","safeJsonParse","safeJsonStringify","compactTree","collectConflicts","isDeleted","isLocalId$1","traverseRevTree","winningRev","latest","btoa","readAsBinaryString","base64StringToBlobOrBuffer","blob","createError","IDB_ERROR","MISSING_STUB","MISSING_DOC","REV_CONFLICT","Map","Set","assign","pick","changesHandler","nextTick","clone","filterChange","uuid","guardedConsole","toPromise","hasLocalStorage","ADAPTER_VERSION","DOC_STORE","BY_SEQ_STORE","ATTACH_STORE","ATTACH_AND_SEQ_STORE","META_STORE","LOCAL_STORE","DETECT_BLOB_SUPPORT_STORE","idbError","callback","evt","message","target","error","name","type","encodeMetadata","metadata","winningRev$$1","deleted","data","deletedOrLocal","seq","id","decodeMetadata","storedObject","decodeDoc","doc","idx","_doc_id_rev","lastIndexOf","_id","substring","_rev","readBlobData","body","asBlob","binary","fetchAttachmentsIfNecessary","opts","txn","cb","attachments","Object","keys","_attachments","length","numDone","checkDone","fetchAttachment","att","attObj","digest","req","objectStore","get","onsuccess","e","result","forEach","include_docs","stub","postProcessAttachments","results","Promise","all","map","row","attNames","content_type","resolve","compactRevs","revs","docId","possiblyOrphanedDigests","seqStore","attStore","attAndSeqStore","count","deleteOrphanedAttachments","countReq","index","IDBKeyRange","bound","delete","rev","key","getKey","cursor","openCursor","only","event","value","digestSeq","split","push","primaryKey","continue","openTransactionSafely","idb","stores","mode","transaction","err","changesHandler$1","idbBulkDocs","dbOpts","api","docInfos","docs","docStore","bySeqStore","attachStore","attachAndSeqStore","metaStore","docInfoError","metaDoc","i","len","new_edits","allDocsProcessed","docCountDelta","Array","fetchedDocs","preconditionErrored","blobType","_meta","blobSupport","startTransaction","txnResult","onabort","ontimeout","oncomplete","complete","updateDocCountIfReady","verifyAttachments","fetchExistingDocs","onAllDocsProcessed","idbProcessDocs","revs_limit","writeDoc","docCount","put","numFetched","readMetadata","set","docInfo","notify","verifyAttachment","status","finish","digests","filename","attErr","winningRevIsDeleted","newRevIsDeleted","isUpdate","delta","resultsIdx","_deleted","hasAttachments","writeAttachments","finishDoc","afterPutDoc","revsToDelete","stemmedRevs","auto_compaction","concat","metadataToStore","metaDataReq","afterPutMetadata","afterPutDocError","preventDefault","stopPropagation","getKeyReq","putReq","ok","insertAttachmentMappings","onerror","collectResults","attachmentSaved","revpos","parseInt","saveAttachment","attsAdded","attsToAdd","add","newAtt","runBatchedCursor","keyRange","descending","batchSize","onBatch","useGetAll","getAll","getAllKeys","keysBatch","valuesBatch","pseudoCursor","onGetAll","onGetAllKeys","continuePseudoCursor","lastKey","newKeyRange","upper","upperOpen","code","lowerBound","onCursor","onSuccess","values","allDocsKeys","createKeyRange","start","end","inclusiveEnd","upperBound","idbAllDocs","startkey","endkey","skip","limit","inclusive_end","keyRangeError","onTxnComplete","docIdRevIndex","updateSeq","update_seq","getMaxUpdateSeq","maxKey","undefined","fetchDocAsynchronously","onGetDoc","conflicts","_conflicts","allDocsInner","processBatch","batchValues","batchValue","batchKeys","reverse","onResultsReady","returnVal","total_rows","offset","rows","then","checkBlobSupport","blob$$1","matchedChrome","navigator","userAgent","match","matchedEdge","catch","countDocs","running","queue","tryCode","fun","res","PouchDB","emit","applyNext","shift","enqueueTask","action","runAction","runCallback","runNext","changes","dbName","continuous","addListener","cancel","removeListener","docIds","doc_ids","since","lastSeq","numResults","filter","docIdsToMetadata","winningDocs","metadatas","processMetadataAndWinningDoc","winningDoc","change","processChange","filtered","reject","return_docs","onBatchDone","promises","onChange","fetchWinningDocAndMetadata","onGetMetadata","docIdRev","has","last_seq","objectStores","cachedDBs","blobSupportPromise","openReqList","IdbPouch","thisCallback","init","constructor","createSchema","db","createObjectStore","keyPath","autoIncrement","createIndex","unique","addDeletedOrLocalIndex","createLocalStoreSchema","migrateLocalStore","localStore","local","range","seqCursor","addAttachAndSeqStore","migrateAttsAndSeqs","atts","digestMap","j","migrateMetadata","decodeMetadataCompat","fetchMetadataSeq","metadataSeq","onGetMetadataSeq","_remote","instanceId","_bulkDocs","idb_bulkDocs","reqOpts","_get","idb_get","ctx","_getAttachment","attachId","attachment","blobData","_info","idb_info","doc_count","idb_attachment_format","_allDocs","idb_allDocs","_changes","idbChanges","_close","close","_getRevisionTree","rev_tree","_doCompaction","isLeaf","pos","revHash","indexOf","_getLocal","tx","_putLocal","_revisions","oldRev","ret","oStore","oldDoc","_removeLocal","_destroy","removeAllListeners","openReq","indexedDB","deleteDatabase","localStorage","cached","global","open","onupgradeneeded","oldVersion","currentTarget","migrations","next","migration","onversionchange","storedMetaDoc","completeSetup","storeMetaDocIfReady","instanceKey","val","msg","Error","valid","adapter"],"mappings":"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","sourcesContent":["import { preprocessAttachments, processDocs, isLocalId, parseDoc } from 'pouchdb-adapter-utils';\nimport { safeJsonParse, safeJsonStringify } from 'pouchdb-json';\nimport { compactTree, collectConflicts, isDeleted, isLocalId as isLocalId$1, traverseRevTree, winningRev, latest } from 'pouchdb-merge';\nimport { btoa, readAsBinaryString, base64StringToBlobOrBuffer, blob } from 'pouchdb-binary-utils';\nimport { createError, IDB_ERROR, MISSING_STUB, MISSING_DOC, REV_CONFLICT } from 'pouchdb-errors';\nimport { Map, Set } from 'pouchdb-collections';\nimport { assign, pick, changesHandler, nextTick, clone, filterChange, uuid, guardedConsole, toPromise, hasLocalStorage } from 'pouchdb-utils';\n\n// IndexedDB requires a versioned database structure, so we use the\n// version here to manage migrations.\nvar ADAPTER_VERSION = 5;\n\n// The object stores created for each database\n// DOC_STORE stores the document meta data, its revision history and state\n// Keyed by document id\nvar DOC_STORE = 'document-store';\n// BY_SEQ_STORE stores a particular version of a document, keyed by its\n// sequence id\nvar BY_SEQ_STORE = 'by-sequence';\n// Where we store attachments\nvar ATTACH_STORE = 'attach-store';\n// Where we store many-to-many relations\n// between attachment digests and seqs\nvar ATTACH_AND_SEQ_STORE = 'attach-seq-store';\n\n// Where we store database-wide meta data in a single record\n// keyed by id: META_STORE\nvar META_STORE = 'meta-store';\n// Where we store local documents\nvar LOCAL_STORE = 'local-store';\n// Where we detect blob support\nvar DETECT_BLOB_SUPPORT_STORE = 'detect-blob-support';\n\nfunction idbError(callback) {\n  return function (evt) {\n    var message = 'unknown_error';\n    if (evt.target && evt.target.error) {\n      message = evt.target.error.name || evt.target.error.message;\n    }\n    callback(createError(IDB_ERROR, message, evt.type));\n  };\n}\n\n// Unfortunately, the metadata has to be stringified\n// when it is put into the database, because otherwise\n// IndexedDB can throw errors for deeply-nested objects.\n// Originally we just used JSON.parse/JSON.stringify; now\n// we use this custom vuvuzela library that avoids recursion.\n// If we could do it all over again, we'd probably use a\n// format for the revision trees other than JSON.\nfunction encodeMetadata(metadata, winningRev$$1, deleted) {\n  return {\n    data: safeJsonStringify(metadata),\n    winningRev: winningRev$$1,\n    deletedOrLocal: deleted ? '1' : '0',\n    seq: metadata.seq, // highest seq for this doc\n    id: metadata.id\n  };\n}\n\nfunction decodeMetadata(storedObject) {\n  if (!storedObject) {\n    return null;\n  }\n  var metadata = safeJsonParse(storedObject.data);\n  metadata.winningRev = storedObject.winningRev;\n  metadata.deleted = storedObject.deletedOrLocal === '1';\n  metadata.seq = storedObject.seq;\n  return metadata;\n}\n\n// read the doc back out from the database. we don't store the\n// _id or _rev because we already have _doc_id_rev.\nfunction decodeDoc(doc) {\n  if (!doc) {\n    return doc;\n  }\n  var idx = doc._doc_id_rev.lastIndexOf(':');\n  doc._id = doc._doc_id_rev.substring(0, idx - 1);\n  doc._rev = doc._doc_id_rev.substring(idx + 1);\n  delete doc._doc_id_rev;\n  return doc;\n}\n\n// Read a blob from the database, encoding as necessary\n// and translating from base64 if the IDB doesn't support\n// native Blobs\nfunction readBlobData(body, type, asBlob, callback) {\n  if (asBlob) {\n    if (!body) {\n      callback(blob([''], {type: type}));\n    } else if (typeof body !== 'string') { // we have blob support\n      callback(body);\n    } else { // no blob support\n      callback(base64StringToBlobOrBuffer(body, type));\n    }\n  } else { // as base64 string\n    if (!body) {\n      callback('');\n    } else if (typeof body !== 'string') { // we have blob support\n      readAsBinaryString(body, function (binary) {\n        callback(btoa(binary));\n      });\n    } else { // no blob support\n      callback(body);\n    }\n  }\n}\n\nfunction fetchAttachmentsIfNecessary(doc, opts, txn, cb) {\n  var attachments = Object.keys(doc._attachments || {});\n  if (!attachments.length) {\n    return cb && cb();\n  }\n  var numDone = 0;\n\n  function checkDone() {\n    if (++numDone === attachments.length && cb) {\n      cb();\n    }\n  }\n\n  function fetchAttachment(doc, att) {\n    var attObj = doc._attachments[att];\n    var digest = attObj.digest;\n    var req = txn.objectStore(ATTACH_STORE).get(digest);\n    req.onsuccess = function (e) {\n      attObj.body = e.target.result.body;\n      checkDone();\n    };\n  }\n\n  attachments.forEach(function (att) {\n    if (opts.attachments && opts.include_docs) {\n      fetchAttachment(doc, att);\n    } else {\n      doc._attachments[att].stub = true;\n      checkDone();\n    }\n  });\n}\n\n// IDB-specific postprocessing necessary because\n// we don't know whether we stored a true Blob or\n// a base64-encoded string, and if it's a Blob it\n// needs to be read outside of the transaction context\nfunction postProcessAttachments(results, asBlob) {\n  return Promise.all(results.map(function (row) {\n    if (row.doc && row.doc._attachments) {\n      var attNames = Object.keys(row.doc._attachments);\n      return Promise.all(attNames.map(function (att) {\n        var attObj = row.doc._attachments[att];\n        if (!('body' in attObj)) { // already processed\n          return;\n        }\n        var body = attObj.body;\n        var type = attObj.content_type;\n        return new Promise(function (resolve) {\n          readBlobData(body, type, asBlob, function (data) {\n            row.doc._attachments[att] = assign(\n              pick(attObj, ['digest', 'content_type']),\n              {data: data}\n            );\n            resolve();\n          });\n        });\n      }));\n    }\n  }));\n}\n\nfunction compactRevs(revs, docId, txn) {\n\n  var possiblyOrphanedDigests = [];\n  var seqStore = txn.objectStore(BY_SEQ_STORE);\n  var attStore = txn.objectStore(ATTACH_STORE);\n  var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n  var count = revs.length;\n\n  function checkDone() {\n    count--;\n    if (!count) { // done processing all revs\n      deleteOrphanedAttachments();\n    }\n  }\n\n  function deleteOrphanedAttachments() {\n    if (!possiblyOrphanedDigests.length) {\n      return;\n    }\n    possiblyOrphanedDigests.forEach(function (digest) {\n      var countReq = attAndSeqStore.index('digestSeq').count(\n        IDBKeyRange.bound(\n          digest + '::', digest + '::\\uffff', false, false));\n      countReq.onsuccess = function (e) {\n        var count = e.target.result;\n        if (!count) {\n          // orphaned\n          attStore.delete(digest);\n        }\n      };\n    });\n  }\n\n  revs.forEach(function (rev) {\n    var index = seqStore.index('_doc_id_rev');\n    var key = docId + \"::\" + rev;\n    index.getKey(key).onsuccess = function (e) {\n      var seq = e.target.result;\n      if (typeof seq !== 'number') {\n        return checkDone();\n      }\n      seqStore.delete(seq);\n\n      var cursor = attAndSeqStore.index('seq')\n        .openCursor(IDBKeyRange.only(seq));\n\n      cursor.onsuccess = function (event) {\n        var cursor = event.target.result;\n        if (cursor) {\n          var digest = cursor.value.digestSeq.split('::')[0];\n          possiblyOrphanedDigests.push(digest);\n          attAndSeqStore.delete(cursor.primaryKey);\n          cursor.continue();\n        } else { // done\n          checkDone();\n        }\n      };\n    };\n  });\n}\n\nfunction openTransactionSafely(idb, stores, mode) {\n  try {\n    return {\n      txn: idb.transaction(stores, mode)\n    };\n  } catch (err) {\n    return {\n      error: err\n    };\n  }\n}\n\nvar changesHandler$1 = new changesHandler();\n\nfunction idbBulkDocs(dbOpts, req, opts, api, idb, callback) {\n  var docInfos = req.docs;\n  var txn;\n  var docStore;\n  var bySeqStore;\n  var attachStore;\n  var attachAndSeqStore;\n  var metaStore;\n  var docInfoError;\n  var metaDoc;\n\n  for (var i = 0, len = docInfos.length; i < len; i++) {\n    var doc = docInfos[i];\n    if (doc._id && isLocalId(doc._id)) {\n      continue;\n    }\n    doc = docInfos[i] = parseDoc(doc, opts.new_edits, dbOpts);\n    if (doc.error && !docInfoError) {\n      docInfoError = doc;\n    }\n  }\n\n  if (docInfoError) {\n    return callback(docInfoError);\n  }\n\n  var allDocsProcessed = false;\n  var docCountDelta = 0;\n  var results = new Array(docInfos.length);\n  var fetchedDocs = new Map();\n  var preconditionErrored = false;\n  var blobType = api._meta.blobSupport ? 'blob' : 'base64';\n\n  preprocessAttachments(docInfos, blobType, function (err) {\n    if (err) {\n      return callback(err);\n    }\n    startTransaction();\n  });\n\n  function startTransaction() {\n\n    var stores = [\n      DOC_STORE, BY_SEQ_STORE,\n      ATTACH_STORE,\n      LOCAL_STORE, ATTACH_AND_SEQ_STORE,\n      META_STORE\n    ];\n    var txnResult = openTransactionSafely(idb, stores, 'readwrite');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    txn = txnResult.txn;\n    txn.onabort = idbError(callback);\n    txn.ontimeout = idbError(callback);\n    txn.oncomplete = complete;\n    docStore = txn.objectStore(DOC_STORE);\n    bySeqStore = txn.objectStore(BY_SEQ_STORE);\n    attachStore = txn.objectStore(ATTACH_STORE);\n    attachAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n    metaStore = txn.objectStore(META_STORE);\n\n    metaStore.get(META_STORE).onsuccess = function (e) {\n      metaDoc = e.target.result;\n      updateDocCountIfReady();\n    };\n\n    verifyAttachments(function (err) {\n      if (err) {\n        preconditionErrored = true;\n        return callback(err);\n      }\n      fetchExistingDocs();\n    });\n  }\n\n  function onAllDocsProcessed() {\n    allDocsProcessed = true;\n    updateDocCountIfReady();\n  }\n\n  function idbProcessDocs() {\n    processDocs(dbOpts.revs_limit, docInfos, api, fetchedDocs,\n                txn, results, writeDoc, opts, onAllDocsProcessed);\n  }\n\n  function updateDocCountIfReady() {\n    if (!metaDoc || !allDocsProcessed) {\n      return;\n    }\n    // caching the docCount saves a lot of time in allDocs() and\n    // info(), which is why we go to all the trouble of doing this\n    metaDoc.docCount += docCountDelta;\n    metaStore.put(metaDoc);\n  }\n\n  function fetchExistingDocs() {\n\n    if (!docInfos.length) {\n      return;\n    }\n\n    var numFetched = 0;\n\n    function checkDone() {\n      if (++numFetched === docInfos.length) {\n        idbProcessDocs();\n      }\n    }\n\n    function readMetadata(event) {\n      var metadata = decodeMetadata(event.target.result);\n\n      if (metadata) {\n        fetchedDocs.set(metadata.id, metadata);\n      }\n      checkDone();\n    }\n\n    for (var i = 0, len = docInfos.length; i < len; i++) {\n      var docInfo = docInfos[i];\n      if (docInfo._id && isLocalId(docInfo._id)) {\n        checkDone(); // skip local docs\n        continue;\n      }\n      var req = docStore.get(docInfo.metadata.id);\n      req.onsuccess = readMetadata;\n    }\n  }\n\n  function complete() {\n    if (preconditionErrored) {\n      return;\n    }\n\n    changesHandler$1.notify(api._meta.name);\n    callback(null, results);\n  }\n\n  function verifyAttachment(digest, callback) {\n\n    var req = attachStore.get(digest);\n    req.onsuccess = function (e) {\n      if (!e.target.result) {\n        var err = createError(MISSING_STUB,\n          'unknown stub attachment with digest ' +\n          digest);\n        err.status = 412;\n        callback(err);\n      } else {\n        callback();\n      }\n    };\n  }\n\n  function verifyAttachments(finish) {\n\n\n    var digests = [];\n    docInfos.forEach(function (docInfo) {\n      if (docInfo.data && docInfo.data._attachments) {\n        Object.keys(docInfo.data._attachments).forEach(function (filename) {\n          var att = docInfo.data._attachments[filename];\n          if (att.stub) {\n            digests.push(att.digest);\n          }\n        });\n      }\n    });\n    if (!digests.length) {\n      return finish();\n    }\n    var numDone = 0;\n    var err;\n\n    function checkDone() {\n      if (++numDone === digests.length) {\n        finish(err);\n      }\n    }\n    digests.forEach(function (digest) {\n      verifyAttachment(digest, function (attErr) {\n        if (attErr && !err) {\n          err = attErr;\n        }\n        checkDone();\n      });\n    });\n  }\n\n  function writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted,\n                    isUpdate, delta, resultsIdx, callback) {\n\n    docInfo.metadata.winningRev = winningRev$$1;\n    docInfo.metadata.deleted = winningRevIsDeleted;\n\n    var doc = docInfo.data;\n    doc._id = docInfo.metadata.id;\n    doc._rev = docInfo.metadata.rev;\n\n    if (newRevIsDeleted) {\n      doc._deleted = true;\n    }\n\n    var hasAttachments = doc._attachments &&\n      Object.keys(doc._attachments).length;\n    if (hasAttachments) {\n      return writeAttachments(docInfo, winningRev$$1, winningRevIsDeleted,\n        isUpdate, resultsIdx, callback);\n    }\n\n    docCountDelta += delta;\n    updateDocCountIfReady();\n\n    finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,\n      isUpdate, resultsIdx, callback);\n  }\n\n  function finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,\n                     isUpdate, resultsIdx, callback) {\n\n    var doc = docInfo.data;\n    var metadata = docInfo.metadata;\n\n    doc._doc_id_rev = metadata.id + '::' + metadata.rev;\n    delete doc._id;\n    delete doc._rev;\n\n    function afterPutDoc(e) {\n      var revsToDelete = docInfo.stemmedRevs || [];\n\n      if (isUpdate && api.auto_compaction) {\n        revsToDelete = revsToDelete.concat(compactTree(docInfo.metadata));\n      }\n\n      if (revsToDelete && revsToDelete.length) {\n        compactRevs(revsToDelete, docInfo.metadata.id, txn);\n      }\n\n      metadata.seq = e.target.result;\n      // Current _rev is calculated from _rev_tree on read\n      // delete metadata.rev;\n      var metadataToStore = encodeMetadata(metadata, winningRev$$1,\n        winningRevIsDeleted);\n      var metaDataReq = docStore.put(metadataToStore);\n      metaDataReq.onsuccess = afterPutMetadata;\n    }\n\n    function afterPutDocError(e) {\n      // ConstraintError, need to update, not put (see #1638 for details)\n      e.preventDefault(); // avoid transaction abort\n      e.stopPropagation(); // avoid transaction onerror\n      var index = bySeqStore.index('_doc_id_rev');\n      var getKeyReq = index.getKey(doc._doc_id_rev);\n      getKeyReq.onsuccess = function (e) {\n        var putReq = bySeqStore.put(doc, e.target.result);\n        putReq.onsuccess = afterPutDoc;\n      };\n    }\n\n    function afterPutMetadata() {\n      results[resultsIdx] = {\n        ok: true,\n        id: metadata.id,\n        rev: metadata.rev\n      };\n      fetchedDocs.set(docInfo.metadata.id, docInfo.metadata);\n      insertAttachmentMappings(docInfo, metadata.seq, callback);\n    }\n\n    var putReq = bySeqStore.put(doc);\n\n    putReq.onsuccess = afterPutDoc;\n    putReq.onerror = afterPutDocError;\n  }\n\n  function writeAttachments(docInfo, winningRev$$1, winningRevIsDeleted,\n                            isUpdate, resultsIdx, callback) {\n\n\n    var doc = docInfo.data;\n\n    var numDone = 0;\n    var attachments = Object.keys(doc._attachments);\n\n    function collectResults() {\n      if (numDone === attachments.length) {\n        finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,\n          isUpdate, resultsIdx, callback);\n      }\n    }\n\n    function attachmentSaved() {\n      numDone++;\n      collectResults();\n    }\n\n    attachments.forEach(function (key) {\n      var att = docInfo.data._attachments[key];\n      if (!att.stub) {\n        var data = att.data;\n        delete att.data;\n        att.revpos = parseInt(winningRev$$1, 10);\n        var digest = att.digest;\n        saveAttachment(digest, data, attachmentSaved);\n      } else {\n        numDone++;\n        collectResults();\n      }\n    });\n  }\n\n  // map seqs to attachment digests, which\n  // we will need later during compaction\n  function insertAttachmentMappings(docInfo, seq, callback) {\n\n    var attsAdded = 0;\n    var attsToAdd = Object.keys(docInfo.data._attachments || {});\n\n    if (!attsToAdd.length) {\n      return callback();\n    }\n\n    function checkDone() {\n      if (++attsAdded === attsToAdd.length) {\n        callback();\n      }\n    }\n\n    function add(att) {\n      var digest = docInfo.data._attachments[att].digest;\n      var req = attachAndSeqStore.put({\n        seq: seq,\n        digestSeq: digest + '::' + seq\n      });\n\n      req.onsuccess = checkDone;\n      req.onerror = function (e) {\n        // this callback is for a constaint error, which we ignore\n        // because this docid/rev has already been associated with\n        // the digest (e.g. when new_edits == false)\n        e.preventDefault(); // avoid transaction abort\n        e.stopPropagation(); // avoid transaction onerror\n        checkDone();\n      };\n    }\n    for (var i = 0; i < attsToAdd.length; i++) {\n      add(attsToAdd[i]); // do in parallel\n    }\n  }\n\n  function saveAttachment(digest, data, callback) {\n\n\n    var getKeyReq = attachStore.count(digest);\n    getKeyReq.onsuccess = function (e) {\n      var count = e.target.result;\n      if (count) {\n        return callback(); // already exists\n      }\n      var newAtt = {\n        digest: digest,\n        body: data\n      };\n      var putReq = attachStore.put(newAtt);\n      putReq.onsuccess = callback;\n    };\n  }\n}\n\n// Abstraction over IDBCursor and getAll()/getAllKeys() that allows us to batch our operations\n// while falling back to a normal IDBCursor operation on browsers that don't support getAll() or\n// getAllKeys(). This allows for a much faster implementation than just straight-up cursors, because\n// we're not processing each document one-at-a-time.\nfunction runBatchedCursor(objectStore, keyRange, descending, batchSize, onBatch) {\n\n  if (batchSize === -1) {\n    batchSize = 1000;\n  }\n\n  // Bail out of getAll()/getAllKeys() in the following cases:\n  // 1) either method is unsupported - we need both\n  // 2) batchSize is 1 (might as well use IDBCursor)\n  // 3) descending â€“ no real way to do this via getAll()/getAllKeys()\n\n  var useGetAll = typeof objectStore.getAll === 'function' &&\n    typeof objectStore.getAllKeys === 'function' &&\n    batchSize > 1 && !descending;\n\n  var keysBatch;\n  var valuesBatch;\n  var pseudoCursor;\n\n  function onGetAll(e) {\n    valuesBatch = e.target.result;\n    if (keysBatch) {\n      onBatch(keysBatch, valuesBatch, pseudoCursor);\n    }\n  }\n\n  function onGetAllKeys(e) {\n    keysBatch = e.target.result;\n    if (valuesBatch) {\n      onBatch(keysBatch, valuesBatch, pseudoCursor);\n    }\n  }\n\n  function continuePseudoCursor() {\n    if (!keysBatch.length) { // no more results\n      return onBatch();\n    }\n    // fetch next batch, exclusive start\n    var lastKey = keysBatch[keysBatch.length - 1];\n    var newKeyRange;\n    if (keyRange && keyRange.upper) {\n      try {\n        newKeyRange = IDBKeyRange.bound(lastKey, keyRange.upper,\n          true, keyRange.upperOpen);\n      } catch (e) {\n        if (e.name === \"DataError\" && e.code === 0) {\n          return onBatch(); // we're done, startkey and endkey are equal\n        }\n      }\n    } else {\n      newKeyRange = IDBKeyRange.lowerBound(lastKey, true);\n    }\n    keyRange = newKeyRange;\n    keysBatch = null;\n    valuesBatch = null;\n    objectStore.getAll(keyRange, batchSize).onsuccess = onGetAll;\n    objectStore.getAllKeys(keyRange, batchSize).onsuccess = onGetAllKeys;\n  }\n\n  function onCursor(e) {\n    var cursor = e.target.result;\n    if (!cursor) { // done\n      return onBatch();\n    }\n    // regular IDBCursor acts like a batch where batch size is always 1\n    onBatch([cursor.key], [cursor.value], cursor);\n  }\n\n  if (useGetAll) {\n    pseudoCursor = {\"continue\": continuePseudoCursor};\n    objectStore.getAll(keyRange, batchSize).onsuccess = onGetAll;\n    objectStore.getAllKeys(keyRange, batchSize).onsuccess = onGetAllKeys;\n  } else if (descending) {\n    objectStore.openCursor(keyRange, 'prev').onsuccess = onCursor;\n  } else {\n    objectStore.openCursor(keyRange).onsuccess = onCursor;\n  }\n}\n\n// simple shim for objectStore.getAll(), falling back to IDBCursor\nfunction getAll(objectStore, keyRange, onSuccess) {\n  if (typeof objectStore.getAll === 'function') {\n    // use native getAll\n    objectStore.getAll(keyRange).onsuccess = onSuccess;\n    return;\n  }\n  // fall back to cursors\n  var values = [];\n\n  function onCursor(e) {\n    var cursor = e.target.result;\n    if (cursor) {\n      values.push(cursor.value);\n      cursor.continue();\n    } else {\n      onSuccess({\n        target: {\n          result: values\n        }\n      });\n    }\n  }\n\n  objectStore.openCursor(keyRange).onsuccess = onCursor;\n}\n\nfunction allDocsKeys(keys, docStore, onBatch) {\n  // It's not guaranted to be returned in right order  \n  var valuesBatch = new Array(keys.length);\n  var count = 0;\n  keys.forEach(function (key, index) {\n    docStore.get(key).onsuccess = function (event) {\n      if (event.target.result) {\n        valuesBatch[index] = event.target.result;\n      } else {\n        valuesBatch[index] = {key: key, error: 'not_found'};\n      }\n      count++;\n      if (count === keys.length) {\n        onBatch(keys, valuesBatch, {});\n      }\n    };\n  });\n}\n\nfunction createKeyRange(start, end, inclusiveEnd, key, descending) {\n  try {\n    if (start && end) {\n      if (descending) {\n        return IDBKeyRange.bound(end, start, !inclusiveEnd, false);\n      } else {\n        return IDBKeyRange.bound(start, end, false, !inclusiveEnd);\n      }\n    } else if (start) {\n      if (descending) {\n        return IDBKeyRange.upperBound(start);\n      } else {\n        return IDBKeyRange.lowerBound(start);\n      }\n    } else if (end) {\n      if (descending) {\n        return IDBKeyRange.lowerBound(end, !inclusiveEnd);\n      } else {\n        return IDBKeyRange.upperBound(end, !inclusiveEnd);\n      }\n    } else if (key) {\n      return IDBKeyRange.only(key);\n    }\n  } catch (e) {\n    return {error: e};\n  }\n  return null;\n}\n\nfunction idbAllDocs(opts, idb, callback) {\n  var start = 'startkey' in opts ? opts.startkey : false;\n  var end = 'endkey' in opts ? opts.endkey : false;\n  var key = 'key' in opts ? opts.key : false;\n  var keys = 'keys' in opts ? opts.keys : false; \n  var skip = opts.skip || 0;\n  var limit = typeof opts.limit === 'number' ? opts.limit : -1;\n  var inclusiveEnd = opts.inclusive_end !== false;\n\n  var keyRange ; \n  var keyRangeError;\n  if (!keys) {\n    keyRange = createKeyRange(start, end, inclusiveEnd, key, opts.descending);\n    keyRangeError = keyRange && keyRange.error;\n    if (keyRangeError && \n      !(keyRangeError.name === \"DataError\" && keyRangeError.code === 0)) {\n      // DataError with error code 0 indicates start is less than end, so\n      // can just do an empty query. Else need to throw\n      return callback(createError(IDB_ERROR,\n        keyRangeError.name, keyRangeError.message));\n    }\n  }\n\n  var stores = [DOC_STORE, BY_SEQ_STORE, META_STORE];\n\n  if (opts.attachments) {\n    stores.push(ATTACH_STORE);\n  }\n  var txnResult = openTransactionSafely(idb, stores, 'readonly');\n  if (txnResult.error) {\n    return callback(txnResult.error);\n  }\n  var txn = txnResult.txn;\n  txn.oncomplete = onTxnComplete;\n  txn.onabort = idbError(callback);\n  var docStore = txn.objectStore(DOC_STORE);\n  var seqStore = txn.objectStore(BY_SEQ_STORE);\n  var metaStore = txn.objectStore(META_STORE);\n  var docIdRevIndex = seqStore.index('_doc_id_rev');\n  var results = [];\n  var docCount;\n  var updateSeq;\n\n  metaStore.get(META_STORE).onsuccess = function (e) {\n    docCount = e.target.result.docCount;\n  };\n\n  /* istanbul ignore if */\n  if (opts.update_seq) {\n    getMaxUpdateSeq(seqStore, function (e) { \n      if (e.target.result && e.target.result.length > 0) {\n        updateSeq = e.target.result[0];\n      }\n    });\n  }\n\n  function getMaxUpdateSeq(objectStore, onSuccess) {\n    function onCursor(e) {\n      var cursor = e.target.result;\n      var maxKey = undefined;\n      if (cursor && cursor.key) {\n        maxKey = cursor.key;\n      } \n      return onSuccess({\n        target: {\n          result: [maxKey]\n        }\n      });\n    }\n    objectStore.openCursor(null, 'prev').onsuccess = onCursor;\n  }\n\n  // if the user specifies include_docs=true, then we don't\n  // want to block the main cursor while we're fetching the doc\n  function fetchDocAsynchronously(metadata, row, winningRev$$1) {\n    var key = metadata.id + \"::\" + winningRev$$1;\n    docIdRevIndex.get(key).onsuccess =  function onGetDoc(e) {\n      row.doc = decodeDoc(e.target.result) || {};\n      if (opts.conflicts) {\n        var conflicts = collectConflicts(metadata);\n        if (conflicts.length) {\n          row.doc._conflicts = conflicts;\n        }\n      }\n      fetchAttachmentsIfNecessary(row.doc, opts, txn);\n    };\n  }\n\n  function allDocsInner(winningRev$$1, metadata) {\n    var row = {\n      id: metadata.id,\n      key: metadata.id,\n      value: {\n        rev: winningRev$$1\n      }\n    };\n    var deleted = metadata.deleted;\n    if (deleted) {\n      if (keys) {\n        results.push(row);\n        // deleted docs are okay with \"keys\" requests\n        row.value.deleted = true;\n        row.doc = null;\n      }\n    } else if (skip-- <= 0) {\n      results.push(row);\n      if (opts.include_docs) {\n        fetchDocAsynchronously(metadata, row, winningRev$$1);\n      }\n    }\n  }\n\n  function processBatch(batchValues) {\n    for (var i = 0, len = batchValues.length; i < len; i++) {\n      if (results.length === limit) {\n        break;\n      }\n      var batchValue = batchValues[i];\n      if (batchValue.error && keys) {\n        // key was not found with \"keys\" requests\n        results.push(batchValue);\n        continue;\n      }\n      var metadata = decodeMetadata(batchValue);\n      var winningRev$$1 = metadata.winningRev;\n      allDocsInner(winningRev$$1, metadata);\n    }\n  }\n\n  function onBatch(batchKeys, batchValues, cursor) {\n    if (!cursor) {\n      return;\n    }\n    processBatch(batchValues);\n    if (results.length < limit) {\n      cursor.continue();\n    }\n  }\n\n  function onGetAll(e) {\n    var values = e.target.result;\n    if (opts.descending) {\n      values = values.reverse();\n    }\n    processBatch(values);\n  }\n\n  function onResultsReady() {\n    var returnVal = {\n      total_rows: docCount,\n      offset: opts.skip,\n      rows: results\n    };\n    \n    /* istanbul ignore if */\n    if (opts.update_seq && updateSeq !== undefined) {\n      returnVal.update_seq = updateSeq;\n    }\n    callback(null, returnVal);\n  }\n\n  function onTxnComplete() {\n    if (opts.attachments) {\n      postProcessAttachments(results, opts.binary).then(onResultsReady);\n    } else {\n      onResultsReady();\n    }\n  }\n\n  // don't bother doing any requests if start > end or limit === 0\n  if (keyRangeError || limit === 0) {\n    return;\n  }\n  if (keys) {\n    return allDocsKeys(opts.keys, docStore, onBatch);\n  }\n  if (limit === -1) { // just fetch everything\n    return getAll(docStore, keyRange, onGetAll);\n  }\n  // else do a cursor\n  // choose a batch size based on the skip, since we'll need to skip that many\n  runBatchedCursor(docStore, keyRange, opts.descending, limit + skip, onBatch);\n}\n\n//\n// Blobs are not supported in all versions of IndexedDB, notably\n// Chrome <37 and Android <5. In those versions, storing a blob will throw.\n//\n// Various other blob bugs exist in Chrome v37-42 (inclusive).\n// Detecting them is expensive and confusing to users, and Chrome 37-42\n// is at very low usage worldwide, so we do a hacky userAgent check instead.\n//\n// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120\n// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916\n// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836\n//\nfunction checkBlobSupport(txn) {\n  return new Promise(function (resolve) {\n    var blob$$1 = blob(['']);\n    var req = txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob$$1, 'key');\n\n    req.onsuccess = function () {\n      var matchedChrome = navigator.userAgent.match(/Chrome\\/(\\d+)/);\n      var matchedEdge = navigator.userAgent.match(/Edge\\//);\n      // MS Edge pretends to be Chrome 42:\n      // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx\n      resolve(matchedEdge || !matchedChrome ||\n        parseInt(matchedChrome[1], 10) >= 43);\n    };\n\n    req.onerror = txn.onabort = function (e) {\n      // If the transaction aborts now its due to not being able to\n      // write to the database, likely due to the disk being full\n      e.preventDefault();\n      e.stopPropagation();\n      resolve(false);\n    };\n  }).catch(function () {\n    return false; // error, so assume unsupported\n  });\n}\n\nfunction countDocs(txn, cb) {\n  var index = txn.objectStore(DOC_STORE).index('deletedOrLocal');\n  index.count(IDBKeyRange.only('0')).onsuccess = function (e) {\n    cb(e.target.result);\n  };\n}\n\n// This task queue ensures that IDB open calls are done in their own tick\n\nvar running = false;\nvar queue = [];\n\nfunction tryCode(fun, err, res, PouchDB) {\n  try {\n    fun(err, res);\n  } catch (err) {\n    // Shouldn't happen, but in some odd cases\n    // IndexedDB implementations might throw a sync\n    // error, in which case this will at least log it.\n    PouchDB.emit('error', err);\n  }\n}\n\nfunction applyNext() {\n  if (running || !queue.length) {\n    return;\n  }\n  running = true;\n  queue.shift()();\n}\n\nfunction enqueueTask(action, callback, PouchDB) {\n  queue.push(function runAction() {\n    action(function runCallback(err, res) {\n      tryCode(callback, err, res, PouchDB);\n      running = false;\n      nextTick(function runNext() {\n        applyNext(PouchDB);\n      });\n    });\n  });\n  applyNext();\n}\n\nfunction changes(opts, api, dbName, idb) {\n  opts = clone(opts);\n\n  if (opts.continuous) {\n    var id = dbName + ':' + uuid();\n    changesHandler$1.addListener(dbName, id, api, opts);\n    changesHandler$1.notify(dbName);\n    return {\n      cancel: function () {\n        changesHandler$1.removeListener(dbName, id);\n      }\n    };\n  }\n\n  var docIds = opts.doc_ids && new Set(opts.doc_ids);\n\n  opts.since = opts.since || 0;\n  var lastSeq = opts.since;\n\n  var limit = 'limit' in opts ? opts.limit : -1;\n  if (limit === 0) {\n    limit = 1; // per CouchDB _changes spec\n  }\n\n  var results = [];\n  var numResults = 0;\n  var filter = filterChange(opts);\n  var docIdsToMetadata = new Map();\n\n  var txn;\n  var bySeqStore;\n  var docStore;\n  var docIdRevIndex;\n\n  function onBatch(batchKeys, batchValues, cursor) {\n    if (!cursor || !batchKeys.length) { // done\n      return;\n    }\n\n    var winningDocs = new Array(batchKeys.length);\n    var metadatas = new Array(batchKeys.length);\n\n    function processMetadataAndWinningDoc(metadata, winningDoc) {\n      var change = opts.processChange(winningDoc, metadata, opts);\n      lastSeq = change.seq = metadata.seq;\n\n      var filtered = filter(change);\n      if (typeof filtered === 'object') { // anything but true/false indicates error\n        return Promise.reject(filtered);\n      }\n\n      if (!filtered) {\n        return Promise.resolve();\n      }\n      numResults++;\n      if (opts.return_docs) {\n        results.push(change);\n      }\n      // process the attachment immediately\n      // for the benefit of live listeners\n      if (opts.attachments && opts.include_docs) {\n        return new Promise(function (resolve) {\n          fetchAttachmentsIfNecessary(winningDoc, opts, txn, function () {\n            postProcessAttachments([change], opts.binary).then(function () {\n              resolve(change);\n            });\n          });\n        });\n      } else {\n        return Promise.resolve(change);\n      }\n    }\n\n    function onBatchDone() {\n      var promises = [];\n      for (var i = 0, len = winningDocs.length; i < len; i++) {\n        if (numResults === limit) {\n          break;\n        }\n        var winningDoc = winningDocs[i];\n        if (!winningDoc) {\n          continue;\n        }\n        var metadata = metadatas[i];\n        promises.push(processMetadataAndWinningDoc(metadata, winningDoc));\n      }\n\n      Promise.all(promises).then(function (changes) {\n        for (var i = 0, len = changes.length; i < len; i++) {\n          if (changes[i]) {\n            opts.onChange(changes[i]);\n          }\n        }\n      }).catch(opts.complete);\n\n      if (numResults !== limit) {\n        cursor.continue();\n      }\n    }\n\n    // Fetch all metadatas/winningdocs from this batch in parallel, then process\n    // them all only once all data has been collected. This is done in parallel\n    // because it's faster than doing it one-at-a-time.\n    var numDone = 0;\n    batchValues.forEach(function (value, i) {\n      var doc = decodeDoc(value);\n      var seq = batchKeys[i];\n      fetchWinningDocAndMetadata(doc, seq, function (metadata, winningDoc) {\n        metadatas[i] = metadata;\n        winningDocs[i] = winningDoc;\n        if (++numDone === batchKeys.length) {\n          onBatchDone();\n        }\n      });\n    });\n  }\n\n  function onGetMetadata(doc, seq, metadata, cb) {\n    if (metadata.seq !== seq) {\n      // some other seq is later\n      return cb();\n    }\n\n    if (metadata.winningRev === doc._rev) {\n      // this is the winning doc\n      return cb(metadata, doc);\n    }\n\n    // fetch winning doc in separate request\n    var docIdRev = doc._id + '::' + metadata.winningRev;\n    var req = docIdRevIndex.get(docIdRev);\n    req.onsuccess = function (e) {\n      cb(metadata, decodeDoc(e.target.result));\n    };\n  }\n\n  function fetchWinningDocAndMetadata(doc, seq, cb) {\n    if (docIds && !docIds.has(doc._id)) {\n      return cb();\n    }\n\n    var metadata = docIdsToMetadata.get(doc._id);\n    if (metadata) { // cached\n      return onGetMetadata(doc, seq, metadata, cb);\n    }\n    // metadata not cached, have to go fetch it\n    docStore.get(doc._id).onsuccess = function (e) {\n      metadata = decodeMetadata(e.target.result);\n      docIdsToMetadata.set(doc._id, metadata);\n      onGetMetadata(doc, seq, metadata, cb);\n    };\n  }\n\n  function finish() {\n    opts.complete(null, {\n      results: results,\n      last_seq: lastSeq\n    });\n  }\n\n  function onTxnComplete() {\n    if (!opts.continuous && opts.attachments) {\n      // cannot guarantee that postProcessing was already done,\n      // so do it again\n      postProcessAttachments(results).then(finish);\n    } else {\n      finish();\n    }\n  }\n\n  var objectStores = [DOC_STORE, BY_SEQ_STORE];\n  if (opts.attachments) {\n    objectStores.push(ATTACH_STORE);\n  }\n  var txnResult = openTransactionSafely(idb, objectStores, 'readonly');\n  if (txnResult.error) {\n    return opts.complete(txnResult.error);\n  }\n  txn = txnResult.txn;\n  txn.onabort = idbError(opts.complete);\n  txn.oncomplete = onTxnComplete;\n\n  bySeqStore = txn.objectStore(BY_SEQ_STORE);\n  docStore = txn.objectStore(DOC_STORE);\n  docIdRevIndex = bySeqStore.index('_doc_id_rev');\n\n  var keyRange = (opts.since && !opts.descending) ?\n    IDBKeyRange.lowerBound(opts.since, true) : null;\n\n  runBatchedCursor(bySeqStore, keyRange, opts.descending, limit, onBatch);\n}\n\nvar cachedDBs = new Map();\nvar blobSupportPromise;\nvar openReqList = new Map();\n\nfunction IdbPouch(opts, callback) {\n  var api = this;\n\n  enqueueTask(function (thisCallback) {\n    init(api, opts, thisCallback);\n  }, callback, api.constructor);\n}\n\nfunction init(api, opts, callback) {\n\n  var dbName = opts.name;\n\n  var idb = null;\n  api._meta = null;\n\n  // called when creating a fresh new database\n  function createSchema(db) {\n    var docStore = db.createObjectStore(DOC_STORE, {keyPath : 'id'});\n    db.createObjectStore(BY_SEQ_STORE, {autoIncrement: true})\n      .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});\n    db.createObjectStore(ATTACH_STORE, {keyPath: 'digest'});\n    db.createObjectStore(META_STORE, {keyPath: 'id', autoIncrement: false});\n    db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);\n\n    // added in v2\n    docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {unique : false});\n\n    // added in v3\n    db.createObjectStore(LOCAL_STORE, {keyPath: '_id'});\n\n    // added in v4\n    var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE,\n      {autoIncrement: true});\n    attAndSeqStore.createIndex('seq', 'seq');\n    attAndSeqStore.createIndex('digestSeq', 'digestSeq', {unique: true});\n  }\n\n  // migration to version 2\n  // unfortunately \"deletedOrLocal\" is a misnomer now that we no longer\n  // store local docs in the main doc-store, but whaddyagonnado\n  function addDeletedOrLocalIndex(txn, callback) {\n    var docStore = txn.objectStore(DOC_STORE);\n    docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {unique : false});\n\n    docStore.openCursor().onsuccess = function (event) {\n      var cursor = event.target.result;\n      if (cursor) {\n        var metadata = cursor.value;\n        var deleted = isDeleted(metadata);\n        metadata.deletedOrLocal = deleted ? \"1\" : \"0\";\n        docStore.put(metadata);\n        cursor.continue();\n      } else {\n        callback();\n      }\n    };\n  }\n\n  // migration to version 3 (part 1)\n  function createLocalStoreSchema(db) {\n    db.createObjectStore(LOCAL_STORE, {keyPath: '_id'})\n      .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});\n  }\n\n  // migration to version 3 (part 2)\n  function migrateLocalStore(txn, cb) {\n    var localStore = txn.objectStore(LOCAL_STORE);\n    var docStore = txn.objectStore(DOC_STORE);\n    var seqStore = txn.objectStore(BY_SEQ_STORE);\n\n    var cursor = docStore.openCursor();\n    cursor.onsuccess = function (event) {\n      var cursor = event.target.result;\n      if (cursor) {\n        var metadata = cursor.value;\n        var docId = metadata.id;\n        var local = isLocalId$1(docId);\n        var rev = winningRev(metadata);\n        if (local) {\n          var docIdRev = docId + \"::\" + rev;\n          // remove all seq entries\n          // associated with this docId\n          var start = docId + \"::\";\n          var end = docId + \"::~\";\n          var index = seqStore.index('_doc_id_rev');\n          var range = IDBKeyRange.bound(start, end, false, false);\n          var seqCursor = index.openCursor(range);\n          seqCursor.onsuccess = function (e) {\n            seqCursor = e.target.result;\n            if (!seqCursor) {\n              // done\n              docStore.delete(cursor.primaryKey);\n              cursor.continue();\n            } else {\n              var data = seqCursor.value;\n              if (data._doc_id_rev === docIdRev) {\n                localStore.put(data);\n              }\n              seqStore.delete(seqCursor.primaryKey);\n              seqCursor.continue();\n            }\n          };\n        } else {\n          cursor.continue();\n        }\n      } else if (cb) {\n        cb();\n      }\n    };\n  }\n\n  // migration to version 4 (part 1)\n  function addAttachAndSeqStore(db) {\n    var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE,\n      {autoIncrement: true});\n    attAndSeqStore.createIndex('seq', 'seq');\n    attAndSeqStore.createIndex('digestSeq', 'digestSeq', {unique: true});\n  }\n\n  // migration to version 4 (part 2)\n  function migrateAttsAndSeqs(txn, callback) {\n    var seqStore = txn.objectStore(BY_SEQ_STORE);\n    var attStore = txn.objectStore(ATTACH_STORE);\n    var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n\n    // need to actually populate the table. this is the expensive part,\n    // so as an optimization, check first that this database even\n    // contains attachments\n    var req = attStore.count();\n    req.onsuccess = function (e) {\n      var count = e.target.result;\n      if (!count) {\n        return callback(); // done\n      }\n\n      seqStore.openCursor().onsuccess = function (e) {\n        var cursor = e.target.result;\n        if (!cursor) {\n          return callback(); // done\n        }\n        var doc = cursor.value;\n        var seq = cursor.primaryKey;\n        var atts = Object.keys(doc._attachments || {});\n        var digestMap = {};\n        for (var j = 0; j < atts.length; j++) {\n          var att = doc._attachments[atts[j]];\n          digestMap[att.digest] = true; // uniq digests, just in case\n        }\n        var digests = Object.keys(digestMap);\n        for (j = 0; j < digests.length; j++) {\n          var digest = digests[j];\n          attAndSeqStore.put({\n            seq: seq,\n            digestSeq: digest + '::' + seq\n          });\n        }\n        cursor.continue();\n      };\n    };\n  }\n\n  // migration to version 5\n  // Instead of relying on on-the-fly migration of metadata,\n  // this brings the doc-store to its modern form:\n  // - metadata.winningrev\n  // - metadata.seq\n  // - stringify the metadata when storing it\n  function migrateMetadata(txn) {\n\n    function decodeMetadataCompat(storedObject) {\n      if (!storedObject.data) {\n        // old format, when we didn't store it stringified\n        storedObject.deleted = storedObject.deletedOrLocal === '1';\n        return storedObject;\n      }\n      return decodeMetadata(storedObject);\n    }\n\n    // ensure that every metadata has a winningRev and seq,\n    // which was previously created on-the-fly but better to migrate\n    var bySeqStore = txn.objectStore(BY_SEQ_STORE);\n    var docStore = txn.objectStore(DOC_STORE);\n    var cursor = docStore.openCursor();\n    cursor.onsuccess = function (e) {\n      var cursor = e.target.result;\n      if (!cursor) {\n        return; // done\n      }\n      var metadata = decodeMetadataCompat(cursor.value);\n\n      metadata.winningRev = metadata.winningRev ||\n        winningRev(metadata);\n\n      function fetchMetadataSeq() {\n        // metadata.seq was added post-3.2.0, so if it's missing,\n        // we need to fetch it manually\n        var start = metadata.id + '::';\n        var end = metadata.id + '::\\uffff';\n        var req = bySeqStore.index('_doc_id_rev').openCursor(\n          IDBKeyRange.bound(start, end));\n\n        var metadataSeq = 0;\n        req.onsuccess = function (e) {\n          var cursor = e.target.result;\n          if (!cursor) {\n            metadata.seq = metadataSeq;\n            return onGetMetadataSeq();\n          }\n          var seq = cursor.primaryKey;\n          if (seq > metadataSeq) {\n            metadataSeq = seq;\n          }\n          cursor.continue();\n        };\n      }\n\n      function onGetMetadataSeq() {\n        var metadataToStore = encodeMetadata(metadata,\n          metadata.winningRev, metadata.deleted);\n\n        var req = docStore.put(metadataToStore);\n        req.onsuccess = function () {\n          cursor.continue();\n        };\n      }\n\n      if (metadata.seq) {\n        return onGetMetadataSeq();\n      }\n\n      fetchMetadataSeq();\n    };\n\n  }\n\n  api._remote = false;\n  api.type = function () {\n    return 'idb';\n  };\n\n  api._id = toPromise(function (callback) {\n    callback(null, api._meta.instanceId);\n  });\n\n  api._bulkDocs = function idb_bulkDocs(req, reqOpts, callback) {\n    idbBulkDocs(opts, req, reqOpts, api, idb, callback);\n  };\n\n  // First we look up the metadata in the ids database, then we fetch the\n  // current revision(s) from the by sequence store\n  api._get = function idb_get(id, opts, callback) {\n    var doc;\n    var metadata;\n    var err;\n    var txn = opts.ctx;\n    if (!txn) {\n      var txnResult = openTransactionSafely(idb,\n        [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      txn = txnResult.txn;\n    }\n\n    function finish() {\n      callback(err, {doc: doc, metadata: metadata, ctx: txn});\n    }\n\n    txn.objectStore(DOC_STORE).get(id).onsuccess = function (e) {\n      metadata = decodeMetadata(e.target.result);\n      // we can determine the result here if:\n      // 1. there is no such document\n      // 2. the document is deleted and we don't ask about specific rev\n      // When we ask with opts.rev we expect the answer to be either\n      // doc (possibly with _deleted=true) or missing error\n      if (!metadata) {\n        err = createError(MISSING_DOC, 'missing');\n        return finish();\n      }\n\n      var rev;\n      if (!opts.rev) {\n        rev = metadata.winningRev;\n        var deleted = isDeleted(metadata);\n        if (deleted) {\n          err = createError(MISSING_DOC, \"deleted\");\n          return finish();\n        }\n      } else {\n        rev = opts.latest ? latest(opts.rev, metadata) : opts.rev;\n      }\n\n      var objectStore = txn.objectStore(BY_SEQ_STORE);\n      var key = metadata.id + '::' + rev;\n\n      objectStore.index('_doc_id_rev').get(key).onsuccess = function (e) {\n        doc = e.target.result;\n        if (doc) {\n          doc = decodeDoc(doc);\n        }\n        if (!doc) {\n          err = createError(MISSING_DOC, 'missing');\n          return finish();\n        }\n        finish();\n      };\n    };\n  };\n\n  api._getAttachment = function (docId, attachId, attachment, opts, callback) {\n    var txn;\n    if (opts.ctx) {\n      txn = opts.ctx;\n    } else {\n      var txnResult = openTransactionSafely(idb,\n        [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      txn = txnResult.txn;\n    }\n    var digest = attachment.digest;\n    var type = attachment.content_type;\n\n    txn.objectStore(ATTACH_STORE).get(digest).onsuccess = function (e) {\n      var body = e.target.result.body;\n      readBlobData(body, type, opts.binary, function (blobData) {\n        callback(null, blobData);\n      });\n    };\n  };\n\n  api._info = function idb_info(callback) {\n    var updateSeq;\n    var docCount;\n\n    var txnResult = openTransactionSafely(idb, [META_STORE, BY_SEQ_STORE], 'readonly');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var txn = txnResult.txn;\n    txn.objectStore(META_STORE).get(META_STORE).onsuccess = function (e) {\n      docCount = e.target.result.docCount;\n    };\n    txn.objectStore(BY_SEQ_STORE).openCursor(null, 'prev').onsuccess = function (e) {\n      var cursor = e.target.result;\n      updateSeq = cursor ? cursor.key : 0;\n    };\n\n    txn.oncomplete = function () {\n      callback(null, {\n        doc_count: docCount,\n        update_seq: updateSeq,\n        // for debugging\n        idb_attachment_format: (api._meta.blobSupport ? 'binary' : 'base64')\n      });\n    };\n  };\n\n  api._allDocs = function idb_allDocs(opts, callback) {\n    idbAllDocs(opts, idb, callback);\n  };\n\n  api._changes = function idbChanges(opts) {\n    return changes(opts, api, dbName, idb);\n  };\n\n  api._close = function (callback) {\n    // https://developer.mozilla.org/en-US/docs/IndexedDB/IDBDatabase#close\n    // \"Returns immediately and closes the connection in a separate thread...\"\n    idb.close();\n    cachedDBs.delete(dbName);\n    callback();\n  };\n\n  api._getRevisionTree = function (docId, callback) {\n    var txnResult = openTransactionSafely(idb, [DOC_STORE], 'readonly');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var txn = txnResult.txn;\n    var req = txn.objectStore(DOC_STORE).get(docId);\n    req.onsuccess = function (event) {\n      var doc = decodeMetadata(event.target.result);\n      if (!doc) {\n        callback(createError(MISSING_DOC));\n      } else {\n        callback(null, doc.rev_tree);\n      }\n    };\n  };\n\n  // This function removes revisions of document docId\n  // which are listed in revs and sets this document\n  // revision to to rev_tree\n  api._doCompaction = function (docId, revs, callback) {\n    var stores = [\n      DOC_STORE,\n      BY_SEQ_STORE,\n      ATTACH_STORE,\n      ATTACH_AND_SEQ_STORE\n    ];\n    var txnResult = openTransactionSafely(idb, stores, 'readwrite');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var txn = txnResult.txn;\n\n    var docStore = txn.objectStore(DOC_STORE);\n\n    docStore.get(docId).onsuccess = function (event) {\n      var metadata = decodeMetadata(event.target.result);\n      traverseRevTree(metadata.rev_tree, function (isLeaf, pos,\n                                                         revHash, ctx, opts) {\n        var rev = pos + '-' + revHash;\n        if (revs.indexOf(rev) !== -1) {\n          opts.status = 'missing';\n        }\n      });\n      compactRevs(revs, docId, txn);\n      var winningRev$$1 = metadata.winningRev;\n      var deleted = metadata.deleted;\n      txn.objectStore(DOC_STORE).put(\n        encodeMetadata(metadata, winningRev$$1, deleted));\n    };\n    txn.onabort = idbError(callback);\n    txn.oncomplete = function () {\n      callback();\n    };\n  };\n\n\n  api._getLocal = function (id, callback) {\n    var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readonly');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var tx = txnResult.txn;\n    var req = tx.objectStore(LOCAL_STORE).get(id);\n\n    req.onerror = idbError(callback);\n    req.onsuccess = function (e) {\n      var doc = e.target.result;\n      if (!doc) {\n        callback(createError(MISSING_DOC));\n      } else {\n        delete doc['_doc_id_rev']; // for backwards compat\n        callback(null, doc);\n      }\n    };\n  };\n\n  api._putLocal = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    delete doc._revisions; // ignore this, trust the rev\n    var oldRev = doc._rev;\n    var id = doc._id;\n    if (!oldRev) {\n      doc._rev = '0-1';\n    } else {\n      doc._rev = '0-' + (parseInt(oldRev.split('-')[1], 10) + 1);\n    }\n\n    var tx = opts.ctx;\n    var ret;\n    if (!tx) {\n      var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      tx = txnResult.txn;\n      tx.onerror = idbError(callback);\n      tx.oncomplete = function () {\n        if (ret) {\n          callback(null, ret);\n        }\n      };\n    }\n\n    var oStore = tx.objectStore(LOCAL_STORE);\n    var req;\n    if (oldRev) {\n      req = oStore.get(id);\n      req.onsuccess = function (e) {\n        var oldDoc = e.target.result;\n        if (!oldDoc || oldDoc._rev !== oldRev) {\n          callback(createError(REV_CONFLICT));\n        } else { // update\n          var req = oStore.put(doc);\n          req.onsuccess = function () {\n            ret = {ok: true, id: doc._id, rev: doc._rev};\n            if (opts.ctx) { // return immediately\n              callback(null, ret);\n            }\n          };\n        }\n      };\n    } else { // new doc\n      req = oStore.add(doc);\n      req.onerror = function (e) {\n        // constraint error, already exists\n        callback(createError(REV_CONFLICT));\n        e.preventDefault(); // avoid transaction abort\n        e.stopPropagation(); // avoid transaction onerror\n      };\n      req.onsuccess = function () {\n        ret = {ok: true, id: doc._id, rev: doc._rev};\n        if (opts.ctx) { // return immediately\n          callback(null, ret);\n        }\n      };\n    }\n  };\n\n  api._removeLocal = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    var tx = opts.ctx;\n    if (!tx) {\n      var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      tx = txnResult.txn;\n      tx.oncomplete = function () {\n        if (ret) {\n          callback(null, ret);\n        }\n      };\n    }\n    var ret;\n    var id = doc._id;\n    var oStore = tx.objectStore(LOCAL_STORE);\n    var req = oStore.get(id);\n\n    req.onerror = idbError(callback);\n    req.onsuccess = function (e) {\n      var oldDoc = e.target.result;\n      if (!oldDoc || oldDoc._rev !== doc._rev) {\n        callback(createError(MISSING_DOC));\n      } else {\n        oStore.delete(id);\n        ret = {ok: true, id: id, rev: '0-0'};\n        if (opts.ctx) { // return immediately\n          callback(null, ret);\n        }\n      }\n    };\n  };\n\n  api._destroy = function (opts, callback) {\n    changesHandler$1.removeAllListeners(dbName);\n\n    //Close open request for \"dbName\" database to fix ie delay.\n    var openReq = openReqList.get(dbName);\n    if (openReq && openReq.result) {\n      openReq.result.close();\n      cachedDBs.delete(dbName);\n    }\n    var req = indexedDB.deleteDatabase(dbName);\n\n    req.onsuccess = function () {\n      //Remove open request from the list.\n      openReqList.delete(dbName);\n      if (hasLocalStorage() && (dbName in localStorage)) {\n        delete localStorage[dbName];\n      }\n      callback(null, { 'ok': true });\n    };\n\n    req.onerror = idbError(callback);\n  };\n\n  var cached = cachedDBs.get(dbName);\n\n  if (cached) {\n    idb = cached.idb;\n    api._meta = cached.global;\n    return nextTick(function () {\n      callback(null, api);\n    });\n  }\n\n  var req = indexedDB.open(dbName, ADAPTER_VERSION);\n  openReqList.set(dbName, req);\n\n  req.onupgradeneeded = function (e) {\n    var db = e.target.result;\n    if (e.oldVersion < 1) {\n      return createSchema(db); // new db, initial schema\n    }\n    // do migrations\n\n    var txn = e.currentTarget.transaction;\n    // these migrations have to be done in this function, before\n    // control is returned to the event loop, because IndexedDB\n\n    if (e.oldVersion < 3) {\n      createLocalStoreSchema(db); // v2 -> v3\n    }\n    if (e.oldVersion < 4) {\n      addAttachAndSeqStore(db); // v3 -> v4\n    }\n\n    var migrations = [\n      addDeletedOrLocalIndex, // v1 -> v2\n      migrateLocalStore,      // v2 -> v3\n      migrateAttsAndSeqs,     // v3 -> v4\n      migrateMetadata         // v4 -> v5\n    ];\n\n    var i = e.oldVersion;\n\n    function next() {\n      var migration = migrations[i - 1];\n      i++;\n      if (migration) {\n        migration(txn, next);\n      }\n    }\n\n    next();\n  };\n\n  req.onsuccess = function (e) {\n\n    idb = e.target.result;\n\n    idb.onversionchange = function () {\n      idb.close();\n      cachedDBs.delete(dbName);\n    };\n\n    idb.onabort = function (e) {\n      guardedConsole('error', 'Database has a global failure', e.target.error);\n      idb.close();\n      cachedDBs.delete(dbName);\n    };\n\n    // Do a few setup operations (in parallel as much as possible):\n    // 1. Fetch meta doc\n    // 2. Check blob support\n    // 3. Calculate docCount\n    // 4. Generate an instanceId if necessary\n    // 5. Store docCount and instanceId on meta doc\n\n    var txn = idb.transaction([\n      META_STORE,\n      DETECT_BLOB_SUPPORT_STORE,\n      DOC_STORE\n    ], 'readwrite');\n\n    var storedMetaDoc = false;\n    var metaDoc;\n    var docCount;\n    var blobSupport;\n    var instanceId;\n\n    function completeSetup() {\n      if (typeof blobSupport === 'undefined' || !storedMetaDoc) {\n        return;\n      }\n      api._meta = {\n        name: dbName,\n        instanceId: instanceId,\n        blobSupport: blobSupport\n      };\n\n      cachedDBs.set(dbName, {\n        idb: idb,\n        global: api._meta\n      });\n      callback(null, api);\n    }\n\n    function storeMetaDocIfReady() {\n      if (typeof docCount === 'undefined' || typeof metaDoc === 'undefined') {\n        return;\n      }\n      var instanceKey = dbName + '_id';\n      if (instanceKey in metaDoc) {\n        instanceId = metaDoc[instanceKey];\n      } else {\n        metaDoc[instanceKey] = instanceId = uuid();\n      }\n      metaDoc.docCount = docCount;\n      txn.objectStore(META_STORE).put(metaDoc);\n    }\n\n    //\n    // fetch or generate the instanceId\n    //\n    txn.objectStore(META_STORE).get(META_STORE).onsuccess = function (e) {\n      metaDoc = e.target.result || { id: META_STORE };\n      storeMetaDocIfReady();\n    };\n\n    //\n    // countDocs\n    //\n    countDocs(txn, function (count) {\n      docCount = count;\n      storeMetaDocIfReady();\n    });\n\n    //\n    // check blob support\n    //\n    if (!blobSupportPromise) {\n      // make sure blob support is only checked once\n      blobSupportPromise = checkBlobSupport(txn);\n    }\n\n    blobSupportPromise.then(function (val) {\n      blobSupport = val;\n      completeSetup();\n    });\n\n    // only when the metadata put transaction has completed,\n    // consider the setup done\n    txn.oncomplete = function () {\n      storedMetaDoc = true;\n      completeSetup();\n    };\n    txn.onabort = idbError(callback);\n  };\n\n  req.onerror = function (e) {\n    var msg = e.target.error && e.target.error.message;\n\n    if (!msg) {\n      msg = 'Failed to open indexedDB, are you in private browsing mode?';\n    } else if (msg.indexOf(\"stored database is a higher version\") !== -1) {\n      msg = new Error('This DB was created with the newer \"indexeddb\" adapter, but you are trying to open it with the older \"idb\" adapter');\n    }\n\n    guardedConsole('error', msg);\n    callback(createError(IDB_ERROR, msg));\n  };\n}\n\nIdbPouch.valid = function () {\n  // Following #7085 buggy idb versions (typically Safari < 10.1) are\n  // considered valid.\n\n  // On Firefox SecurityError is thrown while referencing indexedDB if cookies\n  // are not allowed. `typeof indexedDB` also triggers the error.\n  try {\n    // some outdated implementations of IDB that appear on Samsung\n    // and HTC Android devices <4.4 are missing IDBKeyRange\n    return typeof indexedDB !== 'undefined' && typeof IDBKeyRange !== 'undefined';\n  } catch (e) {\n    return false;\n  }\n};\n\nfunction index (PouchDB) {\n  PouchDB.adapter('idb', IdbPouch, true);\n}\n\nexport default index;\n"]},"metadata":{},"sourceType":"module"}
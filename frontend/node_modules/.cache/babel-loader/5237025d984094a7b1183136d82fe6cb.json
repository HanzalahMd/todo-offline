{"ast":null,"code":"/**\n * this plugin adds the RxCollection.sync()-function to rxdb\n * you can use it to sync collections with remote or local couchdb-instances\n */\nimport PouchReplicationPlugin from 'pouchdb-replication';\nimport { BehaviorSubject, Subject, fromEvent } from 'rxjs';\nimport { skipUntil } from 'rxjs/operators';\nimport { promiseWait, flatClone } from '../util';\nimport { addRxPlugin } from '../core';\nimport { newRxError } from '../rx-error';\nimport { pouchReplicationFunction, isInstanceOf as isInstanceOfPouchDB } from '../pouch-db';\nimport { isInstanceOf as isRxCollection } from '../rx-collection';\nimport { RxDBWatchForChangesPlugin } from './watch-for-changes'; // add pouchdb-replication-plugin\n\naddRxPlugin(PouchReplicationPlugin); // add the watch-for-changes-plugin\n\naddRxPlugin(RxDBWatchForChangesPlugin);\nvar INTERNAL_POUCHDBS = new WeakSet();\nexport var RxReplicationStateBase =\n/*#__PURE__*/\nfunction () {\n  function RxReplicationStateBase(collection) {\n    var _this = this;\n\n    this._subs = [];\n    this._subjects = {\n      change: new Subject(),\n      docs: new Subject(),\n      denied: new Subject(),\n      active: new BehaviorSubject(false),\n      complete: new BehaviorSubject(false),\n      alive: new BehaviorSubject(false),\n      error: new Subject()\n    };\n    this.collection = collection; // create getters\n\n    Object.keys(this._subjects).forEach(function (key) {\n      Object.defineProperty(_this, key + '$', {\n        get: function get() {\n          return this._subjects[key].asObservable();\n        }\n      });\n    });\n  }\n\n  var _proto = RxReplicationStateBase.prototype;\n\n  _proto.cancel = function cancel() {\n    if (this._pouchEventEmitterObject) this._pouchEventEmitterObject.cancel();\n\n    this._subs.forEach(function (sub) {\n      return sub.unsubscribe();\n    });\n  };\n\n  return RxReplicationStateBase;\n}();\nexport function setPouchEventEmitter(rxRepState, evEmitter) {\n  if (rxRepState._pouchEventEmitterObject) throw newRxError('RC1');\n  rxRepState._pouchEventEmitterObject = evEmitter; // change\n\n  rxRepState._subs.push(fromEvent(evEmitter, 'change').subscribe(function (ev) {\n    return rxRepState._subjects.change.next(ev);\n  })); // denied\n\n\n  rxRepState._subs.push(fromEvent(evEmitter, 'denied').subscribe(function (ev) {\n    return rxRepState._subjects.denied.next(ev);\n  })); // docs\n\n\n  rxRepState._subs.push(fromEvent(evEmitter, 'change').subscribe(function (ev) {\n    if (rxRepState._subjects.docs.observers.length === 0 || ev.direction !== 'pull') return;\n    ev.change.docs.filter(function (doc) {\n      return doc.language !== 'query';\n    }) // remove internal docs\n    .map(function (doc) {\n      return rxRepState.collection._handleFromPouch(doc);\n    }) // do primary-swap and keycompression\n    .forEach(function (doc) {\n      return rxRepState._subjects.docs.next(doc);\n    });\n  })); // error\n\n\n  rxRepState._subs.push(fromEvent(evEmitter, 'error').subscribe(function (ev) {\n    return rxRepState._subjects.error.next(ev);\n  })); // active\n\n\n  rxRepState._subs.push(fromEvent(evEmitter, 'active').subscribe(function () {\n    return rxRepState._subjects.active.next(true);\n  }));\n\n  rxRepState._subs.push(fromEvent(evEmitter, 'paused').subscribe(function () {\n    return rxRepState._subjects.active.next(false);\n  })); // complete\n\n\n  rxRepState._subs.push(fromEvent(evEmitter, 'complete').subscribe(function (info) {\n    /**\n     * when complete fires, it might be that not all changeEvents\n     * have passed throught, because of the delay of .wachtForChanges()\n     * Therefore we have to first ensure that all previous changeEvents have been handled\n     */\n    var unhandledEvents = Array.from(rxRepState.collection._watchForChangesUnhandled);\n    Promise.all(unhandledEvents).then(function () {\n      return rxRepState._subjects.complete.next(info);\n    });\n  }));\n\n  function getIsAlive(emitter) {\n    // \"state\" will live in emitter.state if single direction replication\n    // or in emitter.push.state & emitter.pull.state when syncing for both\n    var state = emitter.state;\n\n    if (!state) {\n      state = [emitter.pull.state, emitter.push.state].reduce(function (acc, val) {\n        if (acc === 'active' || val === 'active') return 'active';\n        return acc === 'stopped' ? acc : val;\n      }, '');\n    } // If it's active, we can't determine whether the connection is active\n    // or not yet\n\n\n    if (state === 'active') {\n      return promiseWait(15).then(function () {\n        return getIsAlive(emitter);\n      });\n    }\n\n    var isAlive = state !== 'stopped';\n    return Promise.resolve(isAlive);\n  }\n\n  rxRepState._subs.push(fromEvent(evEmitter, 'paused').pipe(skipUntil(fromEvent(evEmitter, 'active'))).subscribe(function () {\n    getIsAlive(rxRepState._pouchEventEmitterObject).then(function (isAlive) {\n      return rxRepState._subjects.alive.next(isAlive);\n    });\n  }));\n}\nexport function createRxReplicationState(collection) {\n  return new RxReplicationStateBase(collection);\n}\nexport function sync(_ref) {\n  var _this2 = this;\n\n  var remote = _ref.remote,\n      _ref$waitForLeadershi = _ref.waitForLeadership,\n      waitForLeadership = _ref$waitForLeadershi === void 0 ? true : _ref$waitForLeadershi,\n      _ref$direction = _ref.direction,\n      direction = _ref$direction === void 0 ? {\n    pull: true,\n    push: true\n  } : _ref$direction,\n      _ref$options = _ref.options,\n      options = _ref$options === void 0 ? {\n    live: true,\n    retry: true\n  } : _ref$options,\n      query = _ref.query;\n  var useOptions = flatClone(options); // prevent #641 by not allowing internal pouchdbs as remote\n\n  if (isInstanceOfPouchDB(remote) && INTERNAL_POUCHDBS.has(remote)) {\n    throw newRxError('RC3', {\n      database: this.database.name,\n      collection: this.name\n    });\n  } // if remote is RxCollection, get internal pouchdb\n\n\n  if (isRxCollection(remote)) {\n    remote.watchForChanges();\n    remote = remote.pouch;\n  }\n\n  if (query && this !== query.collection) {\n    throw newRxError('RC2', {\n      query: query\n    });\n  }\n\n  var syncFun = pouchReplicationFunction(this.pouch, direction);\n  if (query) useOptions.selector = query.keyCompress().selector;\n  var repState = createRxReplicationState(this); // run internal so .sync() does not have to be async\n\n  var waitTillRun = waitForLeadership ? this.database.waitForLeadership() : promiseWait(0);\n  waitTillRun.then(function () {\n    var pouchSync = syncFun(remote, useOptions);\n\n    _this2.watchForChanges();\n\n    setPouchEventEmitter(repState, pouchSync);\n\n    _this2._repStates.push(repState);\n  });\n  return repState;\n}\nexport var rxdb = true;\nexport var prototypes = {\n  RxCollection: function RxCollection(proto) {\n    proto.sync = sync;\n  }\n};\nexport var hooks = {\n  createRxCollection: function createRxCollection(collection) {\n    INTERNAL_POUCHDBS.add(collection.pouch);\n  }\n};\nexport var RxDBReplicationPlugin = {\n  name: 'replication',\n  rxdb: rxdb,\n  prototypes: prototypes,\n  hooks: hooks\n};","map":{"version":3,"sources":["/Users/Hanzalah/Desktop/github/todo-offline/rxdb-hasura-demo/node_modules/rxdb/dist/es/plugins/replication.js"],"names":["PouchReplicationPlugin","BehaviorSubject","Subject","fromEvent","skipUntil","promiseWait","flatClone","addRxPlugin","newRxError","pouchReplicationFunction","isInstanceOf","isInstanceOfPouchDB","isRxCollection","RxDBWatchForChangesPlugin","INTERNAL_POUCHDBS","WeakSet","RxReplicationStateBase","collection","_this","_subs","_subjects","change","docs","denied","active","complete","alive","error","Object","keys","forEach","key","defineProperty","get","asObservable","_proto","prototype","cancel","_pouchEventEmitterObject","sub","unsubscribe","setPouchEventEmitter","rxRepState","evEmitter","push","subscribe","ev","next","observers","length","direction","filter","doc","language","map","_handleFromPouch","info","unhandledEvents","Array","from","_watchForChangesUnhandled","Promise","all","then","getIsAlive","emitter","state","pull","reduce","acc","val","isAlive","resolve","pipe","createRxReplicationState","sync","_ref","_this2","remote","_ref$waitForLeadershi","waitForLeadership","_ref$direction","_ref$options","options","live","retry","query","useOptions","has","database","name","watchForChanges","pouch","syncFun","selector","keyCompress","repState","waitTillRun","pouchSync","_repStates","rxdb","prototypes","RxCollection","proto","hooks","createRxCollection","add","RxDBReplicationPlugin"],"mappings":"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","sourcesContent":["/**\n * this plugin adds the RxCollection.sync()-function to rxdb\n * you can use it to sync collections with remote or local couchdb-instances\n */\nimport PouchReplicationPlugin from 'pouchdb-replication';\nimport { BehaviorSubject, Subject, fromEvent } from 'rxjs';\nimport { skipUntil } from 'rxjs/operators';\nimport { promiseWait, flatClone } from '../util';\nimport { addRxPlugin } from '../core';\nimport { newRxError } from '../rx-error';\nimport { pouchReplicationFunction, isInstanceOf as isInstanceOfPouchDB } from '../pouch-db';\nimport { isInstanceOf as isRxCollection } from '../rx-collection';\nimport { RxDBWatchForChangesPlugin } from './watch-for-changes'; // add pouchdb-replication-plugin\n\naddRxPlugin(PouchReplicationPlugin); // add the watch-for-changes-plugin\n\naddRxPlugin(RxDBWatchForChangesPlugin);\nvar INTERNAL_POUCHDBS = new WeakSet();\nexport var RxReplicationStateBase = /*#__PURE__*/function () {\n  function RxReplicationStateBase(collection) {\n    var _this = this;\n\n    this._subs = [];\n    this._subjects = {\n      change: new Subject(),\n      docs: new Subject(),\n      denied: new Subject(),\n      active: new BehaviorSubject(false),\n      complete: new BehaviorSubject(false),\n      alive: new BehaviorSubject(false),\n      error: new Subject()\n    };\n    this.collection = collection;\n    // create getters\n    Object.keys(this._subjects).forEach(function (key) {\n      Object.defineProperty(_this, key + '$', {\n        get: function get() {\n          return this._subjects[key].asObservable();\n        }\n      });\n    });\n  }\n\n  var _proto = RxReplicationStateBase.prototype;\n\n  _proto.cancel = function cancel() {\n    if (this._pouchEventEmitterObject) this._pouchEventEmitterObject.cancel();\n\n    this._subs.forEach(function (sub) {\n      return sub.unsubscribe();\n    });\n  };\n\n  return RxReplicationStateBase;\n}();\nexport function setPouchEventEmitter(rxRepState, evEmitter) {\n  if (rxRepState._pouchEventEmitterObject) throw newRxError('RC1');\n  rxRepState._pouchEventEmitterObject = evEmitter; // change\n\n  rxRepState._subs.push(fromEvent(evEmitter, 'change').subscribe(function (ev) {\n    return rxRepState._subjects.change.next(ev);\n  })); // denied\n\n\n  rxRepState._subs.push(fromEvent(evEmitter, 'denied').subscribe(function (ev) {\n    return rxRepState._subjects.denied.next(ev);\n  })); // docs\n\n\n  rxRepState._subs.push(fromEvent(evEmitter, 'change').subscribe(function (ev) {\n    if (rxRepState._subjects.docs.observers.length === 0 || ev.direction !== 'pull') return;\n    ev.change.docs.filter(function (doc) {\n      return doc.language !== 'query';\n    }) // remove internal docs\n    .map(function (doc) {\n      return rxRepState.collection._handleFromPouch(doc);\n    }) // do primary-swap and keycompression\n    .forEach(function (doc) {\n      return rxRepState._subjects.docs.next(doc);\n    });\n  })); // error\n\n\n  rxRepState._subs.push(fromEvent(evEmitter, 'error').subscribe(function (ev) {\n    return rxRepState._subjects.error.next(ev);\n  })); // active\n\n\n  rxRepState._subs.push(fromEvent(evEmitter, 'active').subscribe(function () {\n    return rxRepState._subjects.active.next(true);\n  }));\n\n  rxRepState._subs.push(fromEvent(evEmitter, 'paused').subscribe(function () {\n    return rxRepState._subjects.active.next(false);\n  })); // complete\n\n\n  rxRepState._subs.push(fromEvent(evEmitter, 'complete').subscribe(function (info) {\n    /**\n     * when complete fires, it might be that not all changeEvents\n     * have passed throught, because of the delay of .wachtForChanges()\n     * Therefore we have to first ensure that all previous changeEvents have been handled\n     */\n    var unhandledEvents = Array.from(rxRepState.collection._watchForChangesUnhandled);\n    Promise.all(unhandledEvents).then(function () {\n      return rxRepState._subjects.complete.next(info);\n    });\n  }));\n\n  function getIsAlive(emitter) {\n    // \"state\" will live in emitter.state if single direction replication\n    // or in emitter.push.state & emitter.pull.state when syncing for both\n    var state = emitter.state;\n\n    if (!state) {\n      state = [emitter.pull.state, emitter.push.state].reduce(function (acc, val) {\n        if (acc === 'active' || val === 'active') return 'active';\n        return acc === 'stopped' ? acc : val;\n      }, '');\n    } // If it's active, we can't determine whether the connection is active\n    // or not yet\n\n\n    if (state === 'active') {\n      return promiseWait(15).then(function () {\n        return getIsAlive(emitter);\n      });\n    }\n\n    var isAlive = state !== 'stopped';\n    return Promise.resolve(isAlive);\n  }\n\n  rxRepState._subs.push(fromEvent(evEmitter, 'paused').pipe(skipUntil(fromEvent(evEmitter, 'active'))).subscribe(function () {\n    getIsAlive(rxRepState._pouchEventEmitterObject).then(function (isAlive) {\n      return rxRepState._subjects.alive.next(isAlive);\n    });\n  }));\n}\nexport function createRxReplicationState(collection) {\n  return new RxReplicationStateBase(collection);\n}\nexport function sync(_ref) {\n  var _this2 = this;\n\n  var remote = _ref.remote,\n      _ref$waitForLeadershi = _ref.waitForLeadership,\n      waitForLeadership = _ref$waitForLeadershi === void 0 ? true : _ref$waitForLeadershi,\n      _ref$direction = _ref.direction,\n      direction = _ref$direction === void 0 ? {\n    pull: true,\n    push: true\n  } : _ref$direction,\n      _ref$options = _ref.options,\n      options = _ref$options === void 0 ? {\n    live: true,\n    retry: true\n  } : _ref$options,\n      query = _ref.query;\n  var useOptions = flatClone(options); // prevent #641 by not allowing internal pouchdbs as remote\n\n  if (isInstanceOfPouchDB(remote) && INTERNAL_POUCHDBS.has(remote)) {\n    throw newRxError('RC3', {\n      database: this.database.name,\n      collection: this.name\n    });\n  } // if remote is RxCollection, get internal pouchdb\n\n\n  if (isRxCollection(remote)) {\n    remote.watchForChanges();\n    remote = remote.pouch;\n  }\n\n  if (query && this !== query.collection) {\n    throw newRxError('RC2', {\n      query: query\n    });\n  }\n\n  var syncFun = pouchReplicationFunction(this.pouch, direction);\n  if (query) useOptions.selector = query.keyCompress().selector;\n  var repState = createRxReplicationState(this); // run internal so .sync() does not have to be async\n\n  var waitTillRun = waitForLeadership ? this.database.waitForLeadership() : promiseWait(0);\n  waitTillRun.then(function () {\n    var pouchSync = syncFun(remote, useOptions);\n\n    _this2.watchForChanges();\n\n    setPouchEventEmitter(repState, pouchSync);\n\n    _this2._repStates.push(repState);\n  });\n  return repState;\n}\nexport var rxdb = true;\nexport var prototypes = {\n  RxCollection: function RxCollection(proto) {\n    proto.sync = sync;\n  }\n};\nexport var hooks = {\n  createRxCollection: function createRxCollection(collection) {\n    INTERNAL_POUCHDBS.add(collection.pouch);\n  }\n};\nexport var RxDBReplicationPlugin = {\n  name: 'replication',\n  rxdb: rxdb,\n  prototypes: prototypes,\n  hooks: hooks\n};\n//# sourceMappingURL=replication.js.map"]},"metadata":{},"sourceType":"module"}
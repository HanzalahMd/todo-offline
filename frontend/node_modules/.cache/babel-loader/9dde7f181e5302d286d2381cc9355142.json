{"ast":null,"code":"/**\n * does additional checks over the schema-json\n * to ensure nothing is broken or not supported\n */\nimport objectPath from 'object-path';\nimport RxDocument from '../rx-document';\nimport { newRxError, newRxTypeError } from '../rx-error';\nimport { getIndexes } from '../rx-schema';\nimport { properties as rxDocumentProperties } from '../rx-document';\nimport { properties as rxCollectionProperties } from '../rx-collection';\nimport { getPreviousVersions } from '../rx-schema';\n/**\n * checks if the fieldname is allowed\n * this makes sure that the fieldnames can be transformed into javascript-vars\n * and does not conquer the observe$ and populate_ fields\n * @throws {Error}\n */\n\nexport function checkFieldNameRegex(fieldName) {\n  if (fieldName === '') return;\n  if (fieldName === '_id') return;\n\n  if (['properties', 'language'].includes(fieldName)) {\n    throw newRxError('SC23', {\n      fieldName: fieldName\n    });\n  }\n\n  var regexStr = '^[a-zA-Z](?:[[a-zA-Z0-9_]*]?[a-zA-Z0-9])?$';\n  var regex = new RegExp(regexStr);\n\n  if (!fieldName.match(regex)) {\n    throw newRxError('SC1', {\n      regex: regexStr,\n      fieldName: fieldName\n    });\n  }\n}\n/**\n * validate that all schema-related things are ok\n */\n\nexport function validateFieldsDeep(jsonSchema) {\n  function checkField(fieldName, schemaObj, path) {\n    if (typeof fieldName === 'string' && typeof schemaObj === 'object' && !Array.isArray(schemaObj)) checkFieldNameRegex(fieldName); // 'item' only allowed it type=='array'\n\n    if (schemaObj.hasOwnProperty('item') && schemaObj.type !== 'array') {\n      throw newRxError('SC2', {\n        fieldName: fieldName\n      });\n    }\n    /**\n     * required fields cannot be set via 'required: true',\n     * but must be set via required: []\n     */\n\n\n    if (schemaObj.hasOwnProperty('required') && typeof schemaObj.required === 'boolean') {\n      throw newRxError('SC24', {\n        fieldName: fieldName\n      });\n    } // if ref given, must be type=='string' or type=='array' with string-items\n\n\n    if (schemaObj.hasOwnProperty('ref')) {\n      switch (schemaObj.type) {\n        case 'string':\n          break;\n\n        case 'array':\n          if (!schemaObj.items || !schemaObj.items.type || schemaObj.items.type !== 'string') {\n            throw newRxError('SC3', {\n              fieldName: fieldName\n            });\n          }\n\n          break;\n\n        default:\n          throw newRxError('SC4', {\n            fieldName: fieldName\n          });\n      }\n    } // if primary is ref, throw\n\n\n    if (schemaObj.hasOwnProperty('ref') && schemaObj.primary) {\n      throw newRxError('SC5', {\n        fieldName: fieldName\n      });\n    }\n\n    var isNested = path.split('.').length >= 2; // nested only\n\n    if (isNested) {\n      if (schemaObj.primary) {\n        throw newRxError('SC6', {\n          path: path,\n          primary: schemaObj.primary\n        });\n      }\n\n      if (schemaObj[\"default\"]) {\n        throw newRxError('SC7', {\n          path: path\n        });\n      }\n    } // first level\n\n\n    if (!isNested) {\n      // check underscore fields\n      if (fieldName.charAt(0) === '_') {\n        if (fieldName === '_id' && schemaObj.primary) {\n          return;\n        }\n\n        throw newRxError('SC8', {\n          fieldName: fieldName\n        });\n      }\n    }\n  }\n\n  function traverse(currentObj, currentPath) {\n    if (typeof currentObj !== 'object') return;\n    Object.keys(currentObj).forEach(function (attributeName) {\n      if (!currentObj.properties) {\n        checkField(attributeName, currentObj[attributeName], currentPath);\n      }\n\n      var nextPath = currentPath;\n      if (attributeName !== 'properties') nextPath = nextPath + '.' + attributeName;\n      traverse(currentObj[attributeName], nextPath);\n    });\n  }\n\n  traverse(jsonSchema, '');\n  return true;\n}\n/**\n * does the checking\n * @throws {Error} if something is not ok\n */\n\nexport function checkSchema(jsonID) {\n  // check _rev\n  if (jsonID.properties._rev) {\n    throw newRxError('SC10', {\n      schema: jsonID\n    });\n  } // check version\n\n\n  if (!jsonID.hasOwnProperty('version') || typeof jsonID.version !== 'number' || jsonID.version < 0) {\n    throw newRxError('SC11', {\n      version: jsonID.version\n    });\n  }\n\n  validateFieldsDeep(jsonID);\n  var primaryPath;\n  Object.keys(jsonID.properties).forEach(function (key) {\n    var value = jsonID.properties[key]; // check primary\n\n    if (value.primary) {\n      if (primaryPath) {\n        throw newRxError('SC12', {\n          value: value\n        });\n      }\n\n      primaryPath = key;\n\n      if (value.index) {\n        throw newRxError('SC13', {\n          value: value\n        });\n      }\n\n      if (value.unique) {\n        throw newRxError('SC14', {\n          value: value\n        });\n      }\n\n      if (value.encrypted) {\n        throw newRxError('SC15', {\n          value: value\n        });\n      }\n\n      if (value.type !== 'string') {\n        throw newRxError('SC16', {\n          value: value\n        });\n      }\n    } // check if RxDocument-property\n\n\n    if (RxDocument.properties().includes(key)) {\n      throw newRxError('SC17', {\n        key: key\n      });\n    }\n  }); // check format of jsonID.compoundIndexes\n\n  if (jsonID.compoundIndexes) {\n    if (!Array.isArray(jsonID.compoundIndexes)) {\n      throw newRxError('SC18', {\n        compoundIndexes: jsonID.compoundIndexes\n      });\n    }\n\n    jsonID.compoundIndexes.forEach(function (ar) {\n      if (!Array.isArray(ar)) {\n        throw newRxError('SC19', {\n          compoundIndexes: jsonID.compoundIndexes\n        });\n      }\n\n      ar.forEach(function (str) {\n        if (typeof str !== 'string') {\n          throw newRxError('SC20', {\n            compoundIndexes: jsonID.compoundIndexes\n          });\n        }\n      });\n    });\n  } // check that indexes are string or number\n\n\n  getIndexes(jsonID).reduce(function (a, b) {\n    return a.concat(b);\n  }, []).filter(function (elem, pos, arr) {\n    return arr.indexOf(elem) === pos;\n  }) // unique\n  .map(function (key) {\n    var path = 'properties.' + key.replace(/\\./g, '.properties.');\n    var schemaObj = objectPath.get(jsonID, path);\n\n    if (!schemaObj || typeof schemaObj !== 'object') {\n      throw newRxError('SC21', {\n        key: key\n      });\n    }\n\n    return {\n      key: key,\n      schemaObj: schemaObj\n    };\n  }).filter(function (index) {\n    return index.schemaObj.type !== 'string' && index.schemaObj.type !== 'integer' && index.schemaObj.type !== 'number';\n  }).forEach(function (index) {\n    throw newRxError('SC22', {\n      key: index.key,\n      type: index.schemaObj.type\n    });\n  });\n}\n/**\n * checks if the given static methods are allowed\n * @throws if not allowed\n */\n\nvar checkOrmMethods = function checkOrmMethods(statics) {\n  if (!statics) {\n    return;\n  }\n\n  Object.entries(statics).forEach(function (_ref) {\n    var k = _ref[0],\n        v = _ref[1];\n\n    if (typeof k !== 'string') {\n      throw newRxTypeError('COL14', {\n        name: k\n      });\n    }\n\n    if (k.startsWith('_')) {\n      throw newRxTypeError('COL15', {\n        name: k\n      });\n    }\n\n    if (typeof v !== 'function') {\n      throw newRxTypeError('COL16', {\n        name: k,\n        type: typeof k\n      });\n    }\n\n    if (rxCollectionProperties().includes(k) || rxDocumentProperties().includes(k)) {\n      throw newRxError('COL17', {\n        name: k\n      });\n    }\n  });\n};\n/**\n * checks if the migrationStrategies are ok, throws if not\n * @throws {Error|TypeError} if not ok\n */\n\n\nfunction checkMigrationStrategies(schema, migrationStrategies) {\n  // migrationStrategies must be object not array\n  if (typeof migrationStrategies !== 'object' || Array.isArray(migrationStrategies)) {\n    throw newRxTypeError('COL11', {\n      schema: schema\n    });\n  }\n\n  var previousVersions = getPreviousVersions(schema); // for every previousVersion there must be strategy\n\n  if (previousVersions.length !== Object.keys(migrationStrategies).length) {\n    throw newRxError('COL12', {\n      have: Object.keys(migrationStrategies),\n      should: previousVersions\n    });\n  } // every strategy must have number as property and be a function\n\n\n  previousVersions.map(function (vNr) {\n    return {\n      v: vNr,\n      s: migrationStrategies[vNr + 1]\n    };\n  }).filter(function (strat) {\n    return typeof strat.s !== 'function';\n  }).forEach(function (strat) {\n    throw newRxTypeError('COL13', {\n      version: strat.v,\n      type: typeof strat,\n      schema: schema\n    });\n  });\n  return true;\n}\n\nexport var rxdb = true;\nexport var hooks = {\n  preCreateRxSchema: checkSchema,\n  createRxCollection: function createRxCollection(args) {\n    // check ORM-methods\n    checkOrmMethods(args.statics);\n    checkOrmMethods(args.methods);\n    checkOrmMethods(args.attachments); // check migration strategies\n\n    if (args.schema && args.migrationStrategies) {\n      checkMigrationStrategies(args.schema, args.migrationStrategies);\n    }\n  }\n};\nexport default {\n  rxdb: rxdb,\n  hooks: hooks\n};","map":{"version":3,"sources":["/Users/Hanzalah/Desktop/github/todo-offline/rxdb-hasura-demo/node_modules/rxdb/dist/es/plugins/schema-check.js"],"names":["objectPath","RxDocument","newRxError","newRxTypeError","getIndexes","properties","rxDocumentProperties","rxCollectionProperties","getPreviousVersions","checkFieldNameRegex","fieldName","includes","regexStr","regex","RegExp","match","validateFieldsDeep","jsonSchema","checkField","schemaObj","path","Array","isArray","hasOwnProperty","type","required","items","primary","isNested","split","length","charAt","traverse","currentObj","currentPath","Object","keys","forEach","attributeName","nextPath","checkSchema","jsonID","_rev","schema","version","primaryPath","key","value","index","unique","encrypted","compoundIndexes","ar","str","reduce","a","b","concat","filter","elem","pos","arr","indexOf","map","replace","get","checkOrmMethods","statics","entries","_ref","k","v","name","startsWith","checkMigrationStrategies","migrationStrategies","previousVersions","have","should","vNr","s","strat","rxdb","hooks","preCreateRxSchema","createRxCollection","args","methods","attachments"],"mappings":"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","sourcesContent":["/**\n * does additional checks over the schema-json\n * to ensure nothing is broken or not supported\n */\nimport objectPath from 'object-path';\nimport RxDocument from '../rx-document';\nimport { newRxError, newRxTypeError } from '../rx-error';\nimport { getIndexes } from '../rx-schema';\nimport { properties as rxDocumentProperties } from '../rx-document';\nimport { properties as rxCollectionProperties } from '../rx-collection';\nimport { getPreviousVersions } from '../rx-schema';\n/**\n * checks if the fieldname is allowed\n * this makes sure that the fieldnames can be transformed into javascript-vars\n * and does not conquer the observe$ and populate_ fields\n * @throws {Error}\n */\n\nexport function checkFieldNameRegex(fieldName) {\n  if (fieldName === '') return;\n  if (fieldName === '_id') return;\n\n  if (['properties', 'language'].includes(fieldName)) {\n    throw newRxError('SC23', {\n      fieldName: fieldName\n    });\n  }\n\n  var regexStr = '^[a-zA-Z](?:[[a-zA-Z0-9_]*]?[a-zA-Z0-9])?$';\n  var regex = new RegExp(regexStr);\n\n  if (!fieldName.match(regex)) {\n    throw newRxError('SC1', {\n      regex: regexStr,\n      fieldName: fieldName\n    });\n  }\n}\n/**\n * validate that all schema-related things are ok\n */\n\nexport function validateFieldsDeep(jsonSchema) {\n  function checkField(fieldName, schemaObj, path) {\n    if (typeof fieldName === 'string' && typeof schemaObj === 'object' && !Array.isArray(schemaObj)) checkFieldNameRegex(fieldName); // 'item' only allowed it type=='array'\n\n    if (schemaObj.hasOwnProperty('item') && schemaObj.type !== 'array') {\n      throw newRxError('SC2', {\n        fieldName: fieldName\n      });\n    }\n    /**\n     * required fields cannot be set via 'required: true',\n     * but must be set via required: []\n     */\n\n\n    if (schemaObj.hasOwnProperty('required') && typeof schemaObj.required === 'boolean') {\n      throw newRxError('SC24', {\n        fieldName: fieldName\n      });\n    } // if ref given, must be type=='string' or type=='array' with string-items\n\n\n    if (schemaObj.hasOwnProperty('ref')) {\n      switch (schemaObj.type) {\n        case 'string':\n          break;\n\n        case 'array':\n          if (!schemaObj.items || !schemaObj.items.type || schemaObj.items.type !== 'string') {\n            throw newRxError('SC3', {\n              fieldName: fieldName\n            });\n          }\n\n          break;\n\n        default:\n          throw newRxError('SC4', {\n            fieldName: fieldName\n          });\n      }\n    } // if primary is ref, throw\n\n\n    if (schemaObj.hasOwnProperty('ref') && schemaObj.primary) {\n      throw newRxError('SC5', {\n        fieldName: fieldName\n      });\n    }\n\n    var isNested = path.split('.').length >= 2; // nested only\n\n    if (isNested) {\n      if (schemaObj.primary) {\n        throw newRxError('SC6', {\n          path: path,\n          primary: schemaObj.primary\n        });\n      }\n\n      if (schemaObj[\"default\"]) {\n        throw newRxError('SC7', {\n          path: path\n        });\n      }\n    } // first level\n\n\n    if (!isNested) {\n      // check underscore fields\n      if (fieldName.charAt(0) === '_') {\n        if (fieldName === '_id' && schemaObj.primary) {\n          return;\n        }\n\n        throw newRxError('SC8', {\n          fieldName: fieldName\n        });\n      }\n    }\n  }\n\n  function traverse(currentObj, currentPath) {\n    if (typeof currentObj !== 'object') return;\n    Object.keys(currentObj).forEach(function (attributeName) {\n      if (!currentObj.properties) {\n        checkField(attributeName, currentObj[attributeName], currentPath);\n      }\n\n      var nextPath = currentPath;\n      if (attributeName !== 'properties') nextPath = nextPath + '.' + attributeName;\n      traverse(currentObj[attributeName], nextPath);\n    });\n  }\n\n  traverse(jsonSchema, '');\n  return true;\n}\n/**\n * does the checking\n * @throws {Error} if something is not ok\n */\n\nexport function checkSchema(jsonID) {\n  // check _rev\n  if (jsonID.properties._rev) {\n    throw newRxError('SC10', {\n      schema: jsonID\n    });\n  } // check version\n\n\n  if (!jsonID.hasOwnProperty('version') || typeof jsonID.version !== 'number' || jsonID.version < 0) {\n    throw newRxError('SC11', {\n      version: jsonID.version\n    });\n  }\n\n  validateFieldsDeep(jsonID);\n  var primaryPath;\n  Object.keys(jsonID.properties).forEach(function (key) {\n    var value = jsonID.properties[key]; // check primary\n\n    if (value.primary) {\n      if (primaryPath) {\n        throw newRxError('SC12', {\n          value: value\n        });\n      }\n\n      primaryPath = key;\n\n      if (value.index) {\n        throw newRxError('SC13', {\n          value: value\n        });\n      }\n\n      if (value.unique) {\n        throw newRxError('SC14', {\n          value: value\n        });\n      }\n\n      if (value.encrypted) {\n        throw newRxError('SC15', {\n          value: value\n        });\n      }\n\n      if (value.type !== 'string') {\n        throw newRxError('SC16', {\n          value: value\n        });\n      }\n    } // check if RxDocument-property\n\n\n    if (RxDocument.properties().includes(key)) {\n      throw newRxError('SC17', {\n        key: key\n      });\n    }\n  }); // check format of jsonID.compoundIndexes\n\n  if (jsonID.compoundIndexes) {\n    if (!Array.isArray(jsonID.compoundIndexes)) {\n      throw newRxError('SC18', {\n        compoundIndexes: jsonID.compoundIndexes\n      });\n    }\n\n    jsonID.compoundIndexes.forEach(function (ar) {\n      if (!Array.isArray(ar)) {\n        throw newRxError('SC19', {\n          compoundIndexes: jsonID.compoundIndexes\n        });\n      }\n\n      ar.forEach(function (str) {\n        if (typeof str !== 'string') {\n          throw newRxError('SC20', {\n            compoundIndexes: jsonID.compoundIndexes\n          });\n        }\n      });\n    });\n  } // check that indexes are string or number\n\n\n  getIndexes(jsonID).reduce(function (a, b) {\n    return a.concat(b);\n  }, []).filter(function (elem, pos, arr) {\n    return arr.indexOf(elem) === pos;\n  }) // unique\n  .map(function (key) {\n    var path = 'properties.' + key.replace(/\\./g, '.properties.');\n    var schemaObj = objectPath.get(jsonID, path);\n\n    if (!schemaObj || typeof schemaObj !== 'object') {\n      throw newRxError('SC21', {\n        key: key\n      });\n    }\n\n    return {\n      key: key,\n      schemaObj: schemaObj\n    };\n  }).filter(function (index) {\n    return index.schemaObj.type !== 'string' && index.schemaObj.type !== 'integer' && index.schemaObj.type !== 'number';\n  }).forEach(function (index) {\n    throw newRxError('SC22', {\n      key: index.key,\n      type: index.schemaObj.type\n    });\n  });\n}\n/**\n * checks if the given static methods are allowed\n * @throws if not allowed\n */\n\nvar checkOrmMethods = function checkOrmMethods(statics) {\n  if (!statics) {\n    return;\n  }\n\n  Object.entries(statics).forEach(function (_ref) {\n    var k = _ref[0],\n        v = _ref[1];\n\n    if (typeof k !== 'string') {\n      throw newRxTypeError('COL14', {\n        name: k\n      });\n    }\n\n    if (k.startsWith('_')) {\n      throw newRxTypeError('COL15', {\n        name: k\n      });\n    }\n\n    if (typeof v !== 'function') {\n      throw newRxTypeError('COL16', {\n        name: k,\n        type: typeof k\n      });\n    }\n\n    if (rxCollectionProperties().includes(k) || rxDocumentProperties().includes(k)) {\n      throw newRxError('COL17', {\n        name: k\n      });\n    }\n  });\n};\n/**\n * checks if the migrationStrategies are ok, throws if not\n * @throws {Error|TypeError} if not ok\n */\n\n\nfunction checkMigrationStrategies(schema, migrationStrategies) {\n  // migrationStrategies must be object not array\n  if (typeof migrationStrategies !== 'object' || Array.isArray(migrationStrategies)) {\n    throw newRxTypeError('COL11', {\n      schema: schema\n    });\n  }\n\n  var previousVersions = getPreviousVersions(schema); // for every previousVersion there must be strategy\n\n  if (previousVersions.length !== Object.keys(migrationStrategies).length) {\n    throw newRxError('COL12', {\n      have: Object.keys(migrationStrategies),\n      should: previousVersions\n    });\n  } // every strategy must have number as property and be a function\n\n\n  previousVersions.map(function (vNr) {\n    return {\n      v: vNr,\n      s: migrationStrategies[vNr + 1]\n    };\n  }).filter(function (strat) {\n    return typeof strat.s !== 'function';\n  }).forEach(function (strat) {\n    throw newRxTypeError('COL13', {\n      version: strat.v,\n      type: typeof strat,\n      schema: schema\n    });\n  });\n  return true;\n}\n\nexport var rxdb = true;\nexport var hooks = {\n  preCreateRxSchema: checkSchema,\n  createRxCollection: function createRxCollection(args) {\n    // check ORM-methods\n    checkOrmMethods(args.statics);\n    checkOrmMethods(args.methods);\n    checkOrmMethods(args.attachments); // check migration strategies\n\n    if (args.schema && args.migrationStrategies) {\n      checkMigrationStrategies(args.schema, args.migrationStrategies);\n    }\n  }\n};\nexport default {\n  rxdb: rxdb,\n  hooks: hooks\n};\n//# sourceMappingURL=schema-check.js.map"]},"metadata":{},"sourceType":"module"}
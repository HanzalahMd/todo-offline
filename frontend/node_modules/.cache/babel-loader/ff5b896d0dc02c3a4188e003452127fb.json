{"ast":null,"code":"/**\n * The DataMigrator handles the documents from collections with older schemas\n * and transforms/saves them into the newest collection\n */\n\n/**\n * TODO this should be completely rewritten because:\n * - The current implemetation does not use pouchdb'S bulkDocs which is much faster\n * - This could have been done in much less code which would be easier to uderstand\n *\n */\nimport { Subject } from 'rxjs';\nimport { countAllUndeleted, getBatch } from '../../pouch-db';\nimport { clone, toPromise, flatClone } from '../../util';\nimport { createRxSchema } from '../../rx-schema';\nimport { newRxError } from '../../rx-error';\nimport { overwritable } from '../../overwritable';\nimport { runPluginHooks, runAsyncPluginHooks } from '../../hooks';\nimport { getPreviousVersions } from '../../rx-schema';\nimport { createCrypter } from '../../crypter';\nimport { _handleToPouch, _handleFromPouch } from '../../rx-collection-helper';\nexport var DataMigrator =\n/*#__PURE__*/\nfunction () {\n  function DataMigrator(newestCollection, migrationStrategies) {\n    this._migrated = false;\n    this.newestCollection = newestCollection;\n    this.migrationStrategies = migrationStrategies;\n    this.currentSchema = newestCollection.schema;\n    this.database = newestCollection.database;\n    this.name = newestCollection.name;\n  }\n\n  var _proto = DataMigrator.prototype;\n\n  _proto.migrate = function migrate() {\n    var _this = this;\n\n    var batchSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n    if (this._migrated) throw newRxError('DM1');\n    this._migrated = true;\n    var state = {\n      done: false,\n      // true if finished\n      total: 0,\n      // will be the doc-count\n      handled: 0,\n      // amount of handled docs\n      success: 0,\n      // handled docs which successed\n      deleted: 0,\n      // handled docs which got deleted\n      percent: 0 // percentage\n\n    };\n    var observer = new Subject();\n    /**\n     * TODO this is a side-effect which might throw\n     * We did this because it is not possible to create new Observer(async(...))\n     * @link https://github.com/ReactiveX/rxjs/issues/4074\n     */\n\n    (function () {\n      var oldCols;\n      return _getOldCollections(_this).then(function (ret) {\n        oldCols = ret;\n        var countAll = Promise.all(oldCols.map(function (oldCol) {\n          return countAllUndeleted(oldCol.pouchdb);\n        }));\n        return countAll;\n      }).then(function (countAll) {\n        var totalCount = countAll.reduce(function (cur, prev) {\n          return prev = cur + prev;\n        }, 0);\n        state.total = totalCount;\n        observer.next(flatClone(state));\n        var currentCol = oldCols.shift();\n        var currentPromise = Promise.resolve();\n\n        var _loop = function _loop() {\n          var migrationState$ = migrateOldCollection(currentCol, batchSize);\n          currentPromise = currentPromise.then(function () {\n            return new Promise(function (res) {\n              var sub = migrationState$.subscribe(function (subState) {\n                state.handled++;\n                state[subState.type] = state[subState.type] + 1;\n                state.percent = Math.round(state.handled / state.total * 100);\n                observer.next(flatClone(state));\n              }, function (e) {\n                sub.unsubscribe();\n                observer.error(e);\n              }, function () {\n                sub.unsubscribe();\n                res();\n              });\n            });\n          });\n          currentCol = oldCols.shift();\n        };\n\n        while (currentCol) {\n          _loop();\n        }\n\n        return currentPromise;\n      }).then(function () {\n        state.done = true;\n        state.percent = 100;\n        observer.next(flatClone(state));\n        observer.complete();\n      });\n    })();\n\n    return observer.asObservable();\n  };\n\n  _proto.migratePromise = function migratePromise(batchSize) {\n    var _this2 = this;\n\n    if (!this._migratePromise) {\n      this._migratePromise = mustMigrate(this).then(function (must) {\n        if (!must) return Promise.resolve(false);else return new Promise(function (res, rej) {\n          var state$ = _this2.migrate(batchSize);\n\n          state$.subscribe(null, rej, res);\n        });\n      });\n    }\n\n    return this._migratePromise;\n  };\n\n  return DataMigrator;\n}();\nexport function createOldCollection(version, schemaObj, dataMigrator) {\n  var database = dataMigrator.newestCollection.database;\n  var schema = createRxSchema(schemaObj, false);\n  var ret = {\n    version: version,\n    dataMigrator: dataMigrator,\n    newestCollection: dataMigrator.newestCollection,\n    database: database,\n    schema: createRxSchema(schemaObj, false),\n    pouchdb: database._spawnPouchDB(dataMigrator.newestCollection.name, version, dataMigrator.newestCollection.pouchSettings),\n    _crypter: createCrypter(database.password, schema)\n  };\n\n  if (schema.doKeyCompression()) {\n    ret._keyCompressor = overwritable.createKeyCompressor(schema);\n  }\n\n  return ret;\n}\n/**\n * get an array with OldCollection-instances from all existing old pouchdb-instance\n */\n\nexport function _getOldCollections(dataMigrator) {\n  return Promise.all(getPreviousVersions(dataMigrator.currentSchema.jsonSchema).map(function (v) {\n    return dataMigrator.database.internalStore.get(dataMigrator.name + '-' + v);\n  }).map(function (fun) {\n    return fun[\"catch\"](function () {\n      return null;\n    });\n  }) // auto-catch so Promise.all continues\n  ).then(function (oldColDocs) {\n    return oldColDocs.filter(function (colDoc) {\n      return colDoc !== null;\n    }).map(function (colDoc) {\n      return createOldCollection(colDoc.schema.version, colDoc.schema, dataMigrator);\n    });\n  });\n}\n/**\n * returns true if a migration is needed\n */\n\nexport function mustMigrate(dataMigrator) {\n  if (dataMigrator.currentSchema.version === 0) {\n    return Promise.resolve(false);\n  }\n\n  return _getOldCollections(dataMigrator).then(function (oldCols) {\n    if (oldCols.length === 0) return false;else return true;\n  });\n}\nexport function createDataMigrator(newestCollection, migrationStrategies) {\n  return new DataMigrator(newestCollection, migrationStrategies);\n}\nexport function _runStrategyIfNotNull(oldCollection, version, docOrNull) {\n  if (docOrNull === null) {\n    return Promise.resolve(null);\n  } else {\n    var ret = oldCollection.dataMigrator.migrationStrategies[version](docOrNull);\n    var retPromise = toPromise(ret);\n    return retPromise;\n  }\n}\nexport function getBatchOfOldCollection(oldCollection, batchSize) {\n  return getBatch(oldCollection.pouchdb, batchSize).then(function (docs) {\n    return docs.map(function (doc) {\n      return _handleFromPouch(oldCollection, doc);\n    });\n  });\n}\n/**\n * runs the doc-data through all following migrationStrategies\n * so it will match the newest schema.\n * @throws Error if final doc does not match final schema or migrationStrategy crashes\n * @return final object or null if migrationStrategy deleted it\n */\n\nexport function migrateDocumentData(oldCollection, docData) {\n  docData = clone(docData);\n  var nextVersion = oldCollection.version + 1; // run the document throught migrationStrategies\n\n  var currentPromise = Promise.resolve(docData);\n\n  var _loop2 = function _loop2() {\n    var version = nextVersion;\n    currentPromise = currentPromise.then(function (docOrNull) {\n      return _runStrategyIfNotNull(oldCollection, version, docOrNull);\n    });\n    nextVersion++;\n  };\n\n  while (nextVersion <= oldCollection.newestCollection.schema.version) {\n    _loop2();\n  }\n\n  return currentPromise.then(function (doc) {\n    if (doc === null) return Promise.resolve(null); // check final schema\n\n    try {\n      oldCollection.newestCollection.schema.validate(doc);\n    } catch (e) {\n      throw newRxError('DM2', {\n        fromVersion: oldCollection.version,\n        toVersion: oldCollection.newestCollection.schema.version,\n        finalDoc: doc\n      });\n    }\n\n    return doc;\n  });\n}\n/**\n * transform docdata and save to new collection\n * @return status-action with status and migrated document\n */\n\nexport function _migrateDocument(oldCollection, doc) {\n  var action = {\n    res: null,\n    type: '',\n    migrated: null,\n    doc: doc,\n    oldCollection: oldCollection,\n    newestCollection: oldCollection.newestCollection\n  };\n  return migrateDocumentData(oldCollection, doc).then(function (migrated) {\n    action.migrated = migrated;\n\n    if (migrated) {\n      runPluginHooks('preMigrateDocument', action); // save to newest collection\n\n      delete migrated._rev;\n      return oldCollection.newestCollection._pouchPut(migrated, true).then(function (res) {\n        action.res = res;\n        action.type = 'success';\n        return runAsyncPluginHooks('postMigrateDocument', action);\n      });\n    } else action.type = 'deleted';\n  }).then(function () {\n    // remove from old collection\n    return oldCollection.pouchdb.remove(_handleToPouch(oldCollection, doc))[\"catch\"](function () {});\n  }).then(function () {\n    return action;\n  });\n}\n/**\n * deletes this.pouchdb and removes it from the database.collectionsCollection\n */\n\nexport function deleteOldCollection(oldCollection) {\n  return oldCollection.pouchdb.destroy().then(function () {\n    return oldCollection.database.removeCollectionDoc(oldCollection.dataMigrator.name, oldCollection.schema);\n  });\n}\n/**\n * runs the migration on all documents and deletes the pouchdb afterwards\n */\n\nexport function migrateOldCollection(oldCollection) {\n  var batchSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n\n  if (oldCollection._migrate) {\n    // already running\n    throw newRxError('DM3');\n  }\n\n  oldCollection._migrate = true;\n  var observer = new Subject();\n  /**\n   * TODO this is a side-effect which might throw\n   * @see DataMigrator.migrate()\n   */\n\n  (function () {\n    var error;\n\n    var allBatchesDone = function allBatchesDone() {\n      // remove this oldCollection\n      return deleteOldCollection(oldCollection).then(function () {\n        return observer.complete();\n      });\n    };\n\n    var handleOneBatch = function handleOneBatch() {\n      return getBatchOfOldCollection(oldCollection, batchSize).then(function (batch) {\n        if (batch.length === 0) {\n          allBatchesDone();\n          return false;\n        } else {\n          return Promise.all(batch.map(function (doc) {\n            return _migrateDocument(oldCollection, doc).then(function (action) {\n              return observer.next(action);\n            });\n          }))[\"catch\"](function (e) {\n            return error = e;\n          }).then(function () {\n            return true;\n          });\n        }\n      }).then(function (next) {\n        if (!next) return;\n        if (error) observer.error(error);else handleOneBatch();\n      });\n    };\n\n    handleOneBatch();\n  })();\n\n  return observer.asObservable();\n}\nexport function migratePromise(oldCollection, batchSize) {\n  if (!oldCollection._migratePromise) {\n    oldCollection._migratePromise = new Promise(function (res, rej) {\n      var state$ = migrateOldCollection(oldCollection, batchSize);\n      state$.subscribe(null, rej, res);\n    });\n  }\n\n  return oldCollection._migratePromise;\n}","map":{"version":3,"sources":["/Users/Hanzalah/Desktop/github/todo-offline/rxdb-hasura-demo/node_modules/rxdb/dist/es/plugins/migration/data-migrator.js"],"names":["Subject","countAllUndeleted","getBatch","clone","toPromise","flatClone","createRxSchema","newRxError","overwritable","runPluginHooks","runAsyncPluginHooks","getPreviousVersions","createCrypter","_handleToPouch","_handleFromPouch","DataMigrator","newestCollection","migrationStrategies","_migrated","currentSchema","schema","database","name","_proto","prototype","migrate","_this","batchSize","arguments","length","undefined","state","done","total","handled","success","deleted","percent","observer","oldCols","_getOldCollections","then","ret","countAll","Promise","all","map","oldCol","pouchdb","totalCount","reduce","cur","prev","next","currentCol","shift","currentPromise","resolve","_loop","migrationState$","migrateOldCollection","res","sub","subscribe","subState","type","Math","round","e","unsubscribe","error","complete","asObservable","migratePromise","_this2","_migratePromise","mustMigrate","must","rej","state$","createOldCollection","version","schemaObj","dataMigrator","_spawnPouchDB","pouchSettings","_crypter","password","doKeyCompression","_keyCompressor","createKeyCompressor","jsonSchema","v","internalStore","get","fun","oldColDocs","filter","colDoc","createDataMigrator","_runStrategyIfNotNull","oldCollection","docOrNull","retPromise","getBatchOfOldCollection","docs","doc","migrateDocumentData","docData","nextVersion","_loop2","validate","fromVersion","toVersion","finalDoc","_migrateDocument","action","migrated","_rev","_pouchPut","remove","deleteOldCollection","destroy","removeCollectionDoc","_migrate","allBatchesDone","handleOneBatch","batch"],"mappings":"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","sourcesContent":["/**\n * The DataMigrator handles the documents from collections with older schemas\n * and transforms/saves them into the newest collection\n */\n\n/**\n * TODO this should be completely rewritten because:\n * - The current implemetation does not use pouchdb'S bulkDocs which is much faster\n * - This could have been done in much less code which would be easier to uderstand\n *\n */\nimport { Subject } from 'rxjs';\nimport { countAllUndeleted, getBatch } from '../../pouch-db';\nimport { clone, toPromise, flatClone } from '../../util';\nimport { createRxSchema } from '../../rx-schema';\nimport { newRxError } from '../../rx-error';\nimport { overwritable } from '../../overwritable';\nimport { runPluginHooks, runAsyncPluginHooks } from '../../hooks';\nimport { getPreviousVersions } from '../../rx-schema';\nimport { createCrypter } from '../../crypter';\nimport { _handleToPouch, _handleFromPouch } from '../../rx-collection-helper';\nexport var DataMigrator = /*#__PURE__*/function () {\n  function DataMigrator(newestCollection, migrationStrategies) {\n    this._migrated = false;\n    this.newestCollection = newestCollection;\n    this.migrationStrategies = migrationStrategies;\n    this.currentSchema = newestCollection.schema;\n    this.database = newestCollection.database;\n    this.name = newestCollection.name;\n  }\n\n  var _proto = DataMigrator.prototype;\n\n  _proto.migrate = function migrate() {\n    var _this = this;\n\n    var batchSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n    if (this._migrated) throw newRxError('DM1');\n    this._migrated = true;\n    var state = {\n      done: false,\n      // true if finished\n      total: 0,\n      // will be the doc-count\n      handled: 0,\n      // amount of handled docs\n      success: 0,\n      // handled docs which successed\n      deleted: 0,\n      // handled docs which got deleted\n      percent: 0 // percentage\n\n    };\n    var observer = new Subject();\n    /**\n     * TODO this is a side-effect which might throw\n     * We did this because it is not possible to create new Observer(async(...))\n     * @link https://github.com/ReactiveX/rxjs/issues/4074\n     */\n\n    (function () {\n      var oldCols;\n      return _getOldCollections(_this).then(function (ret) {\n        oldCols = ret;\n        var countAll = Promise.all(oldCols.map(function (oldCol) {\n          return countAllUndeleted(oldCol.pouchdb);\n        }));\n        return countAll;\n      }).then(function (countAll) {\n        var totalCount = countAll.reduce(function (cur, prev) {\n          return prev = cur + prev;\n        }, 0);\n        state.total = totalCount;\n        observer.next(flatClone(state));\n        var currentCol = oldCols.shift();\n        var currentPromise = Promise.resolve();\n\n        var _loop = function _loop() {\n          var migrationState$ = migrateOldCollection(currentCol, batchSize);\n          currentPromise = currentPromise.then(function () {\n            return new Promise(function (res) {\n              var sub = migrationState$.subscribe(function (subState) {\n                state.handled++;\n                state[subState.type] = state[subState.type] + 1;\n                state.percent = Math.round(state.handled / state.total * 100);\n                observer.next(flatClone(state));\n              }, function (e) {\n                sub.unsubscribe();\n                observer.error(e);\n              }, function () {\n                sub.unsubscribe();\n                res();\n              });\n            });\n          });\n          currentCol = oldCols.shift();\n        };\n\n        while (currentCol) {\n          _loop();\n        }\n\n        return currentPromise;\n      }).then(function () {\n        state.done = true;\n        state.percent = 100;\n        observer.next(flatClone(state));\n        observer.complete();\n      });\n    })();\n\n    return observer.asObservable();\n  };\n\n  _proto.migratePromise = function migratePromise(batchSize) {\n    var _this2 = this;\n\n    if (!this._migratePromise) {\n      this._migratePromise = mustMigrate(this).then(function (must) {\n        if (!must) return Promise.resolve(false);else return new Promise(function (res, rej) {\n          var state$ = _this2.migrate(batchSize);\n\n          state$.subscribe(null, rej, res);\n        });\n      });\n    }\n\n    return this._migratePromise;\n  };\n\n  return DataMigrator;\n}();\nexport function createOldCollection(version, schemaObj, dataMigrator) {\n  var database = dataMigrator.newestCollection.database;\n  var schema = createRxSchema(schemaObj, false);\n  var ret = {\n    version: version,\n    dataMigrator: dataMigrator,\n    newestCollection: dataMigrator.newestCollection,\n    database: database,\n    schema: createRxSchema(schemaObj, false),\n    pouchdb: database._spawnPouchDB(dataMigrator.newestCollection.name, version, dataMigrator.newestCollection.pouchSettings),\n    _crypter: createCrypter(database.password, schema)\n  };\n\n  if (schema.doKeyCompression()) {\n    ret._keyCompressor = overwritable.createKeyCompressor(schema);\n  }\n\n  return ret;\n}\n/**\n * get an array with OldCollection-instances from all existing old pouchdb-instance\n */\n\nexport function _getOldCollections(dataMigrator) {\n  return Promise.all(getPreviousVersions(dataMigrator.currentSchema.jsonSchema).map(function (v) {\n    return dataMigrator.database.internalStore.get(dataMigrator.name + '-' + v);\n  }).map(function (fun) {\n    return fun[\"catch\"](function () {\n      return null;\n    });\n  }) // auto-catch so Promise.all continues\n  ).then(function (oldColDocs) {\n    return oldColDocs.filter(function (colDoc) {\n      return colDoc !== null;\n    }).map(function (colDoc) {\n      return createOldCollection(colDoc.schema.version, colDoc.schema, dataMigrator);\n    });\n  });\n}\n/**\n * returns true if a migration is needed\n */\n\nexport function mustMigrate(dataMigrator) {\n  if (dataMigrator.currentSchema.version === 0) {\n    return Promise.resolve(false);\n  }\n\n  return _getOldCollections(dataMigrator).then(function (oldCols) {\n    if (oldCols.length === 0) return false;else return true;\n  });\n}\nexport function createDataMigrator(newestCollection, migrationStrategies) {\n  return new DataMigrator(newestCollection, migrationStrategies);\n}\nexport function _runStrategyIfNotNull(oldCollection, version, docOrNull) {\n  if (docOrNull === null) {\n    return Promise.resolve(null);\n  } else {\n    var ret = oldCollection.dataMigrator.migrationStrategies[version](docOrNull);\n    var retPromise = toPromise(ret);\n    return retPromise;\n  }\n}\nexport function getBatchOfOldCollection(oldCollection, batchSize) {\n  return getBatch(oldCollection.pouchdb, batchSize).then(function (docs) {\n    return docs.map(function (doc) {\n      return _handleFromPouch(oldCollection, doc);\n    });\n  });\n}\n/**\n * runs the doc-data through all following migrationStrategies\n * so it will match the newest schema.\n * @throws Error if final doc does not match final schema or migrationStrategy crashes\n * @return final object or null if migrationStrategy deleted it\n */\n\nexport function migrateDocumentData(oldCollection, docData) {\n  docData = clone(docData);\n  var nextVersion = oldCollection.version + 1; // run the document throught migrationStrategies\n\n  var currentPromise = Promise.resolve(docData);\n\n  var _loop2 = function _loop2() {\n    var version = nextVersion;\n    currentPromise = currentPromise.then(function (docOrNull) {\n      return _runStrategyIfNotNull(oldCollection, version, docOrNull);\n    });\n    nextVersion++;\n  };\n\n  while (nextVersion <= oldCollection.newestCollection.schema.version) {\n    _loop2();\n  }\n\n  return currentPromise.then(function (doc) {\n    if (doc === null) return Promise.resolve(null); // check final schema\n\n    try {\n      oldCollection.newestCollection.schema.validate(doc);\n    } catch (e) {\n      throw newRxError('DM2', {\n        fromVersion: oldCollection.version,\n        toVersion: oldCollection.newestCollection.schema.version,\n        finalDoc: doc\n      });\n    }\n\n    return doc;\n  });\n}\n/**\n * transform docdata and save to new collection\n * @return status-action with status and migrated document\n */\n\nexport function _migrateDocument(oldCollection, doc) {\n  var action = {\n    res: null,\n    type: '',\n    migrated: null,\n    doc: doc,\n    oldCollection: oldCollection,\n    newestCollection: oldCollection.newestCollection\n  };\n  return migrateDocumentData(oldCollection, doc).then(function (migrated) {\n    action.migrated = migrated;\n\n    if (migrated) {\n      runPluginHooks('preMigrateDocument', action); // save to newest collection\n\n      delete migrated._rev;\n      return oldCollection.newestCollection._pouchPut(migrated, true).then(function (res) {\n        action.res = res;\n        action.type = 'success';\n        return runAsyncPluginHooks('postMigrateDocument', action);\n      });\n    } else action.type = 'deleted';\n  }).then(function () {\n    // remove from old collection\n    return oldCollection.pouchdb.remove(_handleToPouch(oldCollection, doc))[\"catch\"](function () {});\n  }).then(function () {\n    return action;\n  });\n}\n/**\n * deletes this.pouchdb and removes it from the database.collectionsCollection\n */\n\nexport function deleteOldCollection(oldCollection) {\n  return oldCollection.pouchdb.destroy().then(function () {\n    return oldCollection.database.removeCollectionDoc(oldCollection.dataMigrator.name, oldCollection.schema);\n  });\n}\n/**\n * runs the migration on all documents and deletes the pouchdb afterwards\n */\n\nexport function migrateOldCollection(oldCollection) {\n  var batchSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n\n  if (oldCollection._migrate) {\n    // already running\n    throw newRxError('DM3');\n  }\n\n  oldCollection._migrate = true;\n  var observer = new Subject();\n  /**\n   * TODO this is a side-effect which might throw\n   * @see DataMigrator.migrate()\n   */\n\n  (function () {\n    var error;\n\n    var allBatchesDone = function allBatchesDone() {\n      // remove this oldCollection\n      return deleteOldCollection(oldCollection).then(function () {\n        return observer.complete();\n      });\n    };\n\n    var handleOneBatch = function handleOneBatch() {\n      return getBatchOfOldCollection(oldCollection, batchSize).then(function (batch) {\n        if (batch.length === 0) {\n          allBatchesDone();\n          return false;\n        } else {\n          return Promise.all(batch.map(function (doc) {\n            return _migrateDocument(oldCollection, doc).then(function (action) {\n              return observer.next(action);\n            });\n          }))[\"catch\"](function (e) {\n            return error = e;\n          }).then(function () {\n            return true;\n          });\n        }\n      }).then(function (next) {\n        if (!next) return;\n        if (error) observer.error(error);else handleOneBatch();\n      });\n    };\n\n    handleOneBatch();\n  })();\n\n  return observer.asObservable();\n}\nexport function migratePromise(oldCollection, batchSize) {\n  if (!oldCollection._migratePromise) {\n    oldCollection._migratePromise = new Promise(function (res, rej) {\n      var state$ = migrateOldCollection(oldCollection, batchSize);\n      state$.subscribe(null, rej, res);\n    });\n  }\n\n  return oldCollection._migratePromise;\n}\n//# sourceMappingURL=data-migrator.js.map"]},"metadata":{},"sourceType":"module"}
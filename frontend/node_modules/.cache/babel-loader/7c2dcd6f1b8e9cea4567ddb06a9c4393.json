{"ast":null,"code":"import { map } from 'rxjs/operators';\nimport { createChangeEvent } from './../rx-change-event';\nimport { nextTick, isElectronRenderer } from './../util';\nimport { newRxError } from '../rx-error';\n\nfunction ensureSchemaSupportsAttachments(doc) {\n  var schemaJson = doc.collection.schema.jsonID;\n\n  if (!schemaJson.attachments) {\n    throw newRxError('AT1', {\n      link: 'https://pubkey.github.io/rxdb/rx-attachment.html'\n    });\n  }\n}\n\nfunction resyncRxDocument(doc) {\n  return doc.collection.pouch.get(doc.primary).then(function (docData) {\n    var data = doc.collection._handleFromPouch(docData);\n\n    var changeEvent = createChangeEvent('UPDATE', doc.collection.database, doc.collection, doc, data);\n    doc.$emit(changeEvent);\n  });\n}\n\nexport var blobBufferUtil = {\n  /**\n   * depending if we are on node or browser,\n   * we have to use Buffer(node) or Blob(browser)\n   */\n  createBlobBuffer: function createBlobBuffer(data, type) {\n    var blobBuffer;\n\n    if (isElectronRenderer) {\n      // if we are inside of electron-renderer, always use the node-buffer\n      return Buffer.from(data, {\n        type: type\n      });\n    }\n\n    try {\n      // for browsers\n      blobBuffer = new Blob([data], {\n        type: type\n      });\n    } catch (e) {\n      // for node\n      blobBuffer = Buffer.from(data, {\n        type: type\n      });\n    }\n\n    return blobBuffer;\n  },\n  toString: function toString(blobBuffer) {\n    if (blobBuffer instanceof Buffer) {\n      // node\n      return nextTick().then(function () {\n        return blobBuffer.toString();\n      });\n    }\n\n    return new Promise(function (res) {\n      // browsers\n      var reader = new FileReader();\n      reader.addEventListener('loadend', function (e) {\n        var text = e.target.result;\n        res(text);\n      });\n      var blobBufferType = Object.prototype.toString.call(blobBuffer);\n      /**\n       * in the electron-renderer we have a typed array insteaf of a blob\n       * so we have to transform it.\n       * @link https://github.com/pubkey/rxdb/issues/1371\n       */\n\n      if (blobBufferType === '[object Uint8Array]') {\n        blobBuffer = new Blob([blobBuffer]);\n      }\n\n      reader.readAsText(blobBuffer);\n    });\n  }\n};\n\nvar _assignMethodsToAttachment = function _assignMethodsToAttachment(attachment) {\n  Object.entries(attachment.doc.collection.attachments).forEach(function (_ref) {\n    var funName = _ref[0],\n        fun = _ref[1];\n    Object.defineProperty(attachment, funName, {\n      get: function get() {\n        return fun.bind(attachment);\n      }\n    });\n  });\n};\n/**\n * an RxAttachment is basically just the attachment-stub\n * wrapped so that you can access the attachment-data\n */\n\n\nexport var RxAttachment =\n/*#__PURE__*/\nfunction () {\n  function RxAttachment(_ref2) {\n    var doc = _ref2.doc,\n        id = _ref2.id,\n        type = _ref2.type,\n        length = _ref2.length,\n        digest = _ref2.digest,\n        rev = _ref2.rev;\n    this.doc = doc;\n    this.id = id;\n    this.type = type;\n    this.length = length;\n    this.digest = digest;\n    this.rev = rev;\n\n    _assignMethodsToAttachment(this);\n  }\n\n  var _proto = RxAttachment.prototype;\n\n  _proto.remove = function remove() {\n    var _this = this;\n\n    return this.doc.collection.pouch.removeAttachment(this.doc.primary, this.id, this.doc._data._rev).then(function () {\n      return resyncRxDocument(_this.doc);\n    });\n  }\n  /**\n   * returns the data for the attachment\n   */\n  ;\n\n  _proto.getData = function getData() {\n    var _this2 = this;\n\n    return this.doc.collection.pouch.getAttachment(this.doc.primary, this.id).then(function (data) {\n      if (shouldEncrypt(_this2.doc)) {\n        return blobBufferUtil.toString(data).then(function (dataString) {\n          return blobBufferUtil.createBlobBuffer(_this2.doc.collection._crypter._decryptValue(dataString), _this2.type);\n        });\n      } else return data;\n    });\n  };\n\n  _proto.getStringData = function getStringData() {\n    return this.getData().then(function (bufferBlob) {\n      return blobBufferUtil.toString(bufferBlob);\n    });\n  };\n\n  return RxAttachment;\n}();\nexport function fromPouchDocument(id, pouchDocAttachment, rxDocument) {\n  return new RxAttachment({\n    doc: rxDocument,\n    id: id,\n    type: pouchDocAttachment.content_type,\n    length: pouchDocAttachment.length,\n    digest: pouchDocAttachment.digest,\n    rev: pouchDocAttachment.revpos\n  });\n}\n\nfunction shouldEncrypt(doc) {\n  return !!doc.collection.schema.jsonID.attachments.encrypted;\n}\n\nexport function putAttachment(_ref3) {\n  var _this3 = this;\n\n  var id = _ref3.id,\n      data = _ref3.data,\n      _ref3$type = _ref3.type,\n      type = _ref3$type === void 0 ? 'text/plain' : _ref3$type;\n  ensureSchemaSupportsAttachments(this);\n  if (shouldEncrypt(this)) data = this.collection._crypter._encryptValue(data);\n  var blobBuffer = blobBufferUtil.createBlobBuffer(data, type);\n  this._atomicQueue = this._atomicQueue.then(function () {\n    return _this3.collection.pouch.putAttachment(_this3.primary, id, _this3._data._rev, blobBuffer, type);\n  }).then(function () {\n    return _this3.collection.pouch.get(_this3.primary);\n  }).then(function (docData) {\n    var attachmentData = docData._attachments[id];\n    var attachment = fromPouchDocument(id, attachmentData, _this3);\n    _this3._data._rev = docData._rev;\n    _this3._data._attachments = docData._attachments;\n    return resyncRxDocument(_this3).then(function () {\n      return attachment;\n    });\n  });\n  return this._atomicQueue;\n}\n/**\n * get an attachment of the document by its id\n */\n\nexport function getAttachment(id) {\n  ensureSchemaSupportsAttachments(this);\n\n  var docData = this._dataSync$.getValue();\n\n  if (!docData._attachments || !docData._attachments[id]) return null;\n  var attachmentData = docData._attachments[id];\n  var attachment = fromPouchDocument(id, attachmentData, this);\n  return attachment;\n}\n/**\n * returns all attachments of the document\n */\n\nexport function allAttachments() {\n  var _this4 = this;\n\n  ensureSchemaSupportsAttachments(this);\n\n  var docData = this._dataSync$.getValue(); // if there are no attachments, the field is missing\n\n\n  if (!docData._attachments) return [];\n  return Object.keys(docData._attachments).map(function (id) {\n    return fromPouchDocument(id, docData._attachments[id], _this4);\n  });\n}\nexport function preMigrateDocument(action) {\n  delete action.migrated._attachments;\n  return action;\n}\nexport function postMigrateDocument(action) {\n  var primaryPath = action.oldCollection.schema.primaryPath;\n  var attachments = action.doc._attachments;\n  if (!attachments) return Promise.resolve(action);\n  var currentPromise = Promise.resolve();\n  Object.keys(attachments).forEach(function (id) {\n    var stubData = attachments[id];\n    var primary = action.doc[primaryPath];\n    currentPromise = currentPromise.then(function () {\n      return action.oldCollection.pouchdb.getAttachment(primary, id);\n    }).then(function (data) {\n      return blobBufferUtil.toString(data);\n    }).then(function (data) {\n      return action.newestCollection.pouch.putAttachment(primary, id, action.res.rev, blobBufferUtil.createBlobBuffer(data, stubData.content_type), stubData.content_type);\n    }).then(function (res) {\n      return action.res = res;\n    });\n  });\n  return currentPromise;\n}\nexport var rxdb = true;\nexport var prototypes = {\n  RxDocument: function RxDocument(proto) {\n    proto.putAttachment = putAttachment;\n    proto.getAttachment = getAttachment;\n    proto.allAttachments = allAttachments;\n    Object.defineProperty(proto, 'allAttachments$', {\n      get: function allAttachments$() {\n        var _this5 = this;\n\n        return this._dataSync$.pipe(map(function (data) {\n          if (!data['_attachments']) return {};\n          return data['_attachments'];\n        }), map(function (attachmentsData) {\n          return Object.entries(attachmentsData);\n        }), map(function (entries) {\n          return entries.map(function (_ref4) {\n            var id = _ref4[0],\n                attachmentData = _ref4[1];\n            return fromPouchDocument(id, attachmentData, _this5);\n          });\n        }));\n      }\n    });\n  }\n};\nexport var overwritable = {};\nexport var hooks = {\n  preMigrateDocument: preMigrateDocument,\n  postMigrateDocument: postMigrateDocument\n};\nexport default {\n  rxdb: rxdb,\n  prototypes: prototypes,\n  overwritable: overwritable,\n  hooks: hooks,\n  blobBufferUtil: blobBufferUtil\n};","map":{"version":3,"sources":["/Users/Hanzalah/Desktop/github/todo-offline/rxdb-hasura-demo/node_modules/rxdb/dist/es/plugins/attachments.js"],"names":["map","createChangeEvent","nextTick","isElectronRenderer","newRxError","ensureSchemaSupportsAttachments","doc","schemaJson","collection","schema","jsonID","attachments","link","resyncRxDocument","pouch","get","primary","then","docData","data","_handleFromPouch","changeEvent","database","$emit","blobBufferUtil","createBlobBuffer","type","blobBuffer","Buffer","from","Blob","e","toString","Promise","res","reader","FileReader","addEventListener","text","target","result","blobBufferType","Object","prototype","call","readAsText","_assignMethodsToAttachment","attachment","entries","forEach","_ref","funName","fun","defineProperty","bind","RxAttachment","_ref2","id","length","digest","rev","_proto","remove","_this","removeAttachment","_data","_rev","getData","_this2","getAttachment","shouldEncrypt","dataString","_crypter","_decryptValue","getStringData","bufferBlob","fromPouchDocument","pouchDocAttachment","rxDocument","content_type","revpos","encrypted","putAttachment","_ref3","_this3","_ref3$type","_encryptValue","_atomicQueue","attachmentData","_attachments","_dataSync$","getValue","allAttachments","_this4","keys","preMigrateDocument","action","migrated","postMigrateDocument","primaryPath","oldCollection","resolve","currentPromise","stubData","pouchdb","newestCollection","rxdb","prototypes","RxDocument","proto","allAttachments$","_this5","pipe","attachmentsData","_ref4","overwritable","hooks"],"mappings":"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","sourcesContent":["import { map } from 'rxjs/operators';\nimport { createChangeEvent } from './../rx-change-event';\nimport { nextTick, isElectronRenderer } from './../util';\nimport { newRxError } from '../rx-error';\n\nfunction ensureSchemaSupportsAttachments(doc) {\n  var schemaJson = doc.collection.schema.jsonID;\n\n  if (!schemaJson.attachments) {\n    throw newRxError('AT1', {\n      link: 'https://pubkey.github.io/rxdb/rx-attachment.html'\n    });\n  }\n}\n\nfunction resyncRxDocument(doc) {\n  return doc.collection.pouch.get(doc.primary).then(function (docData) {\n    var data = doc.collection._handleFromPouch(docData);\n\n    var changeEvent = createChangeEvent('UPDATE', doc.collection.database, doc.collection, doc, data);\n    doc.$emit(changeEvent);\n  });\n}\n\nexport var blobBufferUtil = {\n  /**\n   * depending if we are on node or browser,\n   * we have to use Buffer(node) or Blob(browser)\n   */\n  createBlobBuffer: function createBlobBuffer(data, type) {\n    var blobBuffer;\n\n    if (isElectronRenderer) {\n      // if we are inside of electron-renderer, always use the node-buffer\n      return Buffer.from(data, {\n        type: type\n      });\n    }\n\n    try {\n      // for browsers\n      blobBuffer = new Blob([data], {\n        type: type\n      });\n    } catch (e) {\n      // for node\n      blobBuffer = Buffer.from(data, {\n        type: type\n      });\n    }\n\n    return blobBuffer;\n  },\n  toString: function toString(blobBuffer) {\n    if (blobBuffer instanceof Buffer) {\n      // node\n      return nextTick().then(function () {\n        return blobBuffer.toString();\n      });\n    }\n\n    return new Promise(function (res) {\n      // browsers\n      var reader = new FileReader();\n      reader.addEventListener('loadend', function (e) {\n        var text = e.target.result;\n        res(text);\n      });\n      var blobBufferType = Object.prototype.toString.call(blobBuffer);\n      /**\n       * in the electron-renderer we have a typed array insteaf of a blob\n       * so we have to transform it.\n       * @link https://github.com/pubkey/rxdb/issues/1371\n       */\n\n      if (blobBufferType === '[object Uint8Array]') {\n        blobBuffer = new Blob([blobBuffer]);\n      }\n\n      reader.readAsText(blobBuffer);\n    });\n  }\n};\n\nvar _assignMethodsToAttachment = function _assignMethodsToAttachment(attachment) {\n  Object.entries(attachment.doc.collection.attachments).forEach(function (_ref) {\n    var funName = _ref[0],\n        fun = _ref[1];\n    Object.defineProperty(attachment, funName, {\n      get: function get() {\n        return fun.bind(attachment);\n      }\n    });\n  });\n};\n/**\n * an RxAttachment is basically just the attachment-stub\n * wrapped so that you can access the attachment-data\n */\n\n\nexport var RxAttachment = /*#__PURE__*/function () {\n  function RxAttachment(_ref2) {\n    var doc = _ref2.doc,\n        id = _ref2.id,\n        type = _ref2.type,\n        length = _ref2.length,\n        digest = _ref2.digest,\n        rev = _ref2.rev;\n    this.doc = doc;\n    this.id = id;\n    this.type = type;\n    this.length = length;\n    this.digest = digest;\n    this.rev = rev;\n\n    _assignMethodsToAttachment(this);\n  }\n\n  var _proto = RxAttachment.prototype;\n\n  _proto.remove = function remove() {\n    var _this = this;\n\n    return this.doc.collection.pouch.removeAttachment(this.doc.primary, this.id, this.doc._data._rev).then(function () {\n      return resyncRxDocument(_this.doc);\n    });\n  }\n  /**\n   * returns the data for the attachment\n   */\n  ;\n\n  _proto.getData = function getData() {\n    var _this2 = this;\n\n    return this.doc.collection.pouch.getAttachment(this.doc.primary, this.id).then(function (data) {\n      if (shouldEncrypt(_this2.doc)) {\n        return blobBufferUtil.toString(data).then(function (dataString) {\n          return blobBufferUtil.createBlobBuffer(_this2.doc.collection._crypter._decryptValue(dataString), _this2.type);\n        });\n      } else return data;\n    });\n  };\n\n  _proto.getStringData = function getStringData() {\n    return this.getData().then(function (bufferBlob) {\n      return blobBufferUtil.toString(bufferBlob);\n    });\n  };\n\n  return RxAttachment;\n}();\nexport function fromPouchDocument(id, pouchDocAttachment, rxDocument) {\n  return new RxAttachment({\n    doc: rxDocument,\n    id: id,\n    type: pouchDocAttachment.content_type,\n    length: pouchDocAttachment.length,\n    digest: pouchDocAttachment.digest,\n    rev: pouchDocAttachment.revpos\n  });\n}\n\nfunction shouldEncrypt(doc) {\n  return !!doc.collection.schema.jsonID.attachments.encrypted;\n}\n\nexport function putAttachment(_ref3) {\n  var _this3 = this;\n\n  var id = _ref3.id,\n      data = _ref3.data,\n      _ref3$type = _ref3.type,\n      type = _ref3$type === void 0 ? 'text/plain' : _ref3$type;\n  ensureSchemaSupportsAttachments(this);\n  if (shouldEncrypt(this)) data = this.collection._crypter._encryptValue(data);\n  var blobBuffer = blobBufferUtil.createBlobBuffer(data, type);\n  this._atomicQueue = this._atomicQueue.then(function () {\n    return _this3.collection.pouch.putAttachment(_this3.primary, id, _this3._data._rev, blobBuffer, type);\n  }).then(function () {\n    return _this3.collection.pouch.get(_this3.primary);\n  }).then(function (docData) {\n    var attachmentData = docData._attachments[id];\n    var attachment = fromPouchDocument(id, attachmentData, _this3);\n    _this3._data._rev = docData._rev;\n    _this3._data._attachments = docData._attachments;\n    return resyncRxDocument(_this3).then(function () {\n      return attachment;\n    });\n  });\n  return this._atomicQueue;\n}\n/**\n * get an attachment of the document by its id\n */\n\nexport function getAttachment(id) {\n  ensureSchemaSupportsAttachments(this);\n\n  var docData = this._dataSync$.getValue();\n\n  if (!docData._attachments || !docData._attachments[id]) return null;\n  var attachmentData = docData._attachments[id];\n  var attachment = fromPouchDocument(id, attachmentData, this);\n  return attachment;\n}\n/**\n * returns all attachments of the document\n */\n\nexport function allAttachments() {\n  var _this4 = this;\n\n  ensureSchemaSupportsAttachments(this);\n\n  var docData = this._dataSync$.getValue(); // if there are no attachments, the field is missing\n\n\n  if (!docData._attachments) return [];\n  return Object.keys(docData._attachments).map(function (id) {\n    return fromPouchDocument(id, docData._attachments[id], _this4);\n  });\n}\nexport function preMigrateDocument(action) {\n  delete action.migrated._attachments;\n  return action;\n}\nexport function postMigrateDocument(action) {\n  var primaryPath = action.oldCollection.schema.primaryPath;\n  var attachments = action.doc._attachments;\n  if (!attachments) return Promise.resolve(action);\n  var currentPromise = Promise.resolve();\n  Object.keys(attachments).forEach(function (id) {\n    var stubData = attachments[id];\n    var primary = action.doc[primaryPath];\n    currentPromise = currentPromise.then(function () {\n      return action.oldCollection.pouchdb.getAttachment(primary, id);\n    }).then(function (data) {\n      return blobBufferUtil.toString(data);\n    }).then(function (data) {\n      return action.newestCollection.pouch.putAttachment(primary, id, action.res.rev, blobBufferUtil.createBlobBuffer(data, stubData.content_type), stubData.content_type);\n    }).then(function (res) {\n      return action.res = res;\n    });\n  });\n  return currentPromise;\n}\nexport var rxdb = true;\nexport var prototypes = {\n  RxDocument: function RxDocument(proto) {\n    proto.putAttachment = putAttachment;\n    proto.getAttachment = getAttachment;\n    proto.allAttachments = allAttachments;\n    Object.defineProperty(proto, 'allAttachments$', {\n      get: function allAttachments$() {\n        var _this5 = this;\n\n        return this._dataSync$.pipe(map(function (data) {\n          if (!data['_attachments']) return {};\n          return data['_attachments'];\n        }), map(function (attachmentsData) {\n          return Object.entries(attachmentsData);\n        }), map(function (entries) {\n          return entries.map(function (_ref4) {\n            var id = _ref4[0],\n                attachmentData = _ref4[1];\n            return fromPouchDocument(id, attachmentData, _this5);\n          });\n        }));\n      }\n    });\n  }\n};\nexport var overwritable = {};\nexport var hooks = {\n  preMigrateDocument: preMigrateDocument,\n  postMigrateDocument: postMigrateDocument\n};\nexport default {\n  rxdb: rxdb,\n  prototypes: prototypes,\n  overwritable: overwritable,\n  hooks: hooks,\n  blobBufferUtil: blobBufferUtil\n};\n//# sourceMappingURL=attachments.js.map"]},"metadata":{},"sourceType":"module"}
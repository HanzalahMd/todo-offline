{"ast":null,"code":"import { upsert, flatten, guardedConsole, nextTick, isRemote } from 'pouchdb-utils';\nimport { stringMd5 } from 'pouchdb-md5';\nimport { Set, Map } from 'pouchdb-collections';\nimport { base64StringToBlobOrBuffer } from 'pouchdb-binary-utils';\nimport { collate, toIndexableString, normalizeKey, parseIndexableString } from 'pouchdb-collate';\nimport { generateErrorFromResponse } from 'pouchdb-errors';\nimport { Headers } from 'pouchdb-fetch';\nimport { callbackify, sequentialize, uniq, fin, promisedCallback, mapToKeysArray, QueryParseError, NotFoundError, BuiltInError } from 'pouchdb-mapreduce-utils';\n/*\n * Simple task queue to sequentialize actions. Assumes\n * callbacks will eventually fire (once).\n */\n\nfunction TaskQueue() {\n  this.promise = new Promise(function (fulfill) {\n    fulfill();\n  });\n}\n\nTaskQueue.prototype.add = function (promiseFactory) {\n  this.promise = this.promise.catch(function () {// just recover\n  }).then(function () {\n    return promiseFactory();\n  });\n  return this.promise;\n};\n\nTaskQueue.prototype.finish = function () {\n  return this.promise;\n};\n\nfunction stringify(input) {\n  if (!input) {\n    return 'undefined'; // backwards compat for empty reduce\n  } // for backwards compat with mapreduce, functions/strings are stringified\n  // as-is. everything else is JSON-stringified.\n\n\n  switch (typeof input) {\n    case 'function':\n      // e.g. a mapreduce map\n      return input.toString();\n\n    case 'string':\n      // e.g. a mapreduce built-in _reduce function\n      return input.toString();\n\n    default:\n      // e.g. a JSON object in the case of mango queries\n      return JSON.stringify(input);\n  }\n}\n/* create a string signature for a view so we can cache it and uniq it */\n\n\nfunction createViewSignature(mapFun, reduceFun) {\n  // the \"undefined\" part is for backwards compatibility\n  return stringify(mapFun) + stringify(reduceFun) + 'undefined';\n}\n\nfunction createView(sourceDB, viewName, mapFun, reduceFun, temporary, localDocName) {\n  var viewSignature = createViewSignature(mapFun, reduceFun);\n  var cachedViews;\n\n  if (!temporary) {\n    // cache this to ensure we don't try to update the same view twice\n    cachedViews = sourceDB._cachedViews = sourceDB._cachedViews || {};\n\n    if (cachedViews[viewSignature]) {\n      return cachedViews[viewSignature];\n    }\n  }\n\n  var promiseForView = sourceDB.info().then(function (info) {\n    var depDbName = info.db_name + '-mrview-' + (temporary ? 'temp' : stringMd5(viewSignature)); // save the view name in the source db so it can be cleaned up if necessary\n    // (e.g. when the _design doc is deleted, remove all associated view data)\n\n    function diffFunction(doc) {\n      doc.views = doc.views || {};\n      var fullViewName = viewName;\n\n      if (fullViewName.indexOf('/') === -1) {\n        fullViewName = viewName + '/' + viewName;\n      }\n\n      var depDbs = doc.views[fullViewName] = doc.views[fullViewName] || {};\n      /* istanbul ignore if */\n\n      if (depDbs[depDbName]) {\n        return; // no update necessary\n      }\n\n      depDbs[depDbName] = true;\n      return doc;\n    }\n\n    return upsert(sourceDB, '_local/' + localDocName, diffFunction).then(function () {\n      return sourceDB.registerDependentDatabase(depDbName).then(function (res) {\n        var db = res.db;\n        db.auto_compaction = true;\n        var view = {\n          name: depDbName,\n          db: db,\n          sourceDB: sourceDB,\n          adapter: sourceDB.adapter,\n          mapFun: mapFun,\n          reduceFun: reduceFun\n        };\n        return view.db.get('_local/lastSeq').catch(function (err) {\n          /* istanbul ignore if */\n          if (err.status !== 404) {\n            throw err;\n          }\n        }).then(function (lastSeqDoc) {\n          view.seq = lastSeqDoc ? lastSeqDoc.seq : 0;\n\n          if (cachedViews) {\n            view.db.once('destroyed', function () {\n              delete cachedViews[viewSignature];\n            });\n          }\n\n          return view;\n        });\n      });\n    });\n  });\n\n  if (cachedViews) {\n    cachedViews[viewSignature] = promiseForView;\n  }\n\n  return promiseForView;\n}\n\nvar persistentQueues = {};\nvar tempViewQueue = new TaskQueue();\nvar CHANGES_BATCH_SIZE = 50;\n\nfunction parseViewName(name) {\n  // can be either 'ddocname/viewname' or just 'viewname'\n  // (where the ddoc name is the same)\n  return name.indexOf('/') === -1 ? [name, name] : name.split('/');\n}\n\nfunction isGenOne(changes) {\n  // only return true if the current change is 1-\n  // and there are no other leafs\n  return changes.length === 1 && /^1-/.test(changes[0].rev);\n}\n\nfunction emitError(db, e) {\n  try {\n    db.emit('error', e);\n  } catch (err) {\n    guardedConsole('error', 'The user\\'s map/reduce function threw an uncaught error.\\n' + 'You can debug this error by doing:\\n' + 'myDatabase.on(\\'error\\', function (err) { debugger; });\\n' + 'Please double-check your map/reduce function.');\n    guardedConsole('error', e);\n  }\n}\n/**\n * Returns an \"abstract\" mapreduce object of the form:\n *\n *   {\n *     query: queryFun,\n *     viewCleanup: viewCleanupFun\n *   }\n *\n * Arguments are:\n *\n * localDoc: string\n *   This is for the local doc that gets saved in order to track the\n *   \"dependent\" DBs and clean them up for viewCleanup. It should be\n *   unique, so that indexer plugins don't collide with each other.\n * mapper: function (mapFunDef, emit)\n *   Returns a map function based on the mapFunDef, which in the case of\n *   normal map/reduce is just the de-stringified function, but may be\n *   something else, such as an object in the case of pouchdb-find.\n * reducer: function (reduceFunDef)\n *   Ditto, but for reducing. Modules don't have to support reducing\n *   (e.g. pouchdb-find).\n * ddocValidator: function (ddoc, viewName)\n *   Throws an error if the ddoc or viewName is not valid.\n *   This could be a way to communicate to the user that the configuration for the\n *   indexer is invalid.\n */\n\n\nfunction createAbstractMapReduce(localDocName, mapper, reducer, ddocValidator) {\n  function tryMap(db, fun, doc) {\n    // emit an event if there was an error thrown by a map function.\n    // putting try/catches in a single function also avoids deoptimizations.\n    try {\n      fun(doc);\n    } catch (e) {\n      emitError(db, e);\n    }\n  }\n\n  function tryReduce(db, fun, keys, values, rereduce) {\n    // same as above, but returning the result or an error. there are two separate\n    // functions to avoid extra memory allocations since the tryCode() case is used\n    // for custom map functions (common) vs this function, which is only used for\n    // custom reduce functions (rare)\n    try {\n      return {\n        output: fun(keys, values, rereduce)\n      };\n    } catch (e) {\n      emitError(db, e);\n      return {\n        error: e\n      };\n    }\n  }\n\n  function sortByKeyThenValue(x, y) {\n    var keyCompare = collate(x.key, y.key);\n    return keyCompare !== 0 ? keyCompare : collate(x.value, y.value);\n  }\n\n  function sliceResults(results, limit, skip) {\n    skip = skip || 0;\n\n    if (typeof limit === 'number') {\n      return results.slice(skip, limit + skip);\n    } else if (skip > 0) {\n      return results.slice(skip);\n    }\n\n    return results;\n  }\n\n  function rowToDocId(row) {\n    var val = row.value; // Users can explicitly specify a joined doc _id, or it\n    // defaults to the doc _id that emitted the key/value.\n\n    var docId = val && typeof val === 'object' && val._id || row.id;\n    return docId;\n  }\n\n  function readAttachmentsAsBlobOrBuffer(res) {\n    res.rows.forEach(function (row) {\n      var atts = row.doc && row.doc._attachments;\n\n      if (!atts) {\n        return;\n      }\n\n      Object.keys(atts).forEach(function (filename) {\n        var att = atts[filename];\n        atts[filename].data = base64StringToBlobOrBuffer(att.data, att.content_type);\n      });\n    });\n  }\n\n  function postprocessAttachments(opts) {\n    return function (res) {\n      if (opts.include_docs && opts.attachments && opts.binary) {\n        readAttachmentsAsBlobOrBuffer(res);\n      }\n\n      return res;\n    };\n  }\n\n  function addHttpParam(paramName, opts, params, asJson) {\n    // add an http param from opts to params, optionally json-encoded\n    var val = opts[paramName];\n\n    if (typeof val !== 'undefined') {\n      if (asJson) {\n        val = encodeURIComponent(JSON.stringify(val));\n      }\n\n      params.push(paramName + '=' + val);\n    }\n  }\n\n  function coerceInteger(integerCandidate) {\n    if (typeof integerCandidate !== 'undefined') {\n      var asNumber = Number(integerCandidate); // prevents e.g. '1foo' or '1.1' being coerced to 1\n\n      if (!isNaN(asNumber) && asNumber === parseInt(integerCandidate, 10)) {\n        return asNumber;\n      } else {\n        return integerCandidate;\n      }\n    }\n  }\n\n  function coerceOptions(opts) {\n    opts.group_level = coerceInteger(opts.group_level);\n    opts.limit = coerceInteger(opts.limit);\n    opts.skip = coerceInteger(opts.skip);\n    return opts;\n  }\n\n  function checkPositiveInteger(number) {\n    if (number) {\n      if (typeof number !== 'number') {\n        return new QueryParseError('Invalid value for integer: \"' + number + '\"');\n      }\n\n      if (number < 0) {\n        return new QueryParseError('Invalid value for positive integer: ' + '\"' + number + '\"');\n      }\n    }\n  }\n\n  function checkQueryParseError(options, fun) {\n    var startkeyName = options.descending ? 'endkey' : 'startkey';\n    var endkeyName = options.descending ? 'startkey' : 'endkey';\n\n    if (typeof options[startkeyName] !== 'undefined' && typeof options[endkeyName] !== 'undefined' && collate(options[startkeyName], options[endkeyName]) > 0) {\n      throw new QueryParseError('No rows can match your key range, ' + 'reverse your start_key and end_key or set {descending : true}');\n    } else if (fun.reduce && options.reduce !== false) {\n      if (options.include_docs) {\n        throw new QueryParseError('{include_docs:true} is invalid for reduce');\n      } else if (options.keys && options.keys.length > 1 && !options.group && !options.group_level) {\n        throw new QueryParseError('Multi-key fetches for reduce views must use ' + '{group: true}');\n      }\n    }\n\n    ['group_level', 'limit', 'skip'].forEach(function (optionName) {\n      var error = checkPositiveInteger(options[optionName]);\n\n      if (error) {\n        throw error;\n      }\n    });\n  }\n\n  function httpQuery(db, fun, opts) {\n    // List of parameters to add to the PUT request\n    var params = [];\n    var body;\n    var method = 'GET';\n    var ok, status; // If opts.reduce exists and is defined, then add it to the list\n    // of parameters.\n    // If reduce=false then the results are that of only the map function\n    // not the final result of map and reduce.\n\n    addHttpParam('reduce', opts, params);\n    addHttpParam('include_docs', opts, params);\n    addHttpParam('attachments', opts, params);\n    addHttpParam('limit', opts, params);\n    addHttpParam('descending', opts, params);\n    addHttpParam('group', opts, params);\n    addHttpParam('group_level', opts, params);\n    addHttpParam('skip', opts, params);\n    addHttpParam('stale', opts, params);\n    addHttpParam('conflicts', opts, params);\n    addHttpParam('startkey', opts, params, true);\n    addHttpParam('start_key', opts, params, true);\n    addHttpParam('endkey', opts, params, true);\n    addHttpParam('end_key', opts, params, true);\n    addHttpParam('inclusive_end', opts, params);\n    addHttpParam('key', opts, params, true);\n    addHttpParam('update_seq', opts, params); // Format the list of parameters into a valid URI query string\n\n    params = params.join('&');\n    params = params === '' ? '' : '?' + params; // If keys are supplied, issue a POST to circumvent GET query string limits\n    // see http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options\n\n    if (typeof opts.keys !== 'undefined') {\n      var MAX_URL_LENGTH = 2000; // according to http://stackoverflow.com/a/417184/680742,\n      // the de facto URL length limit is 2000 characters\n\n      var keysAsString = 'keys=' + encodeURIComponent(JSON.stringify(opts.keys));\n\n      if (keysAsString.length + params.length + 1 <= MAX_URL_LENGTH) {\n        // If the keys are short enough, do a GET. we do this to work around\n        // Safari not understanding 304s on POSTs (see pouchdb/pouchdb#1239)\n        params += (params[0] === '?' ? '&' : '?') + keysAsString;\n      } else {\n        method = 'POST';\n\n        if (typeof fun === 'string') {\n          body = {\n            keys: opts.keys\n          };\n        } else {\n          // fun is {map : mapfun}, so append to this\n          fun.keys = opts.keys;\n        }\n      }\n    } // We are referencing a query defined in the design doc\n\n\n    if (typeof fun === 'string') {\n      var parts = parseViewName(fun);\n      return db.fetch('_design/' + parts[0] + '/_view/' + parts[1] + params, {\n        headers: new Headers({\n          'Content-Type': 'application/json'\n        }),\n        method: method,\n        body: JSON.stringify(body)\n      }).then(function (response) {\n        ok = response.ok;\n        status = response.status;\n        return response.json();\n      }).then(function (result) {\n        if (!ok) {\n          result.status = status;\n          throw generateErrorFromResponse(result);\n        } // fail the entire request if the result contains an error\n\n\n        result.rows.forEach(function (row) {\n          /* istanbul ignore if */\n          if (row.value && row.value.error && row.value.error === \"builtin_reduce_error\") {\n            throw new Error(row.reason);\n          }\n        });\n        return result;\n      }).then(postprocessAttachments(opts));\n    } // We are using a temporary view, terrible for performance, good for testing\n\n\n    body = body || {};\n    Object.keys(fun).forEach(function (key) {\n      if (Array.isArray(fun[key])) {\n        body[key] = fun[key];\n      } else {\n        body[key] = fun[key].toString();\n      }\n    });\n    return db.fetch('_temp_view' + params, {\n      headers: new Headers({\n        'Content-Type': 'application/json'\n      }),\n      method: 'POST',\n      body: JSON.stringify(body)\n    }).then(function (response) {\n      ok = response.ok;\n      status = response.status;\n      return response.json();\n    }).then(function (result) {\n      if (!ok) {\n        result.status = status;\n        throw generateErrorFromResponse(result);\n      }\n\n      return result;\n    }).then(postprocessAttachments(opts));\n  } // custom adapters can define their own api._query\n  // and override the default behavior\n\n  /* istanbul ignore next */\n\n\n  function customQuery(db, fun, opts) {\n    return new Promise(function (resolve, reject) {\n      db._query(fun, opts, function (err, res) {\n        if (err) {\n          return reject(err);\n        }\n\n        resolve(res);\n      });\n    });\n  } // custom adapters can define their own api._viewCleanup\n  // and override the default behavior\n\n  /* istanbul ignore next */\n\n\n  function customViewCleanup(db) {\n    return new Promise(function (resolve, reject) {\n      db._viewCleanup(function (err, res) {\n        if (err) {\n          return reject(err);\n        }\n\n        resolve(res);\n      });\n    });\n  }\n\n  function defaultsTo(value) {\n    return function (reason) {\n      /* istanbul ignore else */\n      if (reason.status === 404) {\n        return value;\n      } else {\n        throw reason;\n      }\n    };\n  } // returns a promise for a list of docs to update, based on the input docId.\n  // the order doesn't matter, because post-3.2.0, bulkDocs\n  // is an atomic operation in all three adapters.\n\n\n  function getDocsToPersist(docId, view, docIdsToChangesAndEmits) {\n    var metaDocId = '_local/doc_' + docId;\n    var defaultMetaDoc = {\n      _id: metaDocId,\n      keys: []\n    };\n    var docData = docIdsToChangesAndEmits.get(docId);\n    var indexableKeysToKeyValues = docData[0];\n    var changes = docData[1];\n\n    function getMetaDoc() {\n      if (isGenOne(changes)) {\n        // generation 1, so we can safely assume initial state\n        // for performance reasons (avoids unnecessary GETs)\n        return Promise.resolve(defaultMetaDoc);\n      }\n\n      return view.db.get(metaDocId).catch(defaultsTo(defaultMetaDoc));\n    }\n\n    function getKeyValueDocs(metaDoc) {\n      if (!metaDoc.keys.length) {\n        // no keys, no need for a lookup\n        return Promise.resolve({\n          rows: []\n        });\n      }\n\n      return view.db.allDocs({\n        keys: metaDoc.keys,\n        include_docs: true\n      });\n    }\n\n    function processKeyValueDocs(metaDoc, kvDocsRes) {\n      var kvDocs = [];\n      var oldKeys = new Set();\n\n      for (var i = 0, len = kvDocsRes.rows.length; i < len; i++) {\n        var row = kvDocsRes.rows[i];\n        var doc = row.doc;\n\n        if (!doc) {\n          // deleted\n          continue;\n        }\n\n        kvDocs.push(doc);\n        oldKeys.add(doc._id);\n        doc._deleted = !indexableKeysToKeyValues.has(doc._id);\n\n        if (!doc._deleted) {\n          var keyValue = indexableKeysToKeyValues.get(doc._id);\n\n          if ('value' in keyValue) {\n            doc.value = keyValue.value;\n          }\n        }\n      }\n\n      var newKeys = mapToKeysArray(indexableKeysToKeyValues);\n      newKeys.forEach(function (key) {\n        if (!oldKeys.has(key)) {\n          // new doc\n          var kvDoc = {\n            _id: key\n          };\n          var keyValue = indexableKeysToKeyValues.get(key);\n\n          if ('value' in keyValue) {\n            kvDoc.value = keyValue.value;\n          }\n\n          kvDocs.push(kvDoc);\n        }\n      });\n      metaDoc.keys = uniq(newKeys.concat(metaDoc.keys));\n      kvDocs.push(metaDoc);\n      return kvDocs;\n    }\n\n    return getMetaDoc().then(function (metaDoc) {\n      return getKeyValueDocs(metaDoc).then(function (kvDocsRes) {\n        return processKeyValueDocs(metaDoc, kvDocsRes);\n      });\n    });\n  } // updates all emitted key/value docs and metaDocs in the mrview database\n  // for the given batch of documents from the source database\n\n\n  function saveKeyValues(view, docIdsToChangesAndEmits, seq) {\n    var seqDocId = '_local/lastSeq';\n    return view.db.get(seqDocId).catch(defaultsTo({\n      _id: seqDocId,\n      seq: 0\n    })).then(function (lastSeqDoc) {\n      var docIds = mapToKeysArray(docIdsToChangesAndEmits);\n      return Promise.all(docIds.map(function (docId) {\n        return getDocsToPersist(docId, view, docIdsToChangesAndEmits);\n      })).then(function (listOfDocsToPersist) {\n        var docsToPersist = flatten(listOfDocsToPersist);\n        lastSeqDoc.seq = seq;\n        docsToPersist.push(lastSeqDoc); // write all docs in a single operation, update the seq once\n\n        return view.db.bulkDocs({\n          docs: docsToPersist\n        });\n      });\n    });\n  }\n\n  function getQueue(view) {\n    var viewName = typeof view === 'string' ? view : view.name;\n    var queue = persistentQueues[viewName];\n\n    if (!queue) {\n      queue = persistentQueues[viewName] = new TaskQueue();\n    }\n\n    return queue;\n  }\n\n  function updateView(view) {\n    return sequentialize(getQueue(view), function () {\n      return updateViewInQueue(view);\n    })();\n  }\n\n  function updateViewInQueue(view) {\n    // bind the emit function once\n    var mapResults;\n    var doc;\n\n    function emit(key, value) {\n      var output = {\n        id: doc._id,\n        key: normalizeKey(key)\n      }; // Don't explicitly store the value unless it's defined and non-null.\n      // This saves on storage space, because often people don't use it.\n\n      if (typeof value !== 'undefined' && value !== null) {\n        output.value = normalizeKey(value);\n      }\n\n      mapResults.push(output);\n    }\n\n    var mapFun = mapper(view.mapFun, emit);\n    var currentSeq = view.seq || 0;\n\n    function processChange(docIdsToChangesAndEmits, seq) {\n      return function () {\n        return saveKeyValues(view, docIdsToChangesAndEmits, seq);\n      };\n    }\n\n    var queue = new TaskQueue();\n\n    function processNextBatch() {\n      return view.sourceDB.changes({\n        return_docs: true,\n        conflicts: true,\n        include_docs: true,\n        style: 'all_docs',\n        since: currentSeq,\n        limit: CHANGES_BATCH_SIZE\n      }).then(processBatch);\n    }\n\n    function processBatch(response) {\n      var results = response.results;\n\n      if (!results.length) {\n        return;\n      }\n\n      var docIdsToChangesAndEmits = createDocIdsToChangesAndEmits(results);\n      queue.add(processChange(docIdsToChangesAndEmits, currentSeq));\n\n      if (results.length < CHANGES_BATCH_SIZE) {\n        return;\n      }\n\n      return processNextBatch();\n    }\n\n    function createDocIdsToChangesAndEmits(results) {\n      var docIdsToChangesAndEmits = new Map();\n\n      for (var i = 0, len = results.length; i < len; i++) {\n        var change = results[i];\n\n        if (change.doc._id[0] !== '_') {\n          mapResults = [];\n          doc = change.doc;\n\n          if (!doc._deleted) {\n            tryMap(view.sourceDB, mapFun, doc);\n          }\n\n          mapResults.sort(sortByKeyThenValue);\n          var indexableKeysToKeyValues = createIndexableKeysToKeyValues(mapResults);\n          docIdsToChangesAndEmits.set(change.doc._id, [indexableKeysToKeyValues, change.changes]);\n        }\n\n        currentSeq = change.seq;\n      }\n\n      return docIdsToChangesAndEmits;\n    }\n\n    function createIndexableKeysToKeyValues(mapResults) {\n      var indexableKeysToKeyValues = new Map();\n      var lastKey;\n\n      for (var i = 0, len = mapResults.length; i < len; i++) {\n        var emittedKeyValue = mapResults[i];\n        var complexKey = [emittedKeyValue.key, emittedKeyValue.id];\n\n        if (i > 0 && collate(emittedKeyValue.key, lastKey) === 0) {\n          complexKey.push(i); // dup key+id, so make it unique\n        }\n\n        indexableKeysToKeyValues.set(toIndexableString(complexKey), emittedKeyValue);\n        lastKey = emittedKeyValue.key;\n      }\n\n      return indexableKeysToKeyValues;\n    }\n\n    return processNextBatch().then(function () {\n      return queue.finish();\n    }).then(function () {\n      view.seq = currentSeq;\n    });\n  }\n\n  function reduceView(view, results, options) {\n    if (options.group_level === 0) {\n      delete options.group_level;\n    }\n\n    var shouldGroup = options.group || options.group_level;\n    var reduceFun = reducer(view.reduceFun);\n    var groups = [];\n    var lvl = isNaN(options.group_level) ? Number.POSITIVE_INFINITY : options.group_level;\n    results.forEach(function (e) {\n      var last = groups[groups.length - 1];\n      var groupKey = shouldGroup ? e.key : null; // only set group_level for array keys\n\n      if (shouldGroup && Array.isArray(groupKey)) {\n        groupKey = groupKey.slice(0, lvl);\n      }\n\n      if (last && collate(last.groupKey, groupKey) === 0) {\n        last.keys.push([e.key, e.id]);\n        last.values.push(e.value);\n        return;\n      }\n\n      groups.push({\n        keys: [[e.key, e.id]],\n        values: [e.value],\n        groupKey: groupKey\n      });\n    });\n    results = [];\n\n    for (var i = 0, len = groups.length; i < len; i++) {\n      var e = groups[i];\n      var reduceTry = tryReduce(view.sourceDB, reduceFun, e.keys, e.values, false);\n\n      if (reduceTry.error && reduceTry.error instanceof BuiltInError) {\n        // CouchDB returns an error if a built-in errors out\n        throw reduceTry.error;\n      }\n\n      results.push({\n        // CouchDB just sets the value to null if a non-built-in errors out\n        value: reduceTry.error ? null : reduceTry.output,\n        key: e.groupKey\n      });\n    } // no total_rows/offset when reducing\n\n\n    return {\n      rows: sliceResults(results, options.limit, options.skip)\n    };\n  }\n\n  function queryView(view, opts) {\n    return sequentialize(getQueue(view), function () {\n      return queryViewInQueue(view, opts);\n    })();\n  }\n\n  function queryViewInQueue(view, opts) {\n    var totalRows;\n    var shouldReduce = view.reduceFun && opts.reduce !== false;\n    var skip = opts.skip || 0;\n\n    if (typeof opts.keys !== 'undefined' && !opts.keys.length) {\n      // equivalent query\n      opts.limit = 0;\n      delete opts.keys;\n    }\n\n    function fetchFromView(viewOpts) {\n      viewOpts.include_docs = true;\n      return view.db.allDocs(viewOpts).then(function (res) {\n        totalRows = res.total_rows;\n        return res.rows.map(function (result) {\n          // implicit migration - in older versions of PouchDB,\n          // we explicitly stored the doc as {id: ..., key: ..., value: ...}\n          // this is tested in a migration test\n\n          /* istanbul ignore next */\n          if ('value' in result.doc && typeof result.doc.value === 'object' && result.doc.value !== null) {\n            var keys = Object.keys(result.doc.value).sort(); // this detection method is not perfect, but it's unlikely the user\n            // emitted a value which was an object with these 3 exact keys\n\n            var expectedKeys = ['id', 'key', 'value'];\n\n            if (!(keys < expectedKeys || keys > expectedKeys)) {\n              return result.doc.value;\n            }\n          }\n\n          var parsedKeyAndDocId = parseIndexableString(result.doc._id);\n          return {\n            key: parsedKeyAndDocId[0],\n            id: parsedKeyAndDocId[1],\n            value: 'value' in result.doc ? result.doc.value : null\n          };\n        });\n      });\n    }\n\n    function onMapResultsReady(rows) {\n      var finalResults;\n\n      if (shouldReduce) {\n        finalResults = reduceView(view, rows, opts);\n      } else {\n        finalResults = {\n          total_rows: totalRows,\n          offset: skip,\n          rows: rows\n        };\n      }\n      /* istanbul ignore if */\n\n\n      if (opts.update_seq) {\n        finalResults.update_seq = view.seq;\n      }\n\n      if (opts.include_docs) {\n        var docIds = uniq(rows.map(rowToDocId));\n        return view.sourceDB.allDocs({\n          keys: docIds,\n          include_docs: true,\n          conflicts: opts.conflicts,\n          attachments: opts.attachments,\n          binary: opts.binary\n        }).then(function (allDocsRes) {\n          var docIdsToDocs = new Map();\n          allDocsRes.rows.forEach(function (row) {\n            docIdsToDocs.set(row.id, row.doc);\n          });\n          rows.forEach(function (row) {\n            var docId = rowToDocId(row);\n            var doc = docIdsToDocs.get(docId);\n\n            if (doc) {\n              row.doc = doc;\n            }\n          });\n          return finalResults;\n        });\n      } else {\n        return finalResults;\n      }\n    }\n\n    if (typeof opts.keys !== 'undefined') {\n      var keys = opts.keys;\n      var fetchPromises = keys.map(function (key) {\n        var viewOpts = {\n          startkey: toIndexableString([key]),\n          endkey: toIndexableString([key, {}])\n        };\n        /* istanbul ignore if */\n\n        if (opts.update_seq) {\n          viewOpts.update_seq = true;\n        }\n\n        return fetchFromView(viewOpts);\n      });\n      return Promise.all(fetchPromises).then(flatten).then(onMapResultsReady);\n    } else {\n      // normal query, no 'keys'\n      var viewOpts = {\n        descending: opts.descending\n      };\n      /* istanbul ignore if */\n\n      if (opts.update_seq) {\n        viewOpts.update_seq = true;\n      }\n\n      var startkey;\n      var endkey;\n\n      if ('start_key' in opts) {\n        startkey = opts.start_key;\n      }\n\n      if ('startkey' in opts) {\n        startkey = opts.startkey;\n      }\n\n      if ('end_key' in opts) {\n        endkey = opts.end_key;\n      }\n\n      if ('endkey' in opts) {\n        endkey = opts.endkey;\n      }\n\n      if (typeof startkey !== 'undefined') {\n        viewOpts.startkey = opts.descending ? toIndexableString([startkey, {}]) : toIndexableString([startkey]);\n      }\n\n      if (typeof endkey !== 'undefined') {\n        var inclusiveEnd = opts.inclusive_end !== false;\n\n        if (opts.descending) {\n          inclusiveEnd = !inclusiveEnd;\n        }\n\n        viewOpts.endkey = toIndexableString(inclusiveEnd ? [endkey, {}] : [endkey]);\n      }\n\n      if (typeof opts.key !== 'undefined') {\n        var keyStart = toIndexableString([opts.key]);\n        var keyEnd = toIndexableString([opts.key, {}]);\n\n        if (viewOpts.descending) {\n          viewOpts.endkey = keyStart;\n          viewOpts.startkey = keyEnd;\n        } else {\n          viewOpts.startkey = keyStart;\n          viewOpts.endkey = keyEnd;\n        }\n      }\n\n      if (!shouldReduce) {\n        if (typeof opts.limit === 'number') {\n          viewOpts.limit = opts.limit;\n        }\n\n        viewOpts.skip = skip;\n      }\n\n      return fetchFromView(viewOpts).then(onMapResultsReady);\n    }\n  }\n\n  function httpViewCleanup(db) {\n    return db.fetch('_view_cleanup', {\n      headers: new Headers({\n        'Content-Type': 'application/json'\n      }),\n      method: 'POST'\n    }).then(function (response) {\n      return response.json();\n    });\n  }\n\n  function localViewCleanup(db) {\n    return db.get('_local/' + localDocName).then(function (metaDoc) {\n      var docsToViews = new Map();\n      Object.keys(metaDoc.views).forEach(function (fullViewName) {\n        var parts = parseViewName(fullViewName);\n        var designDocName = '_design/' + parts[0];\n        var viewName = parts[1];\n        var views = docsToViews.get(designDocName);\n\n        if (!views) {\n          views = new Set();\n          docsToViews.set(designDocName, views);\n        }\n\n        views.add(viewName);\n      });\n      var opts = {\n        keys: mapToKeysArray(docsToViews),\n        include_docs: true\n      };\n      return db.allDocs(opts).then(function (res) {\n        var viewsToStatus = {};\n        res.rows.forEach(function (row) {\n          var ddocName = row.key.substring(8); // cuts off '_design/'\n\n          docsToViews.get(row.key).forEach(function (viewName) {\n            var fullViewName = ddocName + '/' + viewName;\n            /* istanbul ignore if */\n\n            if (!metaDoc.views[fullViewName]) {\n              // new format, without slashes, to support PouchDB 2.2.0\n              // migration test in pouchdb's browser.migration.js verifies this\n              fullViewName = viewName;\n            }\n\n            var viewDBNames = Object.keys(metaDoc.views[fullViewName]); // design doc deleted, or view function nonexistent\n\n            var statusIsGood = row.doc && row.doc.views && row.doc.views[viewName];\n            viewDBNames.forEach(function (viewDBName) {\n              viewsToStatus[viewDBName] = viewsToStatus[viewDBName] || statusIsGood;\n            });\n          });\n        });\n        var dbsToDelete = Object.keys(viewsToStatus).filter(function (viewDBName) {\n          return !viewsToStatus[viewDBName];\n        });\n        var destroyPromises = dbsToDelete.map(function (viewDBName) {\n          return sequentialize(getQueue(viewDBName), function () {\n            return new db.constructor(viewDBName, db.__opts).destroy();\n          })();\n        });\n        return Promise.all(destroyPromises).then(function () {\n          return {\n            ok: true\n          };\n        });\n      });\n    }, defaultsTo({\n      ok: true\n    }));\n  }\n\n  function queryPromised(db, fun, opts) {\n    /* istanbul ignore next */\n    if (typeof db._query === 'function') {\n      return customQuery(db, fun, opts);\n    }\n\n    if (isRemote(db)) {\n      return httpQuery(db, fun, opts);\n    }\n\n    if (typeof fun !== 'string') {\n      // temp_view\n      checkQueryParseError(opts, fun);\n      tempViewQueue.add(function () {\n        var createViewPromise = createView(\n        /* sourceDB */\n        db,\n        /* viewName */\n        'temp_view/temp_view',\n        /* mapFun */\n        fun.map,\n        /* reduceFun */\n        fun.reduce,\n        /* temporary */\n        true,\n        /* localDocName */\n        localDocName);\n        return createViewPromise.then(function (view) {\n          return fin(updateView(view).then(function () {\n            return queryView(view, opts);\n          }), function () {\n            return view.db.destroy();\n          });\n        });\n      });\n      return tempViewQueue.finish();\n    } else {\n      // persistent view\n      var fullViewName = fun;\n      var parts = parseViewName(fullViewName);\n      var designDocName = parts[0];\n      var viewName = parts[1];\n      return db.get('_design/' + designDocName).then(function (doc) {\n        var fun = doc.views && doc.views[viewName];\n\n        if (!fun) {\n          // basic validator; it's assumed that every subclass would want this\n          throw new NotFoundError('ddoc ' + doc._id + ' has no view named ' + viewName);\n        }\n\n        ddocValidator(doc, viewName);\n        checkQueryParseError(opts, fun);\n        var createViewPromise = createView(\n        /* sourceDB */\n        db,\n        /* viewName */\n        fullViewName,\n        /* mapFun */\n        fun.map,\n        /* reduceFun */\n        fun.reduce,\n        /* temporary */\n        false,\n        /* localDocName */\n        localDocName);\n        return createViewPromise.then(function (view) {\n          if (opts.stale === 'ok' || opts.stale === 'update_after') {\n            if (opts.stale === 'update_after') {\n              nextTick(function () {\n                updateView(view);\n              });\n            }\n\n            return queryView(view, opts);\n          } else {\n            // stale not ok\n            return updateView(view).then(function () {\n              return queryView(view, opts);\n            });\n          }\n        });\n      });\n    }\n  }\n\n  function abstractQuery(fun, opts, callback) {\n    var db = this;\n\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    opts = opts ? coerceOptions(opts) : {};\n\n    if (typeof fun === 'function') {\n      fun = {\n        map: fun\n      };\n    }\n\n    var promise = Promise.resolve().then(function () {\n      return queryPromised(db, fun, opts);\n    });\n    promisedCallback(promise, callback);\n    return promise;\n  }\n\n  var abstractViewCleanup = callbackify(function () {\n    var db = this;\n    /* istanbul ignore next */\n\n    if (typeof db._viewCleanup === 'function') {\n      return customViewCleanup(db);\n    }\n\n    if (isRemote(db)) {\n      return httpViewCleanup(db);\n    }\n\n    return localViewCleanup(db);\n  });\n  return {\n    query: abstractQuery,\n    viewCleanup: abstractViewCleanup\n  };\n}\n\nexport default createAbstractMapReduce;","map":{"version":3,"sources":["/Users/Hanzalah/Desktop/github/todo-offline/rxdb-hasura-demo/node_modules/pouchdb-abstract-mapreduce/lib/index.es.js"],"names":["upsert","flatten","guardedConsole","nextTick","isRemote","stringMd5","Set","Map","base64StringToBlobOrBuffer","collate","toIndexableString","normalizeKey","parseIndexableString","generateErrorFromResponse","Headers","callbackify","sequentialize","uniq","fin","promisedCallback","mapToKeysArray","QueryParseError","NotFoundError","BuiltInError","TaskQueue","promise","Promise","fulfill","prototype","add","promiseFactory","catch","then","finish","stringify","input","toString","JSON","createViewSignature","mapFun","reduceFun","createView","sourceDB","viewName","temporary","localDocName","viewSignature","cachedViews","_cachedViews","promiseForView","info","depDbName","db_name","diffFunction","doc","views","fullViewName","indexOf","depDbs","registerDependentDatabase","res","db","auto_compaction","view","name","adapter","get","err","status","lastSeqDoc","seq","once","persistentQueues","tempViewQueue","CHANGES_BATCH_SIZE","parseViewName","split","isGenOne","changes","length","test","rev","emitError","e","emit","createAbstractMapReduce","mapper","reducer","ddocValidator","tryMap","fun","tryReduce","keys","values","rereduce","output","error","sortByKeyThenValue","x","y","keyCompare","key","value","sliceResults","results","limit","skip","slice","rowToDocId","row","val","docId","_id","id","readAttachmentsAsBlobOrBuffer","rows","forEach","atts","_attachments","Object","filename","att","data","content_type","postprocessAttachments","opts","include_docs","attachments","binary","addHttpParam","paramName","params","asJson","encodeURIComponent","push","coerceInteger","integerCandidate","asNumber","Number","isNaN","parseInt","coerceOptions","group_level","checkPositiveInteger","number","checkQueryParseError","options","startkeyName","descending","endkeyName","reduce","group","optionName","httpQuery","body","method","ok","join","MAX_URL_LENGTH","keysAsString","parts","fetch","headers","response","json","result","Error","reason","Array","isArray","customQuery","resolve","reject","_query","customViewCleanup","_viewCleanup","defaultsTo","getDocsToPersist","docIdsToChangesAndEmits","metaDocId","defaultMetaDoc","docData","indexableKeysToKeyValues","getMetaDoc","getKeyValueDocs","metaDoc","allDocs","processKeyValueDocs","kvDocsRes","kvDocs","oldKeys","i","len","_deleted","has","keyValue","newKeys","kvDoc","concat","saveKeyValues","seqDocId","docIds","all","map","listOfDocsToPersist","docsToPersist","bulkDocs","docs","getQueue","queue","updateView","updateViewInQueue","mapResults","currentSeq","processChange","processNextBatch","return_docs","conflicts","style","since","processBatch","createDocIdsToChangesAndEmits","change","sort","createIndexableKeysToKeyValues","set","lastKey","emittedKeyValue","complexKey","reduceView","shouldGroup","groups","lvl","POSITIVE_INFINITY","last","groupKey","reduceTry","queryView","queryViewInQueue","totalRows","shouldReduce","fetchFromView","viewOpts","total_rows","expectedKeys","parsedKeyAndDocId","onMapResultsReady","finalResults","offset","update_seq","allDocsRes","docIdsToDocs","fetchPromises","startkey","endkey","start_key","end_key","inclusiveEnd","inclusive_end","keyStart","keyEnd","httpViewCleanup","localViewCleanup","docsToViews","designDocName","viewsToStatus","ddocName","substring","viewDBNames","statusIsGood","viewDBName","dbsToDelete","filter","destroyPromises","constructor","__opts","destroy","queryPromised","createViewPromise","stale","abstractQuery","callback","abstractViewCleanup","query","viewCleanup"],"mappings":"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","sourcesContent":["import { upsert, flatten, guardedConsole, nextTick, isRemote } from 'pouchdb-utils';\nimport { stringMd5 } from 'pouchdb-md5';\nimport { Set, Map } from 'pouchdb-collections';\nimport { base64StringToBlobOrBuffer } from 'pouchdb-binary-utils';\nimport { collate, toIndexableString, normalizeKey, parseIndexableString } from 'pouchdb-collate';\nimport { generateErrorFromResponse } from 'pouchdb-errors';\nimport { Headers } from 'pouchdb-fetch';\nimport { callbackify, sequentialize, uniq, fin, promisedCallback, mapToKeysArray, QueryParseError, NotFoundError, BuiltInError } from 'pouchdb-mapreduce-utils';\n\n/*\n * Simple task queue to sequentialize actions. Assumes\n * callbacks will eventually fire (once).\n */\n\n\nfunction TaskQueue() {\n  this.promise = new Promise(function (fulfill) {fulfill(); });\n}\nTaskQueue.prototype.add = function (promiseFactory) {\n  this.promise = this.promise.catch(function () {\n    // just recover\n  }).then(function () {\n    return promiseFactory();\n  });\n  return this.promise;\n};\nTaskQueue.prototype.finish = function () {\n  return this.promise;\n};\n\nfunction stringify(input) {\n  if (!input) {\n    return 'undefined'; // backwards compat for empty reduce\n  }\n  // for backwards compat with mapreduce, functions/strings are stringified\n  // as-is. everything else is JSON-stringified.\n  switch (typeof input) {\n    case 'function':\n      // e.g. a mapreduce map\n      return input.toString();\n    case 'string':\n      // e.g. a mapreduce built-in _reduce function\n      return input.toString();\n    default:\n      // e.g. a JSON object in the case of mango queries\n      return JSON.stringify(input);\n  }\n}\n\n/* create a string signature for a view so we can cache it and uniq it */\nfunction createViewSignature(mapFun, reduceFun) {\n  // the \"undefined\" part is for backwards compatibility\n  return stringify(mapFun) + stringify(reduceFun) + 'undefined';\n}\n\nfunction createView(sourceDB, viewName, mapFun, reduceFun, temporary, localDocName) {\n  var viewSignature = createViewSignature(mapFun, reduceFun);\n\n  var cachedViews;\n  if (!temporary) {\n    // cache this to ensure we don't try to update the same view twice\n    cachedViews = sourceDB._cachedViews = sourceDB._cachedViews || {};\n    if (cachedViews[viewSignature]) {\n      return cachedViews[viewSignature];\n    }\n  }\n\n  var promiseForView = sourceDB.info().then(function (info) {\n\n    var depDbName = info.db_name + '-mrview-' +\n      (temporary ? 'temp' : stringMd5(viewSignature));\n\n    // save the view name in the source db so it can be cleaned up if necessary\n    // (e.g. when the _design doc is deleted, remove all associated view data)\n    function diffFunction(doc) {\n      doc.views = doc.views || {};\n      var fullViewName = viewName;\n      if (fullViewName.indexOf('/') === -1) {\n        fullViewName = viewName + '/' + viewName;\n      }\n      var depDbs = doc.views[fullViewName] = doc.views[fullViewName] || {};\n      /* istanbul ignore if */\n      if (depDbs[depDbName]) {\n        return; // no update necessary\n      }\n      depDbs[depDbName] = true;\n      return doc;\n    }\n    return upsert(sourceDB, '_local/' + localDocName, diffFunction).then(function () {\n      return sourceDB.registerDependentDatabase(depDbName).then(function (res) {\n        var db = res.db;\n        db.auto_compaction = true;\n        var view = {\n          name: depDbName,\n          db: db,\n          sourceDB: sourceDB,\n          adapter: sourceDB.adapter,\n          mapFun: mapFun,\n          reduceFun: reduceFun\n        };\n        return view.db.get('_local/lastSeq').catch(function (err) {\n          /* istanbul ignore if */\n          if (err.status !== 404) {\n            throw err;\n          }\n        }).then(function (lastSeqDoc) {\n          view.seq = lastSeqDoc ? lastSeqDoc.seq : 0;\n          if (cachedViews) {\n            view.db.once('destroyed', function () {\n              delete cachedViews[viewSignature];\n            });\n          }\n          return view;\n        });\n      });\n    });\n  });\n\n  if (cachedViews) {\n    cachedViews[viewSignature] = promiseForView;\n  }\n  return promiseForView;\n}\n\nvar persistentQueues = {};\nvar tempViewQueue = new TaskQueue();\nvar CHANGES_BATCH_SIZE = 50;\n\nfunction parseViewName(name) {\n  // can be either 'ddocname/viewname' or just 'viewname'\n  // (where the ddoc name is the same)\n  return name.indexOf('/') === -1 ? [name, name] : name.split('/');\n}\n\nfunction isGenOne(changes) {\n  // only return true if the current change is 1-\n  // and there are no other leafs\n  return changes.length === 1 && /^1-/.test(changes[0].rev);\n}\n\nfunction emitError(db, e) {\n  try {\n    db.emit('error', e);\n  } catch (err) {\n    guardedConsole('error',\n      'The user\\'s map/reduce function threw an uncaught error.\\n' +\n      'You can debug this error by doing:\\n' +\n      'myDatabase.on(\\'error\\', function (err) { debugger; });\\n' +\n      'Please double-check your map/reduce function.');\n    guardedConsole('error', e);\n  }\n}\n\n/**\n * Returns an \"abstract\" mapreduce object of the form:\n *\n *   {\n *     query: queryFun,\n *     viewCleanup: viewCleanupFun\n *   }\n *\n * Arguments are:\n *\n * localDoc: string\n *   This is for the local doc that gets saved in order to track the\n *   \"dependent\" DBs and clean them up for viewCleanup. It should be\n *   unique, so that indexer plugins don't collide with each other.\n * mapper: function (mapFunDef, emit)\n *   Returns a map function based on the mapFunDef, which in the case of\n *   normal map/reduce is just the de-stringified function, but may be\n *   something else, such as an object in the case of pouchdb-find.\n * reducer: function (reduceFunDef)\n *   Ditto, but for reducing. Modules don't have to support reducing\n *   (e.g. pouchdb-find).\n * ddocValidator: function (ddoc, viewName)\n *   Throws an error if the ddoc or viewName is not valid.\n *   This could be a way to communicate to the user that the configuration for the\n *   indexer is invalid.\n */\nfunction createAbstractMapReduce(localDocName, mapper, reducer, ddocValidator) {\n\n  function tryMap(db, fun, doc) {\n    // emit an event if there was an error thrown by a map function.\n    // putting try/catches in a single function also avoids deoptimizations.\n    try {\n      fun(doc);\n    } catch (e) {\n      emitError(db, e);\n    }\n  }\n\n  function tryReduce(db, fun, keys, values, rereduce) {\n    // same as above, but returning the result or an error. there are two separate\n    // functions to avoid extra memory allocations since the tryCode() case is used\n    // for custom map functions (common) vs this function, which is only used for\n    // custom reduce functions (rare)\n    try {\n      return {output : fun(keys, values, rereduce)};\n    } catch (e) {\n      emitError(db, e);\n      return {error: e};\n    }\n  }\n\n  function sortByKeyThenValue(x, y) {\n    var keyCompare = collate(x.key, y.key);\n    return keyCompare !== 0 ? keyCompare : collate(x.value, y.value);\n  }\n\n  function sliceResults(results, limit, skip) {\n    skip = skip || 0;\n    if (typeof limit === 'number') {\n      return results.slice(skip, limit + skip);\n    } else if (skip > 0) {\n      return results.slice(skip);\n    }\n    return results;\n  }\n\n  function rowToDocId(row) {\n    var val = row.value;\n    // Users can explicitly specify a joined doc _id, or it\n    // defaults to the doc _id that emitted the key/value.\n    var docId = (val && typeof val === 'object' && val._id) || row.id;\n    return docId;\n  }\n\n  function readAttachmentsAsBlobOrBuffer(res) {\n    res.rows.forEach(function (row) {\n      var atts = row.doc && row.doc._attachments;\n      if (!atts) {\n        return;\n      }\n      Object.keys(atts).forEach(function (filename) {\n        var att = atts[filename];\n        atts[filename].data = base64StringToBlobOrBuffer(att.data, att.content_type);\n      });\n    });\n  }\n\n  function postprocessAttachments(opts) {\n    return function (res) {\n      if (opts.include_docs && opts.attachments && opts.binary) {\n        readAttachmentsAsBlobOrBuffer(res);\n      }\n      return res;\n    };\n  }\n\n  function addHttpParam(paramName, opts, params, asJson) {\n    // add an http param from opts to params, optionally json-encoded\n    var val = opts[paramName];\n    if (typeof val !== 'undefined') {\n      if (asJson) {\n        val = encodeURIComponent(JSON.stringify(val));\n      }\n      params.push(paramName + '=' + val);\n    }\n  }\n\n  function coerceInteger(integerCandidate) {\n    if (typeof integerCandidate !== 'undefined') {\n      var asNumber = Number(integerCandidate);\n      // prevents e.g. '1foo' or '1.1' being coerced to 1\n      if (!isNaN(asNumber) && asNumber === parseInt(integerCandidate, 10)) {\n        return asNumber;\n      } else {\n        return integerCandidate;\n      }\n    }\n  }\n\n  function coerceOptions(opts) {\n    opts.group_level = coerceInteger(opts.group_level);\n    opts.limit = coerceInteger(opts.limit);\n    opts.skip = coerceInteger(opts.skip);\n    return opts;\n  }\n\n  function checkPositiveInteger(number) {\n    if (number) {\n      if (typeof number !== 'number') {\n        return  new QueryParseError('Invalid value for integer: \"' +\n          number + '\"');\n      }\n      if (number < 0) {\n        return new QueryParseError('Invalid value for positive integer: ' +\n          '\"' + number + '\"');\n      }\n    }\n  }\n\n  function checkQueryParseError(options, fun) {\n    var startkeyName = options.descending ? 'endkey' : 'startkey';\n    var endkeyName = options.descending ? 'startkey' : 'endkey';\n\n    if (typeof options[startkeyName] !== 'undefined' &&\n      typeof options[endkeyName] !== 'undefined' &&\n      collate(options[startkeyName], options[endkeyName]) > 0) {\n      throw new QueryParseError('No rows can match your key range, ' +\n        'reverse your start_key and end_key or set {descending : true}');\n    } else if (fun.reduce && options.reduce !== false) {\n      if (options.include_docs) {\n        throw new QueryParseError('{include_docs:true} is invalid for reduce');\n      } else if (options.keys && options.keys.length > 1 &&\n        !options.group && !options.group_level) {\n        throw new QueryParseError('Multi-key fetches for reduce views must use ' +\n          '{group: true}');\n      }\n    }\n    ['group_level', 'limit', 'skip'].forEach(function (optionName) {\n      var error = checkPositiveInteger(options[optionName]);\n      if (error) {\n        throw error;\n      }\n    });\n  }\n\n  function httpQuery(db, fun, opts) {\n    // List of parameters to add to the PUT request\n    var params = [];\n    var body;\n    var method = 'GET';\n    var ok, status;\n\n    // If opts.reduce exists and is defined, then add it to the list\n    // of parameters.\n    // If reduce=false then the results are that of only the map function\n    // not the final result of map and reduce.\n    addHttpParam('reduce', opts, params);\n    addHttpParam('include_docs', opts, params);\n    addHttpParam('attachments', opts, params);\n    addHttpParam('limit', opts, params);\n    addHttpParam('descending', opts, params);\n    addHttpParam('group', opts, params);\n    addHttpParam('group_level', opts, params);\n    addHttpParam('skip', opts, params);\n    addHttpParam('stale', opts, params);\n    addHttpParam('conflicts', opts, params);\n    addHttpParam('startkey', opts, params, true);\n    addHttpParam('start_key', opts, params, true);\n    addHttpParam('endkey', opts, params, true);\n    addHttpParam('end_key', opts, params, true);\n    addHttpParam('inclusive_end', opts, params);\n    addHttpParam('key', opts, params, true);\n    addHttpParam('update_seq', opts, params);\n\n    // Format the list of parameters into a valid URI query string\n    params = params.join('&');\n    params = params === '' ? '' : '?' + params;\n\n    // If keys are supplied, issue a POST to circumvent GET query string limits\n    // see http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options\n    if (typeof opts.keys !== 'undefined') {\n      var MAX_URL_LENGTH = 2000;\n      // according to http://stackoverflow.com/a/417184/680742,\n      // the de facto URL length limit is 2000 characters\n\n      var keysAsString =\n        'keys=' + encodeURIComponent(JSON.stringify(opts.keys));\n      if (keysAsString.length + params.length + 1 <= MAX_URL_LENGTH) {\n        // If the keys are short enough, do a GET. we do this to work around\n        // Safari not understanding 304s on POSTs (see pouchdb/pouchdb#1239)\n        params += (params[0] === '?' ? '&' : '?') + keysAsString;\n      } else {\n        method = 'POST';\n        if (typeof fun === 'string') {\n          body = {keys: opts.keys};\n        } else { // fun is {map : mapfun}, so append to this\n          fun.keys = opts.keys;\n        }\n      }\n    }\n\n    // We are referencing a query defined in the design doc\n    if (typeof fun === 'string') {\n      var parts = parseViewName(fun);\n      return db.fetch('_design/' + parts[0] + '/_view/' + parts[1] + params, {\n        headers: new Headers({'Content-Type': 'application/json'}),\n        method: method,\n        body: JSON.stringify(body)\n      }).then(function (response) {\n        ok = response.ok;\n        status = response.status;\n        return response.json();\n      }).then(function (result) {\n        if (!ok) {\n          result.status = status;\n          throw generateErrorFromResponse(result);\n        }\n        // fail the entire request if the result contains an error\n        result.rows.forEach(function (row) {\n          /* istanbul ignore if */\n          if (row.value && row.value.error && row.value.error === \"builtin_reduce_error\") {\n            throw new Error(row.reason);\n          }\n        });\n        return result;\n      }).then(postprocessAttachments(opts));\n    }\n\n    // We are using a temporary view, terrible for performance, good for testing\n    body = body || {};\n    Object.keys(fun).forEach(function (key) {\n      if (Array.isArray(fun[key])) {\n        body[key] = fun[key];\n      } else {\n        body[key] = fun[key].toString();\n      }\n    });\n\n    return db.fetch('_temp_view' + params, {\n      headers: new Headers({'Content-Type': 'application/json'}),\n      method: 'POST',\n      body: JSON.stringify(body)\n    }).then(function (response) {\n        ok = response.ok;\n        status = response.status;\n      return response.json();\n    }).then(function (result) {\n      if (!ok) {\n        result.status = status;\n        throw generateErrorFromResponse(result);\n      }\n      return result;\n    }).then(postprocessAttachments(opts));\n  }\n\n  // custom adapters can define their own api._query\n  // and override the default behavior\n  /* istanbul ignore next */\n  function customQuery(db, fun, opts) {\n    return new Promise(function (resolve, reject) {\n      db._query(fun, opts, function (err, res) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(res);\n      });\n    });\n  }\n\n  // custom adapters can define their own api._viewCleanup\n  // and override the default behavior\n  /* istanbul ignore next */\n  function customViewCleanup(db) {\n    return new Promise(function (resolve, reject) {\n      db._viewCleanup(function (err, res) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(res);\n      });\n    });\n  }\n\n  function defaultsTo(value) {\n    return function (reason) {\n      /* istanbul ignore else */\n      if (reason.status === 404) {\n        return value;\n      } else {\n        throw reason;\n      }\n    };\n  }\n\n  // returns a promise for a list of docs to update, based on the input docId.\n  // the order doesn't matter, because post-3.2.0, bulkDocs\n  // is an atomic operation in all three adapters.\n  function getDocsToPersist(docId, view, docIdsToChangesAndEmits) {\n    var metaDocId = '_local/doc_' + docId;\n    var defaultMetaDoc = {_id: metaDocId, keys: []};\n    var docData = docIdsToChangesAndEmits.get(docId);\n    var indexableKeysToKeyValues = docData[0];\n    var changes = docData[1];\n\n    function getMetaDoc() {\n      if (isGenOne(changes)) {\n        // generation 1, so we can safely assume initial state\n        // for performance reasons (avoids unnecessary GETs)\n        return Promise.resolve(defaultMetaDoc);\n      }\n      return view.db.get(metaDocId).catch(defaultsTo(defaultMetaDoc));\n    }\n\n    function getKeyValueDocs(metaDoc) {\n      if (!metaDoc.keys.length) {\n        // no keys, no need for a lookup\n        return Promise.resolve({rows: []});\n      }\n      return view.db.allDocs({\n        keys: metaDoc.keys,\n        include_docs: true\n      });\n    }\n\n    function processKeyValueDocs(metaDoc, kvDocsRes) {\n      var kvDocs = [];\n      var oldKeys = new Set();\n\n      for (var i = 0, len = kvDocsRes.rows.length; i < len; i++) {\n        var row = kvDocsRes.rows[i];\n        var doc = row.doc;\n        if (!doc) { // deleted\n          continue;\n        }\n        kvDocs.push(doc);\n        oldKeys.add(doc._id);\n        doc._deleted = !indexableKeysToKeyValues.has(doc._id);\n        if (!doc._deleted) {\n          var keyValue = indexableKeysToKeyValues.get(doc._id);\n          if ('value' in keyValue) {\n            doc.value = keyValue.value;\n          }\n        }\n      }\n      var newKeys = mapToKeysArray(indexableKeysToKeyValues);\n      newKeys.forEach(function (key) {\n        if (!oldKeys.has(key)) {\n          // new doc\n          var kvDoc = {\n            _id: key\n          };\n          var keyValue = indexableKeysToKeyValues.get(key);\n          if ('value' in keyValue) {\n            kvDoc.value = keyValue.value;\n          }\n          kvDocs.push(kvDoc);\n        }\n      });\n      metaDoc.keys = uniq(newKeys.concat(metaDoc.keys));\n      kvDocs.push(metaDoc);\n\n      return kvDocs;\n    }\n\n    return getMetaDoc().then(function (metaDoc) {\n      return getKeyValueDocs(metaDoc).then(function (kvDocsRes) {\n        return processKeyValueDocs(metaDoc, kvDocsRes);\n      });\n    });\n  }\n\n  // updates all emitted key/value docs and metaDocs in the mrview database\n  // for the given batch of documents from the source database\n  function saveKeyValues(view, docIdsToChangesAndEmits, seq) {\n    var seqDocId = '_local/lastSeq';\n    return view.db.get(seqDocId)\n      .catch(defaultsTo({_id: seqDocId, seq: 0}))\n      .then(function (lastSeqDoc) {\n        var docIds = mapToKeysArray(docIdsToChangesAndEmits);\n        return Promise.all(docIds.map(function (docId) {\n          return getDocsToPersist(docId, view, docIdsToChangesAndEmits);\n        })).then(function (listOfDocsToPersist) {\n          var docsToPersist = flatten(listOfDocsToPersist);\n          lastSeqDoc.seq = seq;\n          docsToPersist.push(lastSeqDoc);\n          // write all docs in a single operation, update the seq once\n          return view.db.bulkDocs({docs : docsToPersist});\n        });\n      });\n  }\n\n  function getQueue(view) {\n    var viewName = typeof view === 'string' ? view : view.name;\n    var queue = persistentQueues[viewName];\n    if (!queue) {\n      queue = persistentQueues[viewName] = new TaskQueue();\n    }\n    return queue;\n  }\n\n  function updateView(view) {\n    return sequentialize(getQueue(view), function () {\n      return updateViewInQueue(view);\n    })();\n  }\n\n  function updateViewInQueue(view) {\n    // bind the emit function once\n    var mapResults;\n    var doc;\n\n    function emit(key, value) {\n      var output = {id: doc._id, key: normalizeKey(key)};\n      // Don't explicitly store the value unless it's defined and non-null.\n      // This saves on storage space, because often people don't use it.\n      if (typeof value !== 'undefined' && value !== null) {\n        output.value = normalizeKey(value);\n      }\n      mapResults.push(output);\n    }\n\n    var mapFun = mapper(view.mapFun, emit);\n\n    var currentSeq = view.seq || 0;\n\n    function processChange(docIdsToChangesAndEmits, seq) {\n      return function () {\n        return saveKeyValues(view, docIdsToChangesAndEmits, seq);\n      };\n    }\n\n    var queue = new TaskQueue();\n\n    function processNextBatch() {\n      return view.sourceDB.changes({\n        return_docs: true,\n        conflicts: true,\n        include_docs: true,\n        style: 'all_docs',\n        since: currentSeq,\n        limit: CHANGES_BATCH_SIZE\n      }).then(processBatch);\n    }\n\n    function processBatch(response) {\n      var results = response.results;\n      if (!results.length) {\n        return;\n      }\n      var docIdsToChangesAndEmits = createDocIdsToChangesAndEmits(results);\n      queue.add(processChange(docIdsToChangesAndEmits, currentSeq));\n      if (results.length < CHANGES_BATCH_SIZE) {\n        return;\n      }\n      return processNextBatch();\n    }\n\n    function createDocIdsToChangesAndEmits(results) {\n      var docIdsToChangesAndEmits = new Map();\n      for (var i = 0, len = results.length; i < len; i++) {\n        var change = results[i];\n        if (change.doc._id[0] !== '_') {\n          mapResults = [];\n          doc = change.doc;\n\n          if (!doc._deleted) {\n            tryMap(view.sourceDB, mapFun, doc);\n          }\n          mapResults.sort(sortByKeyThenValue);\n\n          var indexableKeysToKeyValues = createIndexableKeysToKeyValues(mapResults);\n          docIdsToChangesAndEmits.set(change.doc._id, [\n            indexableKeysToKeyValues,\n            change.changes\n          ]);\n        }\n        currentSeq = change.seq;\n      }\n      return docIdsToChangesAndEmits;\n    }\n\n    function createIndexableKeysToKeyValues(mapResults) {\n      var indexableKeysToKeyValues = new Map();\n      var lastKey;\n      for (var i = 0, len = mapResults.length; i < len; i++) {\n        var emittedKeyValue = mapResults[i];\n        var complexKey = [emittedKeyValue.key, emittedKeyValue.id];\n        if (i > 0 && collate(emittedKeyValue.key, lastKey) === 0) {\n          complexKey.push(i); // dup key+id, so make it unique\n        }\n        indexableKeysToKeyValues.set(toIndexableString(complexKey), emittedKeyValue);\n        lastKey = emittedKeyValue.key;\n      }\n      return indexableKeysToKeyValues;\n    }\n\n    return processNextBatch().then(function () {\n      return queue.finish();\n    }).then(function () {\n      view.seq = currentSeq;\n    });\n  }\n\n  function reduceView(view, results, options) {\n    if (options.group_level === 0) {\n      delete options.group_level;\n    }\n\n    var shouldGroup = options.group || options.group_level;\n\n    var reduceFun = reducer(view.reduceFun);\n\n    var groups = [];\n    var lvl = isNaN(options.group_level) ? Number.POSITIVE_INFINITY :\n      options.group_level;\n    results.forEach(function (e) {\n      var last = groups[groups.length - 1];\n      var groupKey = shouldGroup ? e.key : null;\n\n      // only set group_level for array keys\n      if (shouldGroup && Array.isArray(groupKey)) {\n        groupKey = groupKey.slice(0, lvl);\n      }\n\n      if (last && collate(last.groupKey, groupKey) === 0) {\n        last.keys.push([e.key, e.id]);\n        last.values.push(e.value);\n        return;\n      }\n      groups.push({\n        keys: [[e.key, e.id]],\n        values: [e.value],\n        groupKey: groupKey\n      });\n    });\n    results = [];\n    for (var i = 0, len = groups.length; i < len; i++) {\n      var e = groups[i];\n      var reduceTry = tryReduce(view.sourceDB, reduceFun, e.keys, e.values, false);\n      if (reduceTry.error && reduceTry.error instanceof BuiltInError) {\n        // CouchDB returns an error if a built-in errors out\n        throw reduceTry.error;\n      }\n      results.push({\n        // CouchDB just sets the value to null if a non-built-in errors out\n        value: reduceTry.error ? null : reduceTry.output,\n        key: e.groupKey\n      });\n    }\n    // no total_rows/offset when reducing\n    return {rows: sliceResults(results, options.limit, options.skip)};\n  }\n\n  function queryView(view, opts) {\n    return sequentialize(getQueue(view), function () {\n      return queryViewInQueue(view, opts);\n    })();\n  }\n\n  function queryViewInQueue(view, opts) {\n    var totalRows;\n    var shouldReduce = view.reduceFun && opts.reduce !== false;\n    var skip = opts.skip || 0;\n    if (typeof opts.keys !== 'undefined' && !opts.keys.length) {\n      // equivalent query\n      opts.limit = 0;\n      delete opts.keys;\n    }\n\n    function fetchFromView(viewOpts) {\n      viewOpts.include_docs = true;\n      return view.db.allDocs(viewOpts).then(function (res) {\n        totalRows = res.total_rows;\n        return res.rows.map(function (result) {\n\n          // implicit migration - in older versions of PouchDB,\n          // we explicitly stored the doc as {id: ..., key: ..., value: ...}\n          // this is tested in a migration test\n          /* istanbul ignore next */\n          if ('value' in result.doc && typeof result.doc.value === 'object' &&\n            result.doc.value !== null) {\n            var keys = Object.keys(result.doc.value).sort();\n            // this detection method is not perfect, but it's unlikely the user\n            // emitted a value which was an object with these 3 exact keys\n            var expectedKeys = ['id', 'key', 'value'];\n            if (!(keys < expectedKeys || keys > expectedKeys)) {\n              return result.doc.value;\n            }\n          }\n\n          var parsedKeyAndDocId = parseIndexableString(result.doc._id);\n          return {\n            key: parsedKeyAndDocId[0],\n            id: parsedKeyAndDocId[1],\n            value: ('value' in result.doc ? result.doc.value : null)\n          };\n        });\n      });\n    }\n\n    function onMapResultsReady(rows) {\n      var finalResults;\n      if (shouldReduce) {\n        finalResults = reduceView(view, rows, opts);\n      } else {\n        finalResults = {\n          total_rows: totalRows,\n          offset: skip,\n          rows: rows\n        };\n      }\n      /* istanbul ignore if */\n      if (opts.update_seq) {\n        finalResults.update_seq = view.seq;\n      }\n      if (opts.include_docs) {\n        var docIds = uniq(rows.map(rowToDocId));\n\n        return view.sourceDB.allDocs({\n          keys: docIds,\n          include_docs: true,\n          conflicts: opts.conflicts,\n          attachments: opts.attachments,\n          binary: opts.binary\n        }).then(function (allDocsRes) {\n          var docIdsToDocs = new Map();\n          allDocsRes.rows.forEach(function (row) {\n            docIdsToDocs.set(row.id, row.doc);\n          });\n          rows.forEach(function (row) {\n            var docId = rowToDocId(row);\n            var doc = docIdsToDocs.get(docId);\n            if (doc) {\n              row.doc = doc;\n            }\n          });\n          return finalResults;\n        });\n      } else {\n        return finalResults;\n      }\n    }\n\n    if (typeof opts.keys !== 'undefined') {\n      var keys = opts.keys;\n      var fetchPromises = keys.map(function (key) {\n        var viewOpts = {\n          startkey : toIndexableString([key]),\n          endkey   : toIndexableString([key, {}])\n        };\n        /* istanbul ignore if */\n        if (opts.update_seq) {\n          viewOpts.update_seq = true;\n        }\n        return fetchFromView(viewOpts);\n      });\n      return Promise.all(fetchPromises).then(flatten).then(onMapResultsReady);\n    } else { // normal query, no 'keys'\n      var viewOpts = {\n        descending : opts.descending\n      };\n      /* istanbul ignore if */\n      if (opts.update_seq) {\n        viewOpts.update_seq = true;\n      }\n      var startkey;\n      var endkey;\n      if ('start_key' in opts) {\n        startkey = opts.start_key;\n      }\n      if ('startkey' in opts) {\n        startkey = opts.startkey;\n      }\n      if ('end_key' in opts) {\n        endkey = opts.end_key;\n      }\n      if ('endkey' in opts) {\n        endkey = opts.endkey;\n      }\n      if (typeof startkey !== 'undefined') {\n        viewOpts.startkey = opts.descending ?\n          toIndexableString([startkey, {}]) :\n          toIndexableString([startkey]);\n      }\n      if (typeof endkey !== 'undefined') {\n        var inclusiveEnd = opts.inclusive_end !== false;\n        if (opts.descending) {\n          inclusiveEnd = !inclusiveEnd;\n        }\n\n        viewOpts.endkey = toIndexableString(\n          inclusiveEnd ? [endkey, {}] : [endkey]);\n      }\n      if (typeof opts.key !== 'undefined') {\n        var keyStart = toIndexableString([opts.key]);\n        var keyEnd = toIndexableString([opts.key, {}]);\n        if (viewOpts.descending) {\n          viewOpts.endkey = keyStart;\n          viewOpts.startkey = keyEnd;\n        } else {\n          viewOpts.startkey = keyStart;\n          viewOpts.endkey = keyEnd;\n        }\n      }\n      if (!shouldReduce) {\n        if (typeof opts.limit === 'number') {\n          viewOpts.limit = opts.limit;\n        }\n        viewOpts.skip = skip;\n      }\n      return fetchFromView(viewOpts).then(onMapResultsReady);\n    }\n  }\n\n  function httpViewCleanup(db) {\n    return db.fetch('_view_cleanup', {\n      headers: new Headers({'Content-Type': 'application/json'}),\n      method: 'POST'\n    }).then(function (response) {\n      return response.json();\n    });\n  }\n\n  function localViewCleanup(db) {\n    return db.get('_local/' + localDocName).then(function (metaDoc) {\n      var docsToViews = new Map();\n      Object.keys(metaDoc.views).forEach(function (fullViewName) {\n        var parts = parseViewName(fullViewName);\n        var designDocName = '_design/' + parts[0];\n        var viewName = parts[1];\n        var views = docsToViews.get(designDocName);\n        if (!views) {\n          views = new Set();\n          docsToViews.set(designDocName, views);\n        }\n        views.add(viewName);\n      });\n      var opts = {\n        keys : mapToKeysArray(docsToViews),\n        include_docs : true\n      };\n      return db.allDocs(opts).then(function (res) {\n        var viewsToStatus = {};\n        res.rows.forEach(function (row) {\n          var ddocName = row.key.substring(8); // cuts off '_design/'\n          docsToViews.get(row.key).forEach(function (viewName) {\n            var fullViewName = ddocName + '/' + viewName;\n            /* istanbul ignore if */\n            if (!metaDoc.views[fullViewName]) {\n              // new format, without slashes, to support PouchDB 2.2.0\n              // migration test in pouchdb's browser.migration.js verifies this\n              fullViewName = viewName;\n            }\n            var viewDBNames = Object.keys(metaDoc.views[fullViewName]);\n            // design doc deleted, or view function nonexistent\n            var statusIsGood = row.doc && row.doc.views &&\n              row.doc.views[viewName];\n            viewDBNames.forEach(function (viewDBName) {\n              viewsToStatus[viewDBName] =\n                viewsToStatus[viewDBName] || statusIsGood;\n            });\n          });\n        });\n        var dbsToDelete = Object.keys(viewsToStatus).filter(\n          function (viewDBName) { return !viewsToStatus[viewDBName]; });\n        var destroyPromises = dbsToDelete.map(function (viewDBName) {\n          return sequentialize(getQueue(viewDBName), function () {\n            return new db.constructor(viewDBName, db.__opts).destroy();\n          })();\n        });\n        return Promise.all(destroyPromises).then(function () {\n          return {ok: true};\n        });\n      });\n    }, defaultsTo({ok: true}));\n  }\n\n  function queryPromised(db, fun, opts) {\n    /* istanbul ignore next */\n    if (typeof db._query === 'function') {\n      return customQuery(db, fun, opts);\n    }\n    if (isRemote(db)) {\n      return httpQuery(db, fun, opts);\n    }\n\n    if (typeof fun !== 'string') {\n      // temp_view\n      checkQueryParseError(opts, fun);\n\n      tempViewQueue.add(function () {\n        var createViewPromise = createView(\n          /* sourceDB */ db,\n          /* viewName */ 'temp_view/temp_view',\n          /* mapFun */ fun.map,\n          /* reduceFun */ fun.reduce,\n          /* temporary */ true,\n          /* localDocName */ localDocName);\n        return createViewPromise.then(function (view) {\n          return fin(updateView(view).then(function () {\n            return queryView(view, opts);\n          }), function () {\n            return view.db.destroy();\n          });\n        });\n      });\n      return tempViewQueue.finish();\n    } else {\n      // persistent view\n      var fullViewName = fun;\n      var parts = parseViewName(fullViewName);\n      var designDocName = parts[0];\n      var viewName = parts[1];\n      return db.get('_design/' + designDocName).then(function (doc) {\n        var fun = doc.views && doc.views[viewName];\n\n        if (!fun) {\n          // basic validator; it's assumed that every subclass would want this\n          throw new NotFoundError('ddoc ' + doc._id + ' has no view named ' +\n            viewName);\n        }\n\n        ddocValidator(doc, viewName);\n        checkQueryParseError(opts, fun);\n\n        var createViewPromise = createView(\n          /* sourceDB */ db,\n          /* viewName */ fullViewName,\n          /* mapFun */ fun.map,\n          /* reduceFun */ fun.reduce,\n          /* temporary */ false,\n          /* localDocName */ localDocName);\n        return createViewPromise.then(function (view) {\n          if (opts.stale === 'ok' || opts.stale === 'update_after') {\n            if (opts.stale === 'update_after') {\n              nextTick(function () {\n                updateView(view);\n              });\n            }\n            return queryView(view, opts);\n          } else { // stale not ok\n            return updateView(view).then(function () {\n              return queryView(view, opts);\n            });\n          }\n        });\n      });\n    }\n  }\n\n  function abstractQuery(fun, opts, callback) {\n    var db = this;\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = opts ? coerceOptions(opts) : {};\n\n    if (typeof fun === 'function') {\n      fun = {map : fun};\n    }\n\n    var promise = Promise.resolve().then(function () {\n      return queryPromised(db, fun, opts);\n    });\n    promisedCallback(promise, callback);\n    return promise;\n  }\n\n  var abstractViewCleanup = callbackify(function () {\n    var db = this;\n    /* istanbul ignore next */\n    if (typeof db._viewCleanup === 'function') {\n      return customViewCleanup(db);\n    }\n    if (isRemote(db)) {\n      return httpViewCleanup(db);\n    }\n    return localViewCleanup(db);\n  });\n\n  return {\n    query: abstractQuery,\n    viewCleanup: abstractViewCleanup\n  };\n}\n\nexport default createAbstractMapReduce;\n"]},"metadata":{},"sourceType":"module"}
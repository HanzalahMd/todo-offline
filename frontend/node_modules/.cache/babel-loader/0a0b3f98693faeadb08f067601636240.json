{"ast":null,"code":"import _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inheritsLoose from \"@babel/runtime/helpers/inheritsLoose\";\n/**\n * This plugin adds RxCollection.inMemory()\n * Which replicates the collection into an in-memory-collection\n * So you can do faster queries and also query over encrypted fields.\n * Writes will still run on the original collection\n */\n\nimport { Subject, fromEvent as ObservableFromEvent } from 'rxjs';\nimport { filter, map, mergeMap, first } from 'rxjs/operators';\nimport { RxCollectionBase } from '../rx-collection';\nimport { clone, randomCouchString, adapterObject } from '../util';\nimport Core from '../core';\nimport Crypter from '../crypter';\nimport { createChangeEventBuffer } from '../change-event-buffer';\nimport { createRxSchema } from '../rx-schema';\nimport { PouchDB } from '../pouch-db';\nimport { newRxError } from '../rx-error'; // add the watch-for-changes-plugin\n\nimport RxDBWatchForChangesPlugin from '../plugins/watch-for-changes';\nCore.plugin(RxDBWatchForChangesPlugin);\nvar collectionCacheMap = new WeakMap();\nvar collectionPromiseCacheMap = new WeakMap();\nvar BULK_DOC_OPTIONS = {\n  new_edits: true\n};\nvar BULK_DOC_OPTIONS_FALSE = {\n  new_edits: false\n};\nexport var InMemoryRxCollection =\n/*#__PURE__*/\nfunction (_RxCollectionBase) {\n  _inheritsLoose(InMemoryRxCollection, _RxCollectionBase);\n\n  function InMemoryRxCollection(parentCollection) {\n    var _this;\n\n    var pouchSettings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _this = _RxCollectionBase.call(this, parentCollection.database, parentCollection.name, toCleanSchema(parentCollection.schema), pouchSettings, // pouchSettings\n    {}, parentCollection._methods) || this;\n    _this._eventCounter = 0;\n    _this._isInMemory = true;\n    _this._parentCollection = parentCollection;\n\n    _this._parentCollection.onDestroy.then(function () {\n      return _this.destroy();\n    });\n\n    _this._crypter = Crypter.create(_this.database.password, _this.schema);\n    _this._changeStreams = [];\n    /**\n     * runs on parentCollection.destroy()\n     * Cleans up everything to free up memory\n     */\n\n    _this.onDestroy.then(function () {\n      _this._changeStreams.forEach(function (stream) {\n        return stream.cancel();\n      });\n\n      _this.pouch.destroy();\n    }); // add orm functions and options from parent\n\n\n    _this.options = parentCollection.options;\n    Object.entries(parentCollection.statics).forEach(function (_ref) {\n      var funName = _ref[0],\n          fun = _ref[1];\n      Object.defineProperty(_assertThisInitialized(_this), funName, {\n        get: function get() {\n          return fun.bind(_assertThisInitialized(_this));\n        }\n      });\n    });\n    _this.pouch = new PouchDB('rxdb-in-memory-' + randomCouchString(10), adapterObject('memory'));\n    _this._observable$ = new Subject();\n    _this._changeEventBuffer = createChangeEventBuffer(_assertThisInitialized(_this));\n    var parentProto = Object.getPrototypeOf(parentCollection);\n    _this._oldPouchPut = parentProto._pouchPut.bind(_assertThisInitialized(_this));\n    _this._nonPersistentRevisions = new Set();\n    _this._nonPersistentRevisionsSubject = new Subject(); // emits Set.size() when Set is changed\n\n    return _this;\n  }\n\n  var _proto = InMemoryRxCollection.prototype;\n\n  _proto.prepareChild = function prepareChild() {\n    var _this2 = this;\n\n    return setIndexes(this.schema, this.pouch).then(function () {\n      _this2._subs.push(_this2._observable$.subscribe(function (cE) {\n        // when data changes, send it to RxDocument in docCache\n        var doc = _this2._docCache.get(cE.data.doc);\n\n        if (doc) doc._handleChangeEvent(cE);\n      }));\n    }) // initial sync parent's docs to own\n    .then(function () {\n      return replicateExistingDocuments(_this2._parentCollection, _this2);\n    }).then(function () {\n      /**\n       * call watchForChanges() on both sides,\n       * to ensure none-rxdb-changes like replication\n       * will fire into the change-event-stream\n       */\n      _this2._parentCollection.watchForChanges();\n\n      _this2.watchForChanges();\n      /**\n       * create an ongoing replications between both sides\n       */\n\n\n      var thisToParentSub = streamChangedDocuments(_this2).pipe(mergeMap(function (doc) {\n        return applyChangedDocumentToPouch(_this2._parentCollection, doc).then(function () {\n          return doc['_rev'];\n        });\n      })).subscribe(function (changeRev) {\n        _this2._nonPersistentRevisions[\"delete\"](changeRev);\n\n        _this2._nonPersistentRevisionsSubject.next(_this2._nonPersistentRevisions.size);\n      });\n\n      _this2._subs.push(thisToParentSub);\n\n      var parentToThisSub = streamChangedDocuments(_this2._parentCollection).subscribe(function (doc) {\n        return applyChangedDocumentToPouch(_this2, doc);\n      });\n\n      _this2._subs.push(parentToThisSub);\n    });\n  }\n  /**\n   * waits until all writes are persistent\n   * in the parent collection\n   */\n  ;\n\n  _proto.awaitPersistence = function awaitPersistence() {\n    var _this3 = this;\n\n    if (this._nonPersistentRevisions.size === 0) return Promise.resolve();\n    return this._nonPersistentRevisionsSubject.pipe(filter(function () {\n      return _this3._nonPersistentRevisions.size === 0;\n    }), first()).toPromise();\n  }\n  /**\n   * To know which events are replicated and which are not,\n   * the _pouchPut is wrapped\n   * @overwrite\n   */\n  ;\n\n  _proto._pouchPut = function _pouchPut(obj, overwrite) {\n    var _this4 = this;\n\n    return this._oldPouchPut(obj, overwrite).then(function (ret) {\n      _this4._nonPersistentRevisions.add(ret.rev);\n\n      return ret;\n    });\n  };\n\n  _proto.$emit = function $emit(changeEvent) {\n    if (this._changeEventBuffer.hasChangeWithRevision(changeEvent.data.v && changeEvent.data.v._rev)) return;\n\n    this._observable$.next(changeEvent); // run compaction each 10 events\n\n\n    this._eventCounter++;\n\n    if (this._eventCounter === 10) {\n      this._eventCounter = 0;\n      this.pouch.compact();\n    }\n  }\n  /**\n   * @overwrite\n   * Replication on the inMemory is dangerous,\n   * replicate with it's parent instead\n   */\n  ;\n\n  _proto.sync = function sync() {\n    throw newRxError('IM2');\n  };\n\n  return InMemoryRxCollection;\n}(RxCollectionBase);\n/**\n * returns a version of the schema that:\n * - disabled the keyCompression\n * - has no encryption\n * - has no attachments\n */\n\nfunction toCleanSchema(rxSchema) {\n  var newSchemaJson = clone(rxSchema.jsonID);\n  newSchemaJson.keyCompression = false;\n  delete newSchemaJson.properties._id;\n  delete newSchemaJson.properties._rev;\n  delete newSchemaJson.properties._attachments;\n\n  var removeEncryption = function removeEncryption(schema, complete) {\n    delete schema.encrypted;\n    Object.values(schema).filter(function (val) {\n      return typeof val === 'object';\n    }).forEach(function (val) {\n      return removeEncryption(val, complete);\n    });\n  };\n\n  removeEncryption(newSchemaJson, newSchemaJson);\n  return createRxSchema(newSchemaJson);\n}\n/**\n * replicates all documents from the parent to the inMemoryCollection\n * @return Promise that resolves with an array of the docs data\n */\n\n\nexport function replicateExistingDocuments(fromCollection, toCollection) {\n  return fromCollection.pouch.allDocs({\n    attachments: false,\n    include_docs: true\n  }).then(function (allRows) {\n    var docs = allRows.rows.map(function (row) {\n      return row.doc;\n    }).filter(function (doc) {\n      return !doc.language;\n    }) // do not replicate design-docs\n    .map(function (doc) {\n      return fromCollection._handleFromPouch(doc);\n    }) // swap back primary because keyCompression:false\n    .map(function (doc) {\n      return fromCollection.schema.swapPrimaryToId(doc);\n    });\n    if (docs.length === 0) return Promise.resolve([]); // nothing to replicate\n    else {\n        return toCollection.pouch.bulkDocs({\n          docs: docs\n        }, BULK_DOC_OPTIONS_FALSE).then(function () {\n          return docs;\n        });\n      }\n  });\n}\n/**\n * sets the indexes from the schema at the pouchdb\n */\n\nexport function setIndexes(schema, pouch) {\n  return Promise.all(schema.indexes.map(function (indexAr) {\n    return pouch.createIndex({\n      index: {\n        fields: indexAr\n      }\n    });\n  }));\n}\n/**\n * returns an observable that streams all changes\n * as plain documents that have no encryption or keyCompression.\n * We use this to replicate changes from one collection to the other\n * @param prevFilter can be used to filter changes before doing anything\n * @return observable that emits document-data\n */\n\nexport function streamChangedDocuments(rxCollection) {\n  var prevFilter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (i) {\n    return true;\n  };\n  if (!rxCollection._doNotEmitSet) rxCollection._doNotEmitSet = new Set();\n  var observable = ObservableFromEvent(rxCollection.pouch.changes({\n    since: 'now',\n    live: true,\n    include_docs: true\n  }), 'change').pipe(map(function (changeAr) {\n    return changeAr[0];\n  }), // rxjs emits an array for whatever reason\n  filter(function (change) {\n    // changes on the doNotEmit-list shell not be fired\n    var emitFlag = change.id + ':' + change.doc._rev;\n    if (rxCollection._doNotEmitSet.has(emitFlag)) return false;else return true;\n  }), filter(function (change) {\n    return prevFilter(change);\n  }), map(function (change) {\n    return rxCollection._handleFromPouch(change.doc);\n  }));\n  return observable;\n}\n/**\n * writes the doc-data into the pouchdb of the collection\n * without changeing the revision\n */\n\nexport function applyChangedDocumentToPouch(rxCollection, docData) {\n  if (!rxCollection._doNotEmitSet) rxCollection._doNotEmitSet = new Set();\n\n  var transformedDoc = rxCollection._handleToPouch(docData);\n\n  return rxCollection.pouch.get(transformedDoc._id).then(function (oldDoc) {\n    return transformedDoc._rev = oldDoc._rev;\n  })[\"catch\"](function () {\n    // doc not found, do not use a revision\n    delete transformedDoc._rev;\n  }).then(function () {\n    return rxCollection.pouch.bulkDocs({\n      docs: [transformedDoc]\n    }, BULK_DOC_OPTIONS);\n  }).then(function (bulkRet) {\n    if (bulkRet.length > 0 && !bulkRet[0].ok) {\n      throw new Error(JSON.stringify(bulkRet[0]));\n    } // set the flag so this does not appear in the own event-stream again\n\n\n    var emitFlag = transformedDoc._id + ':' + bulkRet[0].rev;\n\n    rxCollection._doNotEmitSet.add(emitFlag); // remove from the list later to not have a memory-leak\n\n\n    setTimeout(function () {\n      return rxCollection._doNotEmitSet[\"delete\"](emitFlag);\n    }, 30 * 1000);\n    return transformedDoc;\n  });\n}\nvar INIT_DONE = false;\n/**\n * called in the proto of RxCollection\n */\n\nexport function spawnInMemory() {\n  var _this5 = this;\n\n  if (!INIT_DONE) {\n    INIT_DONE = true; // ensure memory-adapter is added\n\n    if (!PouchDB.adapters || !PouchDB.adapters.memory) throw newRxError('IM1');\n  }\n\n  if (collectionCacheMap.has(this)) {\n    // already exists for this collection -> wait until synced\n    return collectionPromiseCacheMap.get(this).then(function () {\n      return collectionCacheMap.get(_this5);\n    });\n  }\n\n  var col = new InMemoryRxCollection(this);\n  var preparePromise = col.prepareChild();\n  collectionCacheMap.set(this, col);\n  collectionPromiseCacheMap.set(this, preparePromise);\n  return preparePromise.then(function () {\n    return col;\n  });\n}\nexport var rxdb = true;\nexport var prototypes = {\n  RxCollection: function RxCollection(proto) {\n    proto.inMemory = spawnInMemory;\n  }\n};\nexport var overwritable = {};\nexport default {\n  rxdb: rxdb,\n  prototypes: prototypes,\n  overwritable: overwritable,\n  spawnInMemory: spawnInMemory\n};","map":{"version":3,"sources":["/Users/Hanzalah/Desktop/github/todo-offline/rxdb-hasura-demo/node_modules/rxdb/dist/es/plugins/in-memory.js"],"names":["_assertThisInitialized","_inheritsLoose","Subject","fromEvent","ObservableFromEvent","filter","map","mergeMap","first","RxCollectionBase","clone","randomCouchString","adapterObject","Core","Crypter","createChangeEventBuffer","createRxSchema","PouchDB","newRxError","RxDBWatchForChangesPlugin","plugin","collectionCacheMap","WeakMap","collectionPromiseCacheMap","BULK_DOC_OPTIONS","new_edits","BULK_DOC_OPTIONS_FALSE","InMemoryRxCollection","_RxCollectionBase","parentCollection","_this","pouchSettings","arguments","length","undefined","call","database","name","toCleanSchema","schema","_methods","_eventCounter","_isInMemory","_parentCollection","onDestroy","then","destroy","_crypter","create","password","_changeStreams","forEach","stream","cancel","pouch","options","Object","entries","statics","_ref","funName","fun","defineProperty","get","bind","_observable$","_changeEventBuffer","parentProto","getPrototypeOf","_oldPouchPut","_pouchPut","_nonPersistentRevisions","Set","_nonPersistentRevisionsSubject","_proto","prototype","prepareChild","_this2","setIndexes","_subs","push","subscribe","cE","doc","_docCache","data","_handleChangeEvent","replicateExistingDocuments","watchForChanges","thisToParentSub","streamChangedDocuments","pipe","applyChangedDocumentToPouch","changeRev","next","size","parentToThisSub","awaitPersistence","_this3","Promise","resolve","toPromise","obj","overwrite","_this4","ret","add","rev","$emit","changeEvent","hasChangeWithRevision","v","_rev","compact","sync","rxSchema","newSchemaJson","jsonID","keyCompression","properties","_id","_attachments","removeEncryption","complete","encrypted","values","val","fromCollection","toCollection","allDocs","attachments","include_docs","allRows","docs","rows","row","language","_handleFromPouch","swapPrimaryToId","bulkDocs","all","indexes","indexAr","createIndex","index","fields","rxCollection","prevFilter","i","_doNotEmitSet","observable","changes","since","live","changeAr","change","emitFlag","id","has","docData","transformedDoc","_handleToPouch","oldDoc","bulkRet","ok","Error","JSON","stringify","setTimeout","INIT_DONE","spawnInMemory","_this5","adapters","memory","col","preparePromise","set","rxdb","prototypes","RxCollection","proto","inMemory","overwritable"],"mappings":"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","sourcesContent":["import _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inheritsLoose from \"@babel/runtime/helpers/inheritsLoose\";\n\n/**\n * This plugin adds RxCollection.inMemory()\n * Which replicates the collection into an in-memory-collection\n * So you can do faster queries and also query over encrypted fields.\n * Writes will still run on the original collection\n */\nimport { Subject, fromEvent as ObservableFromEvent } from 'rxjs';\nimport { filter, map, mergeMap, first } from 'rxjs/operators';\nimport { RxCollectionBase } from '../rx-collection';\nimport { clone, randomCouchString, adapterObject } from '../util';\nimport Core from '../core';\nimport Crypter from '../crypter';\nimport { createChangeEventBuffer } from '../change-event-buffer';\nimport { createRxSchema } from '../rx-schema';\nimport { PouchDB } from '../pouch-db';\nimport { newRxError } from '../rx-error'; // add the watch-for-changes-plugin\n\nimport RxDBWatchForChangesPlugin from '../plugins/watch-for-changes';\nCore.plugin(RxDBWatchForChangesPlugin);\nvar collectionCacheMap = new WeakMap();\nvar collectionPromiseCacheMap = new WeakMap();\nvar BULK_DOC_OPTIONS = {\n  new_edits: true\n};\nvar BULK_DOC_OPTIONS_FALSE = {\n  new_edits: false\n};\nexport var InMemoryRxCollection = /*#__PURE__*/function (_RxCollectionBase) {\n  _inheritsLoose(InMemoryRxCollection, _RxCollectionBase);\n\n  function InMemoryRxCollection(parentCollection) {\n    var _this;\n\n    var pouchSettings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _this = _RxCollectionBase.call(this, parentCollection.database, parentCollection.name, toCleanSchema(parentCollection.schema), pouchSettings, // pouchSettings\n    {}, parentCollection._methods) || this;\n    _this._eventCounter = 0;\n    _this._isInMemory = true;\n    _this._parentCollection = parentCollection;\n\n    _this._parentCollection.onDestroy.then(function () {\n      return _this.destroy();\n    });\n\n    _this._crypter = Crypter.create(_this.database.password, _this.schema);\n    _this._changeStreams = [];\n    /**\n     * runs on parentCollection.destroy()\n     * Cleans up everything to free up memory\n     */\n\n    _this.onDestroy.then(function () {\n      _this._changeStreams.forEach(function (stream) {\n        return stream.cancel();\n      });\n\n      _this.pouch.destroy();\n    }); // add orm functions and options from parent\n\n\n    _this.options = parentCollection.options;\n    Object.entries(parentCollection.statics).forEach(function (_ref) {\n      var funName = _ref[0],\n          fun = _ref[1];\n      Object.defineProperty(_assertThisInitialized(_this), funName, {\n        get: function get() {\n          return fun.bind(_assertThisInitialized(_this));\n        }\n      });\n    });\n    _this.pouch = new PouchDB('rxdb-in-memory-' + randomCouchString(10), adapterObject('memory'));\n    _this._observable$ = new Subject();\n    _this._changeEventBuffer = createChangeEventBuffer(_assertThisInitialized(_this));\n    var parentProto = Object.getPrototypeOf(parentCollection);\n    _this._oldPouchPut = parentProto._pouchPut.bind(_assertThisInitialized(_this));\n    _this._nonPersistentRevisions = new Set();\n    _this._nonPersistentRevisionsSubject = new Subject(); // emits Set.size() when Set is changed\n\n    return _this;\n  }\n\n  var _proto = InMemoryRxCollection.prototype;\n\n  _proto.prepareChild = function prepareChild() {\n    var _this2 = this;\n\n    return setIndexes(this.schema, this.pouch).then(function () {\n      _this2._subs.push(_this2._observable$.subscribe(function (cE) {\n        // when data changes, send it to RxDocument in docCache\n        var doc = _this2._docCache.get(cE.data.doc);\n\n        if (doc) doc._handleChangeEvent(cE);\n      }));\n    }) // initial sync parent's docs to own\n    .then(function () {\n      return replicateExistingDocuments(_this2._parentCollection, _this2);\n    }).then(function () {\n      /**\n       * call watchForChanges() on both sides,\n       * to ensure none-rxdb-changes like replication\n       * will fire into the change-event-stream\n       */\n      _this2._parentCollection.watchForChanges();\n\n      _this2.watchForChanges();\n      /**\n       * create an ongoing replications between both sides\n       */\n\n\n      var thisToParentSub = streamChangedDocuments(_this2).pipe(mergeMap(function (doc) {\n        return applyChangedDocumentToPouch(_this2._parentCollection, doc).then(function () {\n          return doc['_rev'];\n        });\n      })).subscribe(function (changeRev) {\n        _this2._nonPersistentRevisions[\"delete\"](changeRev);\n\n        _this2._nonPersistentRevisionsSubject.next(_this2._nonPersistentRevisions.size);\n      });\n\n      _this2._subs.push(thisToParentSub);\n\n      var parentToThisSub = streamChangedDocuments(_this2._parentCollection).subscribe(function (doc) {\n        return applyChangedDocumentToPouch(_this2, doc);\n      });\n\n      _this2._subs.push(parentToThisSub);\n    });\n  }\n  /**\n   * waits until all writes are persistent\n   * in the parent collection\n   */\n  ;\n\n  _proto.awaitPersistence = function awaitPersistence() {\n    var _this3 = this;\n\n    if (this._nonPersistentRevisions.size === 0) return Promise.resolve();\n    return this._nonPersistentRevisionsSubject.pipe(filter(function () {\n      return _this3._nonPersistentRevisions.size === 0;\n    }), first()).toPromise();\n  }\n  /**\n   * To know which events are replicated and which are not,\n   * the _pouchPut is wrapped\n   * @overwrite\n   */\n  ;\n\n  _proto._pouchPut = function _pouchPut(obj, overwrite) {\n    var _this4 = this;\n\n    return this._oldPouchPut(obj, overwrite).then(function (ret) {\n      _this4._nonPersistentRevisions.add(ret.rev);\n\n      return ret;\n    });\n  };\n\n  _proto.$emit = function $emit(changeEvent) {\n    if (this._changeEventBuffer.hasChangeWithRevision(changeEvent.data.v && changeEvent.data.v._rev)) return;\n\n    this._observable$.next(changeEvent); // run compaction each 10 events\n\n\n    this._eventCounter++;\n\n    if (this._eventCounter === 10) {\n      this._eventCounter = 0;\n      this.pouch.compact();\n    }\n  }\n  /**\n   * @overwrite\n   * Replication on the inMemory is dangerous,\n   * replicate with it's parent instead\n   */\n  ;\n\n  _proto.sync = function sync() {\n    throw newRxError('IM2');\n  };\n\n  return InMemoryRxCollection;\n}(RxCollectionBase);\n/**\n * returns a version of the schema that:\n * - disabled the keyCompression\n * - has no encryption\n * - has no attachments\n */\n\nfunction toCleanSchema(rxSchema) {\n  var newSchemaJson = clone(rxSchema.jsonID);\n  newSchemaJson.keyCompression = false;\n  delete newSchemaJson.properties._id;\n  delete newSchemaJson.properties._rev;\n  delete newSchemaJson.properties._attachments;\n\n  var removeEncryption = function removeEncryption(schema, complete) {\n    delete schema.encrypted;\n    Object.values(schema).filter(function (val) {\n      return typeof val === 'object';\n    }).forEach(function (val) {\n      return removeEncryption(val, complete);\n    });\n  };\n\n  removeEncryption(newSchemaJson, newSchemaJson);\n  return createRxSchema(newSchemaJson);\n}\n/**\n * replicates all documents from the parent to the inMemoryCollection\n * @return Promise that resolves with an array of the docs data\n */\n\n\nexport function replicateExistingDocuments(fromCollection, toCollection) {\n  return fromCollection.pouch.allDocs({\n    attachments: false,\n    include_docs: true\n  }).then(function (allRows) {\n    var docs = allRows.rows.map(function (row) {\n      return row.doc;\n    }).filter(function (doc) {\n      return !doc.language;\n    }) // do not replicate design-docs\n    .map(function (doc) {\n      return fromCollection._handleFromPouch(doc);\n    }) // swap back primary because keyCompression:false\n    .map(function (doc) {\n      return fromCollection.schema.swapPrimaryToId(doc);\n    });\n    if (docs.length === 0) return Promise.resolve([]); // nothing to replicate\n    else {\n        return toCollection.pouch.bulkDocs({\n          docs: docs\n        }, BULK_DOC_OPTIONS_FALSE).then(function () {\n          return docs;\n        });\n      }\n  });\n}\n/**\n * sets the indexes from the schema at the pouchdb\n */\n\nexport function setIndexes(schema, pouch) {\n  return Promise.all(schema.indexes.map(function (indexAr) {\n    return pouch.createIndex({\n      index: {\n        fields: indexAr\n      }\n    });\n  }));\n}\n/**\n * returns an observable that streams all changes\n * as plain documents that have no encryption or keyCompression.\n * We use this to replicate changes from one collection to the other\n * @param prevFilter can be used to filter changes before doing anything\n * @return observable that emits document-data\n */\n\nexport function streamChangedDocuments(rxCollection) {\n  var prevFilter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (i) {\n    return true;\n  };\n  if (!rxCollection._doNotEmitSet) rxCollection._doNotEmitSet = new Set();\n  var observable = ObservableFromEvent(rxCollection.pouch.changes({\n    since: 'now',\n    live: true,\n    include_docs: true\n  }), 'change').pipe(map(function (changeAr) {\n    return changeAr[0];\n  }), // rxjs emits an array for whatever reason\n  filter(function (change) {\n    // changes on the doNotEmit-list shell not be fired\n    var emitFlag = change.id + ':' + change.doc._rev;\n    if (rxCollection._doNotEmitSet.has(emitFlag)) return false;else return true;\n  }), filter(function (change) {\n    return prevFilter(change);\n  }), map(function (change) {\n    return rxCollection._handleFromPouch(change.doc);\n  }));\n  return observable;\n}\n/**\n * writes the doc-data into the pouchdb of the collection\n * without changeing the revision\n */\n\nexport function applyChangedDocumentToPouch(rxCollection, docData) {\n  if (!rxCollection._doNotEmitSet) rxCollection._doNotEmitSet = new Set();\n\n  var transformedDoc = rxCollection._handleToPouch(docData);\n\n  return rxCollection.pouch.get(transformedDoc._id).then(function (oldDoc) {\n    return transformedDoc._rev = oldDoc._rev;\n  })[\"catch\"](function () {\n    // doc not found, do not use a revision\n    delete transformedDoc._rev;\n  }).then(function () {\n    return rxCollection.pouch.bulkDocs({\n      docs: [transformedDoc]\n    }, BULK_DOC_OPTIONS);\n  }).then(function (bulkRet) {\n    if (bulkRet.length > 0 && !bulkRet[0].ok) {\n      throw new Error(JSON.stringify(bulkRet[0]));\n    } // set the flag so this does not appear in the own event-stream again\n\n\n    var emitFlag = transformedDoc._id + ':' + bulkRet[0].rev;\n\n    rxCollection._doNotEmitSet.add(emitFlag); // remove from the list later to not have a memory-leak\n\n\n    setTimeout(function () {\n      return rxCollection._doNotEmitSet[\"delete\"](emitFlag);\n    }, 30 * 1000);\n    return transformedDoc;\n  });\n}\nvar INIT_DONE = false;\n/**\n * called in the proto of RxCollection\n */\n\nexport function spawnInMemory() {\n  var _this5 = this;\n\n  if (!INIT_DONE) {\n    INIT_DONE = true; // ensure memory-adapter is added\n\n    if (!PouchDB.adapters || !PouchDB.adapters.memory) throw newRxError('IM1');\n  }\n\n  if (collectionCacheMap.has(this)) {\n    // already exists for this collection -> wait until synced\n    return collectionPromiseCacheMap.get(this).then(function () {\n      return collectionCacheMap.get(_this5);\n    });\n  }\n\n  var col = new InMemoryRxCollection(this);\n  var preparePromise = col.prepareChild();\n  collectionCacheMap.set(this, col);\n  collectionPromiseCacheMap.set(this, preparePromise);\n  return preparePromise.then(function () {\n    return col;\n  });\n}\nexport var rxdb = true;\nexport var prototypes = {\n  RxCollection: function RxCollection(proto) {\n    proto.inMemory = spawnInMemory;\n  }\n};\nexport var overwritable = {};\nexport default {\n  rxdb: rxdb,\n  prototypes: prototypes,\n  overwritable: overwritable,\n  spawnInMemory: spawnInMemory\n};\n//# sourceMappingURL=in-memory.js.map"]},"metadata":{},"sourceType":"module"}
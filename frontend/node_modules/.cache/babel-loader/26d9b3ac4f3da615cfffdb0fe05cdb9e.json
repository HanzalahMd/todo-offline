{"ast":null,"code":"function _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      return function () {\n        if (i >= o.length) return {\n          done: true\n        };\n        return {\n          done: false,\n          value: o[i++]\n        };\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  it = o[Symbol.iterator]();\n  return it.next.bind(it);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n/**\n * the query-cache makes sure that on every query-state, exactly one instance can exist\n * if you use the same mango-query more then once, it will reuse the first RxQuery\n */\n\n\nimport { now } from './util';\nexport var QueryCache =\n/*#__PURE__*/\nfunction () {\n  function QueryCache() {\n    this._map = new Map();\n  }\n\n  var _proto = QueryCache.prototype;\n  /**\n   * check if an equal query is in the cache,\n   * if true, return the cached one,\n   * if false, save the given one and return it\n   */\n\n  _proto.getByQuery = function getByQuery(rxQuery) {\n    var stringRep = rxQuery.toString();\n\n    if (!this._map.has(stringRep)) {\n      this._map.set(stringRep, rxQuery);\n    }\n\n    return this._map.get(stringRep);\n  };\n\n  return QueryCache;\n}();\nexport function createQueryCache() {\n  return new QueryCache();\n}\nexport function uncacheRxQuery(queryCache, rxQuery) {\n  rxQuery.uncached = true;\n  var stringRep = rxQuery.toString();\n\n  queryCache._map[\"delete\"](stringRep);\n}\nexport function countRxQuerySubscribers(rxQuery) {\n  return rxQuery.refCount$.observers.length;\n}\nexport var DEFAULT_TRY_TO_KEEP_MAX = 100;\nexport var DEFAULT_UNEXECUTED_LIFETME = 30 * 1000;\nexport var DEFAULT_CACHE_REPLACEMENT_WAIT_TIME = 20 * 1000;\n/**\n * The default cache replacement policy\n * See docs-src/query-cache.md to learn how it should work.\n * Notice that this runs often and should block the cpu as less as possible\n * This is a monad which makes it easier to unit test\n */\n\nexport var defaultCacheReplacementPolicyMonad = function defaultCacheReplacementPolicyMonad(tryToKeepMax, unExecutedLifetime) {\n  return function (_collection, queryCache) {\n    if (queryCache._map.size < tryToKeepMax) {\n      return;\n    }\n\n    var minUnExecutedLifetime = now() - unExecutedLifetime;\n    var maybeUncash = [];\n\n    for (var _iterator = _createForOfIteratorHelperLoose(queryCache._map.values()), _step; !(_step = _iterator()).done;) {\n      var rxQuery = _step.value; // filter out queries with subscribers\n\n      if (countRxQuerySubscribers(rxQuery) > 0) {\n        continue;\n      } // directly uncache queries that never executed and are older then unExecutedLifetime\n\n\n      if (rxQuery._lastEnsureEqual === 0 && rxQuery._creationTime < minUnExecutedLifetime) {\n        uncacheRxQuery(queryCache, rxQuery);\n        continue;\n      }\n\n      maybeUncash.push(rxQuery);\n    }\n\n    var mustUncache = maybeUncash.length - tryToKeepMax;\n\n    if (mustUncache <= 0) {\n      return;\n    }\n\n    var sortedByLastUsage = maybeUncash.sort(function (a, b) {\n      return a._lastEnsureEqual - b._lastEnsureEqual;\n    });\n    var toRemove = sortedByLastUsage.slice(0, mustUncache);\n    toRemove.forEach(function (rxQuery) {\n      return uncacheRxQuery(queryCache, rxQuery);\n    });\n  };\n};\nexport var defaultCacheReplacementPolicy = defaultCacheReplacementPolicyMonad(DEFAULT_TRY_TO_KEEP_MAX, DEFAULT_UNEXECUTED_LIFETME); // @link https://stackoverflow.com/a/56239226/3443137\n\nexport var CACHE_REPLACEMENT_STATE_BY_COLLECTION = new WeakMap();\nexport var COLLECTIONS_WITH_DESTROY_HOOK = new WeakSet();\n/**\n * Triggers the cache replacement policy after waitTime has passed.\n * We do not run this directly because at exactly the time a query is created,\n * we need all CPU to minimize latency.\n * Also this should not be triggered multiple times when waitTime is still waiting.\n */\n\nexport function triggerCacheReplacement(rxCollection) {\n  var waitTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_CACHE_REPLACEMENT_WAIT_TIME;\n\n  if (CACHE_REPLACEMENT_STATE_BY_COLLECTION.has(rxCollection)) {\n    // already started\n    return;\n  } // ensure we clean up the runnung timeouts when the collection is destroyed\n\n\n  if (!COLLECTIONS_WITH_DESTROY_HOOK.has(rxCollection)) {\n    rxCollection.onDestroy.then(function () {\n      var timeout = CACHE_REPLACEMENT_STATE_BY_COLLECTION.get(rxCollection);\n\n      if (timeout) {\n        clearTimeout(timeout);\n      }\n    });\n    COLLECTIONS_WITH_DESTROY_HOOK.add(rxCollection);\n  }\n\n  var val = setTimeout(function () {\n    CACHE_REPLACEMENT_STATE_BY_COLLECTION[\"delete\"](rxCollection);\n    rxCollection.cacheReplacementPolicy(rxCollection, rxCollection._queryCache);\n  }, waitTime);\n  CACHE_REPLACEMENT_STATE_BY_COLLECTION.set(rxCollection, val);\n}","map":{"version":3,"sources":["/Users/Hanzalah/Desktop/github/todo-offline/rxdb-hasura-demo/node_modules/rxdb/dist/es/query-cache.js"],"names":["_createForOfIteratorHelperLoose","o","allowArrayLike","it","Symbol","iterator","Array","isArray","_unsupportedIterableToArray","length","i","done","value","TypeError","next","bind","minLen","_arrayLikeToArray","n","Object","prototype","toString","call","slice","constructor","name","from","test","arr","len","arr2","now","QueryCache","_map","Map","_proto","getByQuery","rxQuery","stringRep","has","set","get","createQueryCache","uncacheRxQuery","queryCache","uncached","countRxQuerySubscribers","refCount$","observers","DEFAULT_TRY_TO_KEEP_MAX","DEFAULT_UNEXECUTED_LIFETME","DEFAULT_CACHE_REPLACEMENT_WAIT_TIME","defaultCacheReplacementPolicyMonad","tryToKeepMax","unExecutedLifetime","_collection","size","minUnExecutedLifetime","maybeUncash","_iterator","values","_step","_lastEnsureEqual","_creationTime","push","mustUncache","sortedByLastUsage","sort","a","b","toRemove","forEach","defaultCacheReplacementPolicy","CACHE_REPLACEMENT_STATE_BY_COLLECTION","WeakMap","COLLECTIONS_WITH_DESTROY_HOOK","WeakSet","triggerCacheReplacement","rxCollection","waitTime","arguments","undefined","onDestroy","then","timeout","clearTimeout","add","val","setTimeout","cacheReplacementPolicy","_queryCache"],"mappings":"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","sourcesContent":["function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } it = o[Symbol.iterator](); return it.next.bind(it); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * the query-cache makes sure that on every query-state, exactly one instance can exist\n * if you use the same mango-query more then once, it will reuse the first RxQuery\n */\nimport { now } from './util';\nexport var QueryCache = /*#__PURE__*/function () {\n  function QueryCache() {\n    this._map = new Map();\n  }\n\n  var _proto = QueryCache.prototype;\n\n  /**\n   * check if an equal query is in the cache,\n   * if true, return the cached one,\n   * if false, save the given one and return it\n   */\n  _proto.getByQuery = function getByQuery(rxQuery) {\n    var stringRep = rxQuery.toString();\n\n    if (!this._map.has(stringRep)) {\n      this._map.set(stringRep, rxQuery);\n    }\n\n    return this._map.get(stringRep);\n  };\n\n  return QueryCache;\n}();\nexport function createQueryCache() {\n  return new QueryCache();\n}\nexport function uncacheRxQuery(queryCache, rxQuery) {\n  rxQuery.uncached = true;\n  var stringRep = rxQuery.toString();\n\n  queryCache._map[\"delete\"](stringRep);\n}\nexport function countRxQuerySubscribers(rxQuery) {\n  return rxQuery.refCount$.observers.length;\n}\nexport var DEFAULT_TRY_TO_KEEP_MAX = 100;\nexport var DEFAULT_UNEXECUTED_LIFETME = 30 * 1000;\nexport var DEFAULT_CACHE_REPLACEMENT_WAIT_TIME = 20 * 1000;\n/**\n * The default cache replacement policy\n * See docs-src/query-cache.md to learn how it should work.\n * Notice that this runs often and should block the cpu as less as possible\n * This is a monad which makes it easier to unit test\n */\n\nexport var defaultCacheReplacementPolicyMonad = function defaultCacheReplacementPolicyMonad(tryToKeepMax, unExecutedLifetime) {\n  return function (_collection, queryCache) {\n    if (queryCache._map.size < tryToKeepMax) {\n      return;\n    }\n\n    var minUnExecutedLifetime = now() - unExecutedLifetime;\n    var maybeUncash = [];\n\n    for (var _iterator = _createForOfIteratorHelperLoose(queryCache._map.values()), _step; !(_step = _iterator()).done;) {\n      var rxQuery = _step.value;\n\n      // filter out queries with subscribers\n      if (countRxQuerySubscribers(rxQuery) > 0) {\n        continue;\n      } // directly uncache queries that never executed and are older then unExecutedLifetime\n\n\n      if (rxQuery._lastEnsureEqual === 0 && rxQuery._creationTime < minUnExecutedLifetime) {\n        uncacheRxQuery(queryCache, rxQuery);\n        continue;\n      }\n\n      maybeUncash.push(rxQuery);\n    }\n\n    var mustUncache = maybeUncash.length - tryToKeepMax;\n\n    if (mustUncache <= 0) {\n      return;\n    }\n\n    var sortedByLastUsage = maybeUncash.sort(function (a, b) {\n      return a._lastEnsureEqual - b._lastEnsureEqual;\n    });\n    var toRemove = sortedByLastUsage.slice(0, mustUncache);\n    toRemove.forEach(function (rxQuery) {\n      return uncacheRxQuery(queryCache, rxQuery);\n    });\n  };\n};\nexport var defaultCacheReplacementPolicy = defaultCacheReplacementPolicyMonad(DEFAULT_TRY_TO_KEEP_MAX, DEFAULT_UNEXECUTED_LIFETME); // @link https://stackoverflow.com/a/56239226/3443137\n\nexport var CACHE_REPLACEMENT_STATE_BY_COLLECTION = new WeakMap();\nexport var COLLECTIONS_WITH_DESTROY_HOOK = new WeakSet();\n/**\n * Triggers the cache replacement policy after waitTime has passed.\n * We do not run this directly because at exactly the time a query is created,\n * we need all CPU to minimize latency.\n * Also this should not be triggered multiple times when waitTime is still waiting.\n */\n\nexport function triggerCacheReplacement(rxCollection) {\n  var waitTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_CACHE_REPLACEMENT_WAIT_TIME;\n\n  if (CACHE_REPLACEMENT_STATE_BY_COLLECTION.has(rxCollection)) {\n    // already started\n    return;\n  } // ensure we clean up the runnung timeouts when the collection is destroyed\n\n\n  if (!COLLECTIONS_WITH_DESTROY_HOOK.has(rxCollection)) {\n    rxCollection.onDestroy.then(function () {\n      var timeout = CACHE_REPLACEMENT_STATE_BY_COLLECTION.get(rxCollection);\n\n      if (timeout) {\n        clearTimeout(timeout);\n      }\n    });\n    COLLECTIONS_WITH_DESTROY_HOOK.add(rxCollection);\n  }\n\n  var val = setTimeout(function () {\n    CACHE_REPLACEMENT_STATE_BY_COLLECTION[\"delete\"](rxCollection);\n    rxCollection.cacheReplacementPolicy(rxCollection, rxCollection._queryCache);\n  }, waitTime);\n  CACHE_REPLACEMENT_STATE_BY_COLLECTION.set(rxCollection, val);\n}\n//# sourceMappingURL=query-cache.js.map"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"/**\n * run some tests on the bdd\n * to ensure everything is correct\n */\nexport function ensureCorrectBdd(bdd) {\n  var jsonString = JSON.stringify(bdd.toJSON(true));\n  var allNodes = [];\n  var nodesById = new Map();\n  bdd.getLevels().forEach(function (level) {\n    var levelNodes = bdd.getNodesOfLevel(level);\n    levelNodes.forEach(function (node) {\n      nodesById.set(node.id, node);\n    });\n    allNodes = allNodes.concat(levelNodes);\n  });\n  var recursiveNodes = getNodesRecursive(bdd);\n\n  if (allNodes.length !== recursiveNodes.size) {\n    var allNodesIds_1 = allNodes.map(function (n) {\n      return n.id;\n    }).sort();\n    var recursiveNodesIds = Array.from(recursiveNodes).map(function (n) {\n      return n.id;\n    }).sort();\n    var nodesOnlyInRecursive = recursiveNodesIds.filter(function (id) {\n      return !allNodesIds_1.includes(id);\n    }); //        console.log(JSON.stringify(allNodes.map(n => n.id).sort(), null, 2));\n    //      console.log(JSON.stringify(Array.from(recursiveNodes).map(n => n.id).sort(), null, 2));\n\n    if (recursiveNodes.size > allNodes.length) {\n      var firstId_1 = nodesOnlyInRecursive[0];\n      var referenceToFirst = allNodes.find(function (n) {\n        if (n.isInternalNode()) {\n          return n.branches.hasNodeIdAsBranch(firstId_1);\n        }\n\n        return false;\n      });\n      console.log('referenceToFirst:');\n      referenceToFirst === null || referenceToFirst === void 0 ? void 0 : referenceToFirst.log();\n    }\n\n    throw new Error('ensureCorrectBdd() ' + 'nodes in list not equal size to recursive nodes ' + 'allNodes: ' + allNodes.length + ' ' + 'recursiveNodes: ' + recursiveNodes.size + ' ' + 'nodesOnlyInRecursive: ' + nodesOnlyInRecursive.join(', ') + ' ');\n  }\n\n  allNodes.forEach(function (node) {\n    if (node.isRootNode()) {\n      return;\n    }\n\n    var useNode = node;\n\n    if (node.deleted) {\n      throw new Error('ensureCorrectBdd() ' + 'bdd includes a deleted node');\n    } // each node should have a parent\n\n\n    if (useNode.parents.size === 0) {\n      throw new Error('ensureCorrectBdd() ' + 'node has no parent ' + useNode.id);\n    }\n\n    if (useNode.isInternalNode()) {\n      var internalNode_1 = useNode;\n      var bothBranches = internalNode_1.branches.getBothBranches(); // a node should not have 2 equal branches\n\n      if (internalNode_1.branches.areBranchesStrictEqual()) {\n        throw new Error('ensureCorrectBdd() ' + 'node has two equal branches: ' + bothBranches.map(function (n) {\n          return n.id;\n        }).join(', '));\n      } // each branch should have the node as parent\n\n\n      bothBranches.forEach(function (branch) {\n        if (!branch.parents.has(internalNode_1)) {\n          throw new Error('ensureCorrectBdd() ' + 'branch must have the node as parent');\n        }\n      });\n    } // each parent should have the child as branch\n\n\n    useNode.parents.getAll().forEach(function (parent) {\n      if (!parent.branches.hasBranchAsNode(useNode)) {\n        throw new Error('ensureCorrectBdd() ' + 'parent node does not have child as branch');\n      }\n    });\n  });\n\n  if (jsonString.includes('\"deleted\":true')) {\n    throw new Error('ensureCorrectBdd() ' + 'bdd includes a deleted node');\n  }\n}\nexport function getNodesRecursive(node, set) {\n  if (set === void 0) {\n    set = new Set();\n  }\n\n  set.add(node);\n\n  if (!node.isLeafNode()) {\n    var useNode = node;\n    var branch1 = useNode.branches.getBranch('0');\n    set.add(branch1);\n    getNodesRecursive(branch1, set);\n    var branch2 = useNode.branches.getBranch('1');\n    set.add(branch2);\n    getNodesRecursive(branch2, set);\n  }\n\n  return set;\n}","map":{"version":3,"sources":["../../src/ensure-correct-bdd.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * run some tests on the bdd\n * to ensure everything is correct\n */\nexport function ensureCorrectBdd(bdd) {\n    var jsonString = JSON.stringify(bdd.toJSON(true));\n    var allNodes = [];\n    var nodesById = new Map();\n    bdd.getLevels().forEach(function (level) {\n        var levelNodes = bdd.getNodesOfLevel(level);\n        levelNodes.forEach(function (node) {\n            nodesById.set(node.id, node);\n        });\n        allNodes = allNodes.concat(levelNodes);\n    });\n    var recursiveNodes = getNodesRecursive(bdd);\n    if (allNodes.length !== recursiveNodes.size) {\n        var allNodesIds_1 = allNodes.map(function (n) { return n.id; }).sort();\n        var recursiveNodesIds = Array.from(recursiveNodes).map(function (n) { return n.id; }).sort();\n        var nodesOnlyInRecursive = recursiveNodesIds.filter(function (id) { return !allNodesIds_1.includes(id); });\n        //        console.log(JSON.stringify(allNodes.map(n => n.id).sort(), null, 2));\n        //      console.log(JSON.stringify(Array.from(recursiveNodes).map(n => n.id).sort(), null, 2));\n        if (recursiveNodes.size > allNodes.length) {\n            var firstId_1 = nodesOnlyInRecursive[0];\n            var referenceToFirst = allNodes.find(function (n) {\n                if (n.isInternalNode()) {\n                    return n.branches.hasNodeIdAsBranch(firstId_1);\n                }\n                return false;\n            });\n            console.log('referenceToFirst:');\n            referenceToFirst === null || referenceToFirst === void 0 ? void 0 : referenceToFirst.log();\n        }\n        throw new Error('ensureCorrectBdd() ' +\n            'nodes in list not equal size to recursive nodes ' +\n            'allNodes: ' + allNodes.length + ' ' +\n            'recursiveNodes: ' + recursiveNodes.size + ' ' +\n            'nodesOnlyInRecursive: ' + nodesOnlyInRecursive.join(', ') + ' ');\n    }\n    allNodes.forEach(function (node) {\n        if (node.isRootNode()) {\n            return;\n        }\n        var useNode = node;\n        if (node.deleted) {\n            throw new Error('ensureCorrectBdd() ' +\n                'bdd includes a deleted node');\n        }\n        // each node should have a parent\n        if (useNode.parents.size === 0) {\n            throw new Error('ensureCorrectBdd() ' +\n                'node has no parent ' + useNode.id);\n        }\n        if (useNode.isInternalNode()) {\n            var internalNode_1 = useNode;\n            var bothBranches = internalNode_1.branches.getBothBranches();\n            // a node should not have 2 equal branches\n            if (internalNode_1.branches.areBranchesStrictEqual()) {\n                throw new Error('ensureCorrectBdd() ' +\n                    'node has two equal branches: ' +\n                    bothBranches.map(function (n) { return n.id; }).join(', '));\n            }\n            // each branch should have the node as parent\n            bothBranches.forEach(function (branch) {\n                if (!branch.parents.has(internalNode_1)) {\n                    throw new Error('ensureCorrectBdd() ' +\n                        'branch must have the node as parent');\n                }\n            });\n        }\n        // each parent should have the child as branch\n        useNode.parents.getAll().forEach(function (parent) {\n            if (!parent.branches.hasBranchAsNode(useNode)) {\n                throw new Error('ensureCorrectBdd() ' +\n                    'parent node does not have child as branch');\n            }\n        });\n    });\n    if (jsonString.includes('\"deleted\":true')) {\n        throw new Error('ensureCorrectBdd() ' +\n            'bdd includes a deleted node');\n    }\n}\nexport function getNodesRecursive(node, set) {\n    if (set === void 0) { set = new Set(); }\n    set.add(node);\n    if (!node.isLeafNode()) {\n        var useNode = node;\n        var branch1 = useNode.branches.getBranch('0');\n        set.add(branch1);\n        getNodesRecursive(branch1, set);\n        var branch2 = useNode.branches.getBranch('1');\n        set.add(branch2);\n        getNodesRecursive(branch2, set);\n    }\n    return set;\n}\n//# sourceMappingURL=ensure-correct-bdd.js.map"]},"metadata":{},"sourceType":"module"}
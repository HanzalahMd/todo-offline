{"ast":null,"code":"import Checkpointer from 'pouchdb-checkpointer';\nimport generateReplicationId from 'pouchdb-generate-replication-id';\nimport { createError, BAD_REQUEST } from 'pouchdb-errors';\nimport { clone, flatten, isRemote, defaultBackOff, filterChange, nextTick, uuid, assign } from 'pouchdb-utils';\nimport inherits from 'inherits';\nimport { EventEmitter } from 'events';\n\nfunction isGenOne(rev) {\n  return /^1-/.test(rev);\n}\n\nfunction fileHasChanged(localDoc, remoteDoc, filename) {\n  return !localDoc._attachments || !localDoc._attachments[filename] || localDoc._attachments[filename].digest !== remoteDoc._attachments[filename].digest;\n}\n\nfunction getDocAttachments(db, doc) {\n  var filenames = Object.keys(doc._attachments);\n  return Promise.all(filenames.map(function (filename) {\n    return db.getAttachment(doc._id, filename, {\n      rev: doc._rev\n    });\n  }));\n}\n\nfunction getDocAttachmentsFromTargetOrSource(target, src, doc) {\n  var doCheckForLocalAttachments = isRemote(src) && !isRemote(target);\n  var filenames = Object.keys(doc._attachments);\n\n  if (!doCheckForLocalAttachments) {\n    return getDocAttachments(src, doc);\n  }\n\n  return target.get(doc._id).then(function (localDoc) {\n    return Promise.all(filenames.map(function (filename) {\n      if (fileHasChanged(localDoc, doc, filename)) {\n        return src.getAttachment(doc._id, filename);\n      }\n\n      return target.getAttachment(localDoc._id, filename);\n    }));\n  }).catch(function (error) {\n    /* istanbul ignore if */\n    if (error.status !== 404) {\n      throw error;\n    }\n\n    return getDocAttachments(src, doc);\n  });\n}\n\nfunction createBulkGetOpts(diffs) {\n  var requests = [];\n  Object.keys(diffs).forEach(function (id) {\n    var missingRevs = diffs[id].missing;\n    missingRevs.forEach(function (missingRev) {\n      requests.push({\n        id: id,\n        rev: missingRev\n      });\n    });\n  });\n  return {\n    docs: requests,\n    revs: true,\n    latest: true\n  };\n} //\n// Fetch all the documents from the src as described in the \"diffs\",\n// which is a mapping of docs IDs to revisions. If the state ever\n// changes to \"cancelled\", then the returned promise will be rejected.\n// Else it will be resolved with a list of fetched documents.\n//\n\n\nfunction getDocs(src, target, diffs, state) {\n  diffs = clone(diffs); // we do not need to modify this\n\n  var resultDocs = [],\n      ok = true;\n\n  function getAllDocs() {\n    var bulkGetOpts = createBulkGetOpts(diffs);\n\n    if (!bulkGetOpts.docs.length) {\n      // optimization: skip empty requests\n      return;\n    }\n\n    return src.bulkGet(bulkGetOpts).then(function (bulkGetResponse) {\n      /* istanbul ignore if */\n      if (state.cancelled) {\n        throw new Error('cancelled');\n      }\n\n      return Promise.all(bulkGetResponse.results.map(function (bulkGetInfo) {\n        return Promise.all(bulkGetInfo.docs.map(function (doc) {\n          var remoteDoc = doc.ok;\n\n          if (doc.error) {\n            // when AUTO_COMPACTION is set, docs can be returned which look\n            // like this: {\"missing\":\"1-7c3ac256b693c462af8442f992b83696\"}\n            ok = false;\n          }\n\n          if (!remoteDoc || !remoteDoc._attachments) {\n            return remoteDoc;\n          }\n\n          return getDocAttachmentsFromTargetOrSource(target, src, remoteDoc).then(function (attachments) {\n            var filenames = Object.keys(remoteDoc._attachments);\n            attachments.forEach(function (attachment, i) {\n              var att = remoteDoc._attachments[filenames[i]];\n              delete att.stub;\n              delete att.length;\n              att.data = attachment;\n            });\n            return remoteDoc;\n          });\n        }));\n      })).then(function (results) {\n        resultDocs = resultDocs.concat(flatten(results).filter(Boolean));\n      });\n    });\n  }\n\n  function hasAttachments(doc) {\n    return doc._attachments && Object.keys(doc._attachments).length > 0;\n  }\n\n  function hasConflicts(doc) {\n    return doc._conflicts && doc._conflicts.length > 0;\n  }\n\n  function fetchRevisionOneDocs(ids) {\n    // Optimization: fetch gen-1 docs and attachments in\n    // a single request using _all_docs\n    return src.allDocs({\n      keys: ids,\n      include_docs: true,\n      conflicts: true\n    }).then(function (res) {\n      if (state.cancelled) {\n        throw new Error('cancelled');\n      }\n\n      res.rows.forEach(function (row) {\n        if (row.deleted || !row.doc || !isGenOne(row.value.rev) || hasAttachments(row.doc) || hasConflicts(row.doc)) {\n          // if any of these conditions apply, we need to fetch using get()\n          return;\n        } // strip _conflicts array to appease CSG (#5793)\n\n        /* istanbul ignore if */\n\n\n        if (row.doc._conflicts) {\n          delete row.doc._conflicts;\n        } // the doc we got back from allDocs() is sufficient\n\n\n        resultDocs.push(row.doc);\n        delete diffs[row.id];\n      });\n    });\n  }\n\n  function getRevisionOneDocs() {\n    // filter out the generation 1 docs and get them\n    // leaving the non-generation one docs to be got otherwise\n    var ids = Object.keys(diffs).filter(function (id) {\n      var missing = diffs[id].missing;\n      return missing.length === 1 && isGenOne(missing[0]);\n    });\n\n    if (ids.length > 0) {\n      return fetchRevisionOneDocs(ids);\n    }\n  }\n\n  function returnResult() {\n    return {\n      ok: ok,\n      docs: resultDocs\n    };\n  }\n\n  return Promise.resolve().then(getRevisionOneDocs).then(getAllDocs).then(returnResult);\n}\n\nvar STARTING_BACK_OFF = 0;\n\nfunction backOff(opts, returnValue, error, callback) {\n  if (opts.retry === false) {\n    returnValue.emit('error', error);\n    returnValue.removeAllListeners();\n    return;\n  }\n  /* istanbul ignore if */\n\n\n  if (typeof opts.back_off_function !== 'function') {\n    opts.back_off_function = defaultBackOff;\n  }\n\n  returnValue.emit('requestError', error);\n\n  if (returnValue.state === 'active' || returnValue.state === 'pending') {\n    returnValue.emit('paused', error);\n    returnValue.state = 'stopped';\n\n    var backOffSet = function backoffTimeSet() {\n      opts.current_back_off = STARTING_BACK_OFF;\n    };\n\n    var removeBackOffSetter = function removeBackOffTimeSet() {\n      returnValue.removeListener('active', backOffSet);\n    };\n\n    returnValue.once('paused', removeBackOffSetter);\n    returnValue.once('active', backOffSet);\n  }\n\n  opts.current_back_off = opts.current_back_off || STARTING_BACK_OFF;\n  opts.current_back_off = opts.back_off_function(opts.current_back_off);\n  setTimeout(callback, opts.current_back_off);\n}\n\nfunction replicate(src, target, opts, returnValue, result) {\n  var batches = []; // list of batches to be processed\n\n  var currentBatch; // the batch currently being processed\n\n  var pendingBatch = {\n    seq: 0,\n    changes: [],\n    docs: []\n  }; // next batch, not yet ready to be processed\n\n  var writingCheckpoint = false; // true while checkpoint is being written\n\n  var changesCompleted = false; // true when all changes received\n\n  var replicationCompleted = false; // true when replication has completed\n\n  var last_seq = 0;\n  var continuous = opts.continuous || opts.live || false;\n  var batch_size = opts.batch_size || 100;\n  var batches_limit = opts.batches_limit || 10;\n  var changesPending = false; // true while src.changes is running\n\n  var doc_ids = opts.doc_ids;\n  var selector = opts.selector;\n  var repId;\n  var checkpointer;\n  var changedDocs = []; // Like couchdb, every replication gets a unique session id\n\n  var session = uuid();\n  result = result || {\n    ok: true,\n    start_time: new Date().toISOString(),\n    docs_read: 0,\n    docs_written: 0,\n    doc_write_failures: 0,\n    errors: []\n  };\n  var changesOpts = {};\n  returnValue.ready(src, target);\n\n  function initCheckpointer() {\n    if (checkpointer) {\n      return Promise.resolve();\n    }\n\n    return generateReplicationId(src, target, opts).then(function (res) {\n      repId = res;\n      var checkpointOpts = {};\n\n      if (opts.checkpoint === false) {\n        checkpointOpts = {\n          writeSourceCheckpoint: false,\n          writeTargetCheckpoint: false\n        };\n      } else if (opts.checkpoint === 'source') {\n        checkpointOpts = {\n          writeSourceCheckpoint: true,\n          writeTargetCheckpoint: false\n        };\n      } else if (opts.checkpoint === 'target') {\n        checkpointOpts = {\n          writeSourceCheckpoint: false,\n          writeTargetCheckpoint: true\n        };\n      } else {\n        checkpointOpts = {\n          writeSourceCheckpoint: true,\n          writeTargetCheckpoint: true\n        };\n      }\n\n      checkpointer = new Checkpointer(src, target, repId, returnValue, checkpointOpts);\n    });\n  }\n\n  function writeDocs() {\n    changedDocs = [];\n\n    if (currentBatch.docs.length === 0) {\n      return;\n    }\n\n    var docs = currentBatch.docs;\n    var bulkOpts = {\n      timeout: opts.timeout\n    };\n    return target.bulkDocs({\n      docs: docs,\n      new_edits: false\n    }, bulkOpts).then(function (res) {\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        throw new Error('cancelled');\n      } // `res` doesn't include full documents (which live in `docs`), so we create a map of \n      // (id -> error), and check for errors while iterating over `docs`\n\n\n      var errorsById = Object.create(null);\n      res.forEach(function (res) {\n        if (res.error) {\n          errorsById[res.id] = res;\n        }\n      });\n      var errorsNo = Object.keys(errorsById).length;\n      result.doc_write_failures += errorsNo;\n      result.docs_written += docs.length - errorsNo;\n      docs.forEach(function (doc) {\n        var error = errorsById[doc._id];\n\n        if (error) {\n          result.errors.push(error); // Normalize error name. i.e. 'Unauthorized' -> 'unauthorized' (eg Sync Gateway)\n\n          var errorName = (error.name || '').toLowerCase();\n\n          if (errorName === 'unauthorized' || errorName === 'forbidden') {\n            returnValue.emit('denied', clone(error));\n          } else {\n            throw error;\n          }\n        } else {\n          changedDocs.push(doc);\n        }\n      });\n    }, function (err) {\n      result.doc_write_failures += docs.length;\n      throw err;\n    });\n  }\n\n  function finishBatch() {\n    if (currentBatch.error) {\n      throw new Error('There was a problem getting docs.');\n    }\n\n    result.last_seq = last_seq = currentBatch.seq;\n    var outResult = clone(result);\n\n    if (changedDocs.length) {\n      outResult.docs = changedDocs; // Attach 'pending' property if server supports it (CouchDB 2.0+)\n\n      /* istanbul ignore if */\n\n      if (typeof currentBatch.pending === 'number') {\n        outResult.pending = currentBatch.pending;\n        delete currentBatch.pending;\n      }\n\n      returnValue.emit('change', outResult);\n    }\n\n    writingCheckpoint = true;\n    return checkpointer.writeCheckpoint(currentBatch.seq, session).then(function () {\n      writingCheckpoint = false;\n      /* istanbul ignore if */\n\n      if (returnValue.cancelled) {\n        completeReplication();\n        throw new Error('cancelled');\n      }\n\n      currentBatch = undefined;\n      getChanges();\n    }).catch(function (err) {\n      onCheckpointError(err);\n      throw err;\n    });\n  }\n\n  function getDiffs() {\n    var diff = {};\n    currentBatch.changes.forEach(function (change) {\n      // Couchbase Sync Gateway emits these, but we can ignore them\n\n      /* istanbul ignore if */\n      if (change.id === \"_user/\") {\n        return;\n      }\n\n      diff[change.id] = change.changes.map(function (x) {\n        return x.rev;\n      });\n    });\n    return target.revsDiff(diff).then(function (diffs) {\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        throw new Error('cancelled');\n      } // currentBatch.diffs elements are deleted as the documents are written\n\n\n      currentBatch.diffs = diffs;\n    });\n  }\n\n  function getBatchDocs() {\n    return getDocs(src, target, currentBatch.diffs, returnValue).then(function (got) {\n      currentBatch.error = !got.ok;\n      got.docs.forEach(function (doc) {\n        delete currentBatch.diffs[doc._id];\n        result.docs_read++;\n        currentBatch.docs.push(doc);\n      });\n    });\n  }\n\n  function startNextBatch() {\n    if (returnValue.cancelled || currentBatch) {\n      return;\n    }\n\n    if (batches.length === 0) {\n      processPendingBatch(true);\n      return;\n    }\n\n    currentBatch = batches.shift();\n    getDiffs().then(getBatchDocs).then(writeDocs).then(finishBatch).then(startNextBatch).catch(function (err) {\n      abortReplication('batch processing terminated with error', err);\n    });\n  }\n\n  function processPendingBatch(immediate) {\n    if (pendingBatch.changes.length === 0) {\n      if (batches.length === 0 && !currentBatch) {\n        if (continuous && changesOpts.live || changesCompleted) {\n          returnValue.state = 'pending';\n          returnValue.emit('paused');\n        }\n\n        if (changesCompleted) {\n          completeReplication();\n        }\n      }\n\n      return;\n    }\n\n    if (immediate || changesCompleted || pendingBatch.changes.length >= batch_size) {\n      batches.push(pendingBatch);\n      pendingBatch = {\n        seq: 0,\n        changes: [],\n        docs: []\n      };\n\n      if (returnValue.state === 'pending' || returnValue.state === 'stopped') {\n        returnValue.state = 'active';\n        returnValue.emit('active');\n      }\n\n      startNextBatch();\n    }\n  }\n\n  function abortReplication(reason, err) {\n    if (replicationCompleted) {\n      return;\n    }\n\n    if (!err.message) {\n      err.message = reason;\n    }\n\n    result.ok = false;\n    result.status = 'aborting';\n    batches = [];\n    pendingBatch = {\n      seq: 0,\n      changes: [],\n      docs: []\n    };\n    completeReplication(err);\n  }\n\n  function completeReplication(fatalError) {\n    if (replicationCompleted) {\n      return;\n    }\n    /* istanbul ignore if */\n\n\n    if (returnValue.cancelled) {\n      result.status = 'cancelled';\n\n      if (writingCheckpoint) {\n        return;\n      }\n    }\n\n    result.status = result.status || 'complete';\n    result.end_time = new Date().toISOString();\n    result.last_seq = last_seq;\n    replicationCompleted = true;\n\n    if (fatalError) {\n      // need to extend the error because Firefox considers \".result\" read-only\n      fatalError = createError(fatalError);\n      fatalError.result = result; // Normalize error name. i.e. 'Unauthorized' -> 'unauthorized' (eg Sync Gateway)\n\n      var errorName = (fatalError.name || '').toLowerCase();\n\n      if (errorName === 'unauthorized' || errorName === 'forbidden') {\n        returnValue.emit('error', fatalError);\n        returnValue.removeAllListeners();\n      } else {\n        backOff(opts, returnValue, fatalError, function () {\n          replicate(src, target, opts, returnValue);\n        });\n      }\n    } else {\n      returnValue.emit('complete', result);\n      returnValue.removeAllListeners();\n    }\n  }\n\n  function onChange(change, pending, lastSeq) {\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      return completeReplication();\n    } // Attach 'pending' property if server supports it (CouchDB 2.0+)\n\n    /* istanbul ignore if */\n\n\n    if (typeof pending === 'number') {\n      pendingBatch.pending = pending;\n    }\n\n    var filter = filterChange(opts)(change);\n\n    if (!filter) {\n      return;\n    }\n\n    pendingBatch.seq = change.seq || lastSeq;\n    pendingBatch.changes.push(change);\n    nextTick(function () {\n      processPendingBatch(batches.length === 0 && changesOpts.live);\n    });\n  }\n\n  function onChangesComplete(changes) {\n    changesPending = false;\n    /* istanbul ignore if */\n\n    if (returnValue.cancelled) {\n      return completeReplication();\n    } // if no results were returned then we're done,\n    // else fetch more\n\n\n    if (changes.results.length > 0) {\n      changesOpts.since = changes.results[changes.results.length - 1].seq;\n      getChanges();\n      processPendingBatch(true);\n    } else {\n      var complete = function complete() {\n        if (continuous) {\n          changesOpts.live = true;\n          getChanges();\n        } else {\n          changesCompleted = true;\n        }\n\n        processPendingBatch(true);\n      }; // update the checkpoint so we start from the right seq next time\n\n\n      if (!currentBatch && changes.results.length === 0) {\n        writingCheckpoint = true;\n        checkpointer.writeCheckpoint(changes.last_seq, session).then(function () {\n          writingCheckpoint = false;\n          result.last_seq = last_seq = changes.last_seq;\n          complete();\n        }).catch(onCheckpointError);\n      } else {\n        complete();\n      }\n    }\n  }\n\n  function onChangesError(err) {\n    changesPending = false;\n    /* istanbul ignore if */\n\n    if (returnValue.cancelled) {\n      return completeReplication();\n    }\n\n    abortReplication('changes rejected', err);\n  }\n\n  function getChanges() {\n    if (!(!changesPending && !changesCompleted && batches.length < batches_limit)) {\n      return;\n    }\n\n    changesPending = true;\n\n    function abortChanges() {\n      changes.cancel();\n    }\n\n    function removeListener() {\n      returnValue.removeListener('cancel', abortChanges);\n    }\n\n    if (returnValue._changes) {\n      // remove old changes() and listeners\n      returnValue.removeListener('cancel', returnValue._abortChanges);\n\n      returnValue._changes.cancel();\n    }\n\n    returnValue.once('cancel', abortChanges);\n    var changes = src.changes(changesOpts).on('change', onChange);\n    changes.then(removeListener, removeListener);\n    changes.then(onChangesComplete).catch(onChangesError);\n\n    if (opts.retry) {\n      // save for later so we can cancel if necessary\n      returnValue._changes = changes;\n      returnValue._abortChanges = abortChanges;\n    }\n  }\n\n  function startChanges() {\n    initCheckpointer().then(function () {\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        return;\n      }\n\n      return checkpointer.getCheckpoint().then(function (checkpoint) {\n        last_seq = checkpoint;\n        changesOpts = {\n          since: last_seq,\n          limit: batch_size,\n          batch_size: batch_size,\n          style: 'all_docs',\n          doc_ids: doc_ids,\n          selector: selector,\n          return_docs: true // required so we know when we're done\n\n        };\n\n        if (opts.filter) {\n          if (typeof opts.filter !== 'string') {\n            // required for the client-side filter in onChange\n            changesOpts.include_docs = true;\n          } else {\n            // ddoc filter\n            changesOpts.filter = opts.filter;\n          }\n        }\n\n        if ('heartbeat' in opts) {\n          changesOpts.heartbeat = opts.heartbeat;\n        }\n\n        if ('timeout' in opts) {\n          changesOpts.timeout = opts.timeout;\n        }\n\n        if (opts.query_params) {\n          changesOpts.query_params = opts.query_params;\n        }\n\n        if (opts.view) {\n          changesOpts.view = opts.view;\n        }\n\n        getChanges();\n      });\n    }).catch(function (err) {\n      abortReplication('getCheckpoint rejected with ', err);\n    });\n  }\n  /* istanbul ignore next */\n\n\n  function onCheckpointError(err) {\n    writingCheckpoint = false;\n    abortReplication('writeCheckpoint completed with error', err);\n  }\n  /* istanbul ignore if */\n\n\n  if (returnValue.cancelled) {\n    // cancelled immediately\n    completeReplication();\n    return;\n  }\n\n  if (!returnValue._addedListeners) {\n    returnValue.once('cancel', completeReplication);\n\n    if (typeof opts.complete === 'function') {\n      returnValue.once('error', opts.complete);\n      returnValue.once('complete', function (result) {\n        opts.complete(null, result);\n      });\n    }\n\n    returnValue._addedListeners = true;\n  }\n\n  if (typeof opts.since === 'undefined') {\n    startChanges();\n  } else {\n    initCheckpointer().then(function () {\n      writingCheckpoint = true;\n      return checkpointer.writeCheckpoint(opts.since, session);\n    }).then(function () {\n      writingCheckpoint = false;\n      /* istanbul ignore if */\n\n      if (returnValue.cancelled) {\n        completeReplication();\n        return;\n      }\n\n      last_seq = opts.since;\n      startChanges();\n    }).catch(onCheckpointError);\n  }\n} // We create a basic promise so the caller can cancel the replication possibly\n// before we have actually started listening to changes etc\n\n\ninherits(Replication, EventEmitter);\n\nfunction Replication() {\n  EventEmitter.call(this);\n  this.cancelled = false;\n  this.state = 'pending';\n  var self = this;\n  var promise = new Promise(function (fulfill, reject) {\n    self.once('complete', fulfill);\n    self.once('error', reject);\n  });\n\n  self.then = function (resolve, reject) {\n    return promise.then(resolve, reject);\n  };\n\n  self.catch = function (reject) {\n    return promise.catch(reject);\n  }; // As we allow error handling via \"error\" event as well,\n  // put a stub in here so that rejecting never throws UnhandledError.\n\n\n  self.catch(function () {});\n}\n\nReplication.prototype.cancel = function () {\n  this.cancelled = true;\n  this.state = 'cancelled';\n  this.emit('cancel');\n};\n\nReplication.prototype.ready = function (src, target) {\n  var self = this;\n\n  if (self._readyCalled) {\n    return;\n  }\n\n  self._readyCalled = true;\n\n  function onDestroy() {\n    self.cancel();\n  }\n\n  src.once('destroyed', onDestroy);\n  target.once('destroyed', onDestroy);\n\n  function cleanup() {\n    src.removeListener('destroyed', onDestroy);\n    target.removeListener('destroyed', onDestroy);\n  }\n\n  self.once('complete', cleanup);\n};\n\nfunction toPouch(db, opts) {\n  var PouchConstructor = opts.PouchConstructor;\n\n  if (typeof db === 'string') {\n    return new PouchConstructor(db, opts);\n  } else {\n    return db;\n  }\n}\n\nfunction replicateWrapper(src, target, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  if (typeof opts === 'undefined') {\n    opts = {};\n  }\n\n  if (opts.doc_ids && !Array.isArray(opts.doc_ids)) {\n    throw createError(BAD_REQUEST, \"`doc_ids` filter parameter is not a list.\");\n  }\n\n  opts.complete = callback;\n  opts = clone(opts);\n  opts.continuous = opts.continuous || opts.live;\n  opts.retry = 'retry' in opts ? opts.retry : false;\n  /*jshint validthis:true */\n\n  opts.PouchConstructor = opts.PouchConstructor || this;\n  var replicateRet = new Replication(opts);\n  var srcPouch = toPouch(src, opts);\n  var targetPouch = toPouch(target, opts);\n  replicate(srcPouch, targetPouch, opts, replicateRet);\n  return replicateRet;\n}\n\ninherits(Sync, EventEmitter);\n\nfunction sync(src, target, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  if (typeof opts === 'undefined') {\n    opts = {};\n  }\n\n  opts = clone(opts);\n  /*jshint validthis:true */\n\n  opts.PouchConstructor = opts.PouchConstructor || this;\n  src = toPouch(src, opts);\n  target = toPouch(target, opts);\n  return new Sync(src, target, opts, callback);\n}\n\nfunction Sync(src, target, opts, callback) {\n  var self = this;\n  this.canceled = false;\n  var optsPush = opts.push ? assign({}, opts, opts.push) : opts;\n  var optsPull = opts.pull ? assign({}, opts, opts.pull) : opts;\n  this.push = replicateWrapper(src, target, optsPush);\n  this.pull = replicateWrapper(target, src, optsPull);\n  this.pushPaused = true;\n  this.pullPaused = true;\n\n  function pullChange(change) {\n    self.emit('change', {\n      direction: 'pull',\n      change: change\n    });\n  }\n\n  function pushChange(change) {\n    self.emit('change', {\n      direction: 'push',\n      change: change\n    });\n  }\n\n  function pushDenied(doc) {\n    self.emit('denied', {\n      direction: 'push',\n      doc: doc\n    });\n  }\n\n  function pullDenied(doc) {\n    self.emit('denied', {\n      direction: 'pull',\n      doc: doc\n    });\n  }\n\n  function pushPaused() {\n    self.pushPaused = true;\n    /* istanbul ignore if */\n\n    if (self.pullPaused) {\n      self.emit('paused');\n    }\n  }\n\n  function pullPaused() {\n    self.pullPaused = true;\n    /* istanbul ignore if */\n\n    if (self.pushPaused) {\n      self.emit('paused');\n    }\n  }\n\n  function pushActive() {\n    self.pushPaused = false;\n    /* istanbul ignore if */\n\n    if (self.pullPaused) {\n      self.emit('active', {\n        direction: 'push'\n      });\n    }\n  }\n\n  function pullActive() {\n    self.pullPaused = false;\n    /* istanbul ignore if */\n\n    if (self.pushPaused) {\n      self.emit('active', {\n        direction: 'pull'\n      });\n    }\n  }\n\n  var removed = {};\n\n  function removeAll(type) {\n    // type is 'push' or 'pull'\n    return function (event, func) {\n      var isChange = event === 'change' && (func === pullChange || func === pushChange);\n      var isDenied = event === 'denied' && (func === pullDenied || func === pushDenied);\n      var isPaused = event === 'paused' && (func === pullPaused || func === pushPaused);\n      var isActive = event === 'active' && (func === pullActive || func === pushActive);\n\n      if (isChange || isDenied || isPaused || isActive) {\n        if (!(event in removed)) {\n          removed[event] = {};\n        }\n\n        removed[event][type] = true;\n\n        if (Object.keys(removed[event]).length === 2) {\n          // both push and pull have asked to be removed\n          self.removeAllListeners(event);\n        }\n      }\n    };\n  }\n\n  if (opts.live) {\n    this.push.on('complete', self.pull.cancel.bind(self.pull));\n    this.pull.on('complete', self.push.cancel.bind(self.push));\n  }\n\n  function addOneListener(ee, event, listener) {\n    if (ee.listeners(event).indexOf(listener) == -1) {\n      ee.on(event, listener);\n    }\n  }\n\n  this.on('newListener', function (event) {\n    if (event === 'change') {\n      addOneListener(self.pull, 'change', pullChange);\n      addOneListener(self.push, 'change', pushChange);\n    } else if (event === 'denied') {\n      addOneListener(self.pull, 'denied', pullDenied);\n      addOneListener(self.push, 'denied', pushDenied);\n    } else if (event === 'active') {\n      addOneListener(self.pull, 'active', pullActive);\n      addOneListener(self.push, 'active', pushActive);\n    } else if (event === 'paused') {\n      addOneListener(self.pull, 'paused', pullPaused);\n      addOneListener(self.push, 'paused', pushPaused);\n    }\n  });\n  this.on('removeListener', function (event) {\n    if (event === 'change') {\n      self.pull.removeListener('change', pullChange);\n      self.push.removeListener('change', pushChange);\n    } else if (event === 'denied') {\n      self.pull.removeListener('denied', pullDenied);\n      self.push.removeListener('denied', pushDenied);\n    } else if (event === 'active') {\n      self.pull.removeListener('active', pullActive);\n      self.push.removeListener('active', pushActive);\n    } else if (event === 'paused') {\n      self.pull.removeListener('paused', pullPaused);\n      self.push.removeListener('paused', pushPaused);\n    }\n  });\n  this.pull.on('removeListener', removeAll('pull'));\n  this.push.on('removeListener', removeAll('push'));\n  var promise = Promise.all([this.push, this.pull]).then(function (resp) {\n    var out = {\n      push: resp[0],\n      pull: resp[1]\n    };\n    self.emit('complete', out);\n\n    if (callback) {\n      callback(null, out);\n    }\n\n    self.removeAllListeners();\n    return out;\n  }, function (err) {\n    self.cancel();\n\n    if (callback) {\n      // if there's a callback, then the callback can receive\n      // the error event\n      callback(err);\n    } else {\n      // if there's no callback, then we're safe to emit an error\n      // event, which would otherwise throw an unhandled error\n      // due to 'error' being a special event in EventEmitters\n      self.emit('error', err);\n    }\n\n    self.removeAllListeners();\n\n    if (callback) {\n      // no sense throwing if we're already emitting an 'error' event\n      throw err;\n    }\n  });\n\n  this.then = function (success, err) {\n    return promise.then(success, err);\n  };\n\n  this.catch = function (err) {\n    return promise.catch(err);\n  };\n}\n\nSync.prototype.cancel = function () {\n  if (!this.canceled) {\n    this.canceled = true;\n    this.push.cancel();\n    this.pull.cancel();\n  }\n};\n\nfunction replication(PouchDB) {\n  PouchDB.replicate = replicateWrapper;\n  PouchDB.sync = sync;\n  Object.defineProperty(PouchDB.prototype, 'replicate', {\n    get: function get() {\n      var self = this;\n\n      if (typeof this.replicateMethods === 'undefined') {\n        this.replicateMethods = {\n          from: function from(other, opts, callback) {\n            return self.constructor.replicate(other, self, opts, callback);\n          },\n          to: function to(other, opts, callback) {\n            return self.constructor.replicate(self, other, opts, callback);\n          }\n        };\n      }\n\n      return this.replicateMethods;\n    }\n  });\n\n  PouchDB.prototype.sync = function (dbName, opts, callback) {\n    return this.constructor.sync(this, dbName, opts, callback);\n  };\n}\n\nexport default replication;","map":{"version":3,"sources":["/Users/Hanzalah/Desktop/github/todo-offline/rxdb-hasura-demo/node_modules/pouchdb-replication/lib/index.es.js"],"names":["Checkpointer","generateReplicationId","createError","BAD_REQUEST","clone","flatten","isRemote","defaultBackOff","filterChange","nextTick","uuid","assign","inherits","EventEmitter","isGenOne","rev","test","fileHasChanged","localDoc","remoteDoc","filename","_attachments","digest","getDocAttachments","db","doc","filenames","Object","keys","Promise","all","map","getAttachment","_id","_rev","getDocAttachmentsFromTargetOrSource","target","src","doCheckForLocalAttachments","get","then","catch","error","status","createBulkGetOpts","diffs","requests","forEach","id","missingRevs","missing","missingRev","push","docs","revs","latest","getDocs","state","resultDocs","ok","getAllDocs","bulkGetOpts","length","bulkGet","bulkGetResponse","cancelled","Error","results","bulkGetInfo","attachments","attachment","i","att","stub","data","concat","filter","Boolean","hasAttachments","hasConflicts","_conflicts","fetchRevisionOneDocs","ids","allDocs","include_docs","conflicts","res","rows","row","deleted","value","getRevisionOneDocs","returnResult","resolve","STARTING_BACK_OFF","backOff","opts","returnValue","callback","retry","emit","removeAllListeners","back_off_function","backOffSet","backoffTimeSet","current_back_off","removeBackOffSetter","removeBackOffTimeSet","removeListener","once","setTimeout","replicate","result","batches","currentBatch","pendingBatch","seq","changes","writingCheckpoint","changesCompleted","replicationCompleted","last_seq","continuous","live","batch_size","batches_limit","changesPending","doc_ids","selector","repId","checkpointer","changedDocs","session","start_time","Date","toISOString","docs_read","docs_written","doc_write_failures","errors","changesOpts","ready","initCheckpointer","checkpointOpts","checkpoint","writeSourceCheckpoint","writeTargetCheckpoint","writeDocs","bulkOpts","timeout","bulkDocs","new_edits","completeReplication","errorsById","create","errorsNo","errorName","name","toLowerCase","err","finishBatch","outResult","pending","writeCheckpoint","undefined","getChanges","onCheckpointError","getDiffs","diff","change","x","revsDiff","getBatchDocs","got","startNextBatch","processPendingBatch","shift","abortReplication","immediate","reason","message","fatalError","end_time","onChange","lastSeq","onChangesComplete","since","complete","onChangesError","abortChanges","cancel","_changes","_abortChanges","on","startChanges","getCheckpoint","limit","style","return_docs","heartbeat","query_params","view","_addedListeners","Replication","call","self","promise","fulfill","reject","prototype","_readyCalled","onDestroy","cleanup","toPouch","PouchConstructor","replicateWrapper","Array","isArray","replicateRet","srcPouch","targetPouch","Sync","sync","canceled","optsPush","optsPull","pull","pushPaused","pullPaused","pullChange","direction","pushChange","pushDenied","pullDenied","pushActive","pullActive","removed","removeAll","type","event","func","isChange","isDenied","isPaused","isActive","bind","addOneListener","ee","listener","listeners","indexOf","resp","out","success","replication","PouchDB","defineProperty","replicateMethods","from","other","constructor","to","dbName"],"mappings":"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","sourcesContent":["import Checkpointer from 'pouchdb-checkpointer';\nimport generateReplicationId from 'pouchdb-generate-replication-id';\nimport { createError, BAD_REQUEST } from 'pouchdb-errors';\nimport { clone, flatten, isRemote, defaultBackOff, filterChange, nextTick, uuid, assign } from 'pouchdb-utils';\nimport inherits from 'inherits';\nimport { EventEmitter } from 'events';\n\nfunction isGenOne(rev) {\n  return /^1-/.test(rev);\n}\n\nfunction fileHasChanged(localDoc, remoteDoc, filename) {\n  return !localDoc._attachments ||\n         !localDoc._attachments[filename] ||\n         localDoc._attachments[filename].digest !== remoteDoc._attachments[filename].digest;\n}\n\nfunction getDocAttachments(db, doc) {\n  var filenames = Object.keys(doc._attachments);\n  return Promise.all(filenames.map(function (filename) {\n    return db.getAttachment(doc._id, filename, {rev: doc._rev});\n  }));\n}\n\nfunction getDocAttachmentsFromTargetOrSource(target, src, doc) {\n  var doCheckForLocalAttachments = isRemote(src) && !isRemote(target);\n  var filenames = Object.keys(doc._attachments);\n\n  if (!doCheckForLocalAttachments) {\n    return getDocAttachments(src, doc);\n  }\n\n  return target.get(doc._id).then(function (localDoc) {\n    return Promise.all(filenames.map(function (filename) {\n      if (fileHasChanged(localDoc, doc, filename)) {\n        return src.getAttachment(doc._id, filename);\n      }\n\n      return target.getAttachment(localDoc._id, filename);\n    }));\n  }).catch(function (error) {\n    /* istanbul ignore if */\n    if (error.status !== 404) {\n      throw error;\n    }\n\n    return getDocAttachments(src, doc);\n  });\n}\n\nfunction createBulkGetOpts(diffs) {\n  var requests = [];\n  Object.keys(diffs).forEach(function (id) {\n    var missingRevs = diffs[id].missing;\n    missingRevs.forEach(function (missingRev) {\n      requests.push({\n        id: id,\n        rev: missingRev\n      });\n    });\n  });\n\n  return {\n    docs: requests,\n    revs: true,\n    latest: true\n  };\n}\n\n//\n// Fetch all the documents from the src as described in the \"diffs\",\n// which is a mapping of docs IDs to revisions. If the state ever\n// changes to \"cancelled\", then the returned promise will be rejected.\n// Else it will be resolved with a list of fetched documents.\n//\nfunction getDocs(src, target, diffs, state) {\n  diffs = clone(diffs); // we do not need to modify this\n\n  var resultDocs = [],\n      ok = true;\n\n  function getAllDocs() {\n\n    var bulkGetOpts = createBulkGetOpts(diffs);\n\n    if (!bulkGetOpts.docs.length) { // optimization: skip empty requests\n      return;\n    }\n\n    return src.bulkGet(bulkGetOpts).then(function (bulkGetResponse) {\n      /* istanbul ignore if */\n      if (state.cancelled) {\n        throw new Error('cancelled');\n      }\n      return Promise.all(bulkGetResponse.results.map(function (bulkGetInfo) {\n        return Promise.all(bulkGetInfo.docs.map(function (doc) {\n          var remoteDoc = doc.ok;\n\n          if (doc.error) {\n            // when AUTO_COMPACTION is set, docs can be returned which look\n            // like this: {\"missing\":\"1-7c3ac256b693c462af8442f992b83696\"}\n            ok = false;\n          }\n\n          if (!remoteDoc || !remoteDoc._attachments) {\n            return remoteDoc;\n          }\n\n          return getDocAttachmentsFromTargetOrSource(target, src, remoteDoc)\n                   .then(function (attachments) {\n                           var filenames = Object.keys(remoteDoc._attachments);\n                           attachments\n                             .forEach(function (attachment, i) {\n                                        var att = remoteDoc._attachments[filenames[i]];\n                                        delete att.stub;\n                                        delete att.length;\n                                        att.data = attachment;\n                                      });\n\n                                      return remoteDoc;\n                                    });\n        }));\n      }))\n\n      .then(function (results) {\n        resultDocs = resultDocs.concat(flatten(results).filter(Boolean));\n      });\n    });\n  }\n\n  function hasAttachments(doc) {\n    return doc._attachments && Object.keys(doc._attachments).length > 0;\n  }\n\n  function hasConflicts(doc) {\n    return doc._conflicts && doc._conflicts.length > 0;\n  }\n\n  function fetchRevisionOneDocs(ids) {\n    // Optimization: fetch gen-1 docs and attachments in\n    // a single request using _all_docs\n    return src.allDocs({\n      keys: ids,\n      include_docs: true,\n      conflicts: true\n    }).then(function (res) {\n      if (state.cancelled) {\n        throw new Error('cancelled');\n      }\n      res.rows.forEach(function (row) {\n        if (row.deleted || !row.doc || !isGenOne(row.value.rev) ||\n            hasAttachments(row.doc) || hasConflicts(row.doc)) {\n          // if any of these conditions apply, we need to fetch using get()\n          return;\n        }\n\n        // strip _conflicts array to appease CSG (#5793)\n        /* istanbul ignore if */\n        if (row.doc._conflicts) {\n          delete row.doc._conflicts;\n        }\n\n        // the doc we got back from allDocs() is sufficient\n        resultDocs.push(row.doc);\n        delete diffs[row.id];\n      });\n    });\n  }\n\n  function getRevisionOneDocs() {\n    // filter out the generation 1 docs and get them\n    // leaving the non-generation one docs to be got otherwise\n    var ids = Object.keys(diffs).filter(function (id) {\n      var missing = diffs[id].missing;\n      return missing.length === 1 && isGenOne(missing[0]);\n    });\n    if (ids.length > 0) {\n      return fetchRevisionOneDocs(ids);\n    }\n  }\n\n  function returnResult() {\n    return { ok:ok, docs:resultDocs };\n  }\n\n  return Promise.resolve()\n    .then(getRevisionOneDocs)\n    .then(getAllDocs)\n    .then(returnResult);\n}\n\nvar STARTING_BACK_OFF = 0;\n\nfunction backOff(opts, returnValue, error, callback) {\n  if (opts.retry === false) {\n    returnValue.emit('error', error);\n    returnValue.removeAllListeners();\n    return;\n  }\n  /* istanbul ignore if */\n  if (typeof opts.back_off_function !== 'function') {\n    opts.back_off_function = defaultBackOff;\n  }\n  returnValue.emit('requestError', error);\n  if (returnValue.state === 'active' || returnValue.state === 'pending') {\n    returnValue.emit('paused', error);\n    returnValue.state = 'stopped';\n    var backOffSet = function backoffTimeSet() {\n      opts.current_back_off = STARTING_BACK_OFF;\n    };\n    var removeBackOffSetter = function removeBackOffTimeSet() {\n      returnValue.removeListener('active', backOffSet);\n    };\n    returnValue.once('paused', removeBackOffSetter);\n    returnValue.once('active', backOffSet);\n  }\n\n  opts.current_back_off = opts.current_back_off || STARTING_BACK_OFF;\n  opts.current_back_off = opts.back_off_function(opts.current_back_off);\n  setTimeout(callback, opts.current_back_off);\n}\n\nfunction replicate(src, target, opts, returnValue, result) {\n  var batches = [];               // list of batches to be processed\n  var currentBatch;               // the batch currently being processed\n  var pendingBatch = {\n    seq: 0,\n    changes: [],\n    docs: []\n  }; // next batch, not yet ready to be processed\n  var writingCheckpoint = false;  // true while checkpoint is being written\n  var changesCompleted = false;   // true when all changes received\n  var replicationCompleted = false; // true when replication has completed\n  var last_seq = 0;\n  var continuous = opts.continuous || opts.live || false;\n  var batch_size = opts.batch_size || 100;\n  var batches_limit = opts.batches_limit || 10;\n  var changesPending = false;     // true while src.changes is running\n  var doc_ids = opts.doc_ids;\n  var selector = opts.selector;\n  var repId;\n  var checkpointer;\n  var changedDocs = [];\n  // Like couchdb, every replication gets a unique session id\n  var session = uuid();\n\n  result = result || {\n    ok: true,\n    start_time: new Date().toISOString(),\n    docs_read: 0,\n    docs_written: 0,\n    doc_write_failures: 0,\n    errors: []\n  };\n\n  var changesOpts = {};\n  returnValue.ready(src, target);\n\n  function initCheckpointer() {\n    if (checkpointer) {\n      return Promise.resolve();\n    }\n    return generateReplicationId(src, target, opts).then(function (res) {\n      repId = res;\n\n      var checkpointOpts = {};\n      if (opts.checkpoint === false) {\n        checkpointOpts = { writeSourceCheckpoint: false, writeTargetCheckpoint: false };\n      } else if (opts.checkpoint === 'source') {\n        checkpointOpts = { writeSourceCheckpoint: true, writeTargetCheckpoint: false };\n      } else if (opts.checkpoint === 'target') {\n        checkpointOpts = { writeSourceCheckpoint: false, writeTargetCheckpoint: true };\n      } else {\n        checkpointOpts = { writeSourceCheckpoint: true, writeTargetCheckpoint: true };\n      }\n\n      checkpointer = new Checkpointer(src, target, repId, returnValue, checkpointOpts);\n    });\n  }\n\n  function writeDocs() {\n    changedDocs = [];\n\n    if (currentBatch.docs.length === 0) {\n      return;\n    }\n    var docs = currentBatch.docs;\n    var bulkOpts = {timeout: opts.timeout};\n    return target.bulkDocs({docs: docs, new_edits: false}, bulkOpts).then(function (res) {\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        throw new Error('cancelled');\n      }\n\n      // `res` doesn't include full documents (which live in `docs`), so we create a map of \n      // (id -> error), and check for errors while iterating over `docs`\n      var errorsById = Object.create(null);\n      res.forEach(function (res) {\n        if (res.error) {\n          errorsById[res.id] = res;\n        }\n      });\n\n      var errorsNo = Object.keys(errorsById).length;\n      result.doc_write_failures += errorsNo;\n      result.docs_written += docs.length - errorsNo;\n\n      docs.forEach(function (doc) {\n        var error = errorsById[doc._id];\n        if (error) {\n          result.errors.push(error);\n          // Normalize error name. i.e. 'Unauthorized' -> 'unauthorized' (eg Sync Gateway)\n          var errorName = (error.name || '').toLowerCase();\n          if (errorName === 'unauthorized' || errorName === 'forbidden') {\n            returnValue.emit('denied', clone(error));\n          } else {\n            throw error;\n          }\n        } else {\n          changedDocs.push(doc);\n        }\n      });\n\n    }, function (err) {\n      result.doc_write_failures += docs.length;\n      throw err;\n    });\n  }\n\n  function finishBatch() {\n    if (currentBatch.error) {\n      throw new Error('There was a problem getting docs.');\n    }\n    result.last_seq = last_seq = currentBatch.seq;\n    var outResult = clone(result);\n    if (changedDocs.length) {\n      outResult.docs = changedDocs;\n      // Attach 'pending' property if server supports it (CouchDB 2.0+)\n      /* istanbul ignore if */\n      if (typeof currentBatch.pending === 'number') {\n        outResult.pending = currentBatch.pending;\n        delete currentBatch.pending;\n      }\n      returnValue.emit('change', outResult);\n    }\n    writingCheckpoint = true;\n    return checkpointer.writeCheckpoint(currentBatch.seq,\n        session).then(function () {\n      writingCheckpoint = false;\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        throw new Error('cancelled');\n      }\n      currentBatch = undefined;\n      getChanges();\n    }).catch(function (err) {\n      onCheckpointError(err);\n      throw err;\n    });\n  }\n\n  function getDiffs() {\n    var diff = {};\n    currentBatch.changes.forEach(function (change) {\n      // Couchbase Sync Gateway emits these, but we can ignore them\n      /* istanbul ignore if */\n      if (change.id === \"_user/\") {\n        return;\n      }\n      diff[change.id] = change.changes.map(function (x) {\n        return x.rev;\n      });\n    });\n    return target.revsDiff(diff).then(function (diffs) {\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        throw new Error('cancelled');\n      }\n      // currentBatch.diffs elements are deleted as the documents are written\n      currentBatch.diffs = diffs;\n    });\n  }\n\n  function getBatchDocs() {\n    return getDocs(src, target, currentBatch.diffs, returnValue).then(function (got) {\n      currentBatch.error = !got.ok;\n      got.docs.forEach(function (doc) {\n        delete currentBatch.diffs[doc._id];\n        result.docs_read++;\n        currentBatch.docs.push(doc);\n      });\n    });\n  }\n\n  function startNextBatch() {\n    if (returnValue.cancelled || currentBatch) {\n      return;\n    }\n    if (batches.length === 0) {\n      processPendingBatch(true);\n      return;\n    }\n    currentBatch = batches.shift();\n    getDiffs()\n      .then(getBatchDocs)\n      .then(writeDocs)\n      .then(finishBatch)\n      .then(startNextBatch)\n      .catch(function (err) {\n        abortReplication('batch processing terminated with error', err);\n      });\n  }\n\n\n  function processPendingBatch(immediate) {\n    if (pendingBatch.changes.length === 0) {\n      if (batches.length === 0 && !currentBatch) {\n        if ((continuous && changesOpts.live) || changesCompleted) {\n          returnValue.state = 'pending';\n          returnValue.emit('paused');\n        }\n        if (changesCompleted) {\n          completeReplication();\n        }\n      }\n      return;\n    }\n    if (\n      immediate ||\n      changesCompleted ||\n      pendingBatch.changes.length >= batch_size\n    ) {\n      batches.push(pendingBatch);\n      pendingBatch = {\n        seq: 0,\n        changes: [],\n        docs: []\n      };\n      if (returnValue.state === 'pending' || returnValue.state === 'stopped') {\n        returnValue.state = 'active';\n        returnValue.emit('active');\n      }\n      startNextBatch();\n    }\n  }\n\n\n  function abortReplication(reason, err) {\n    if (replicationCompleted) {\n      return;\n    }\n    if (!err.message) {\n      err.message = reason;\n    }\n    result.ok = false;\n    result.status = 'aborting';\n    batches = [];\n    pendingBatch = {\n      seq: 0,\n      changes: [],\n      docs: []\n    };\n    completeReplication(err);\n  }\n\n\n  function completeReplication(fatalError) {\n    if (replicationCompleted) {\n      return;\n    }\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      result.status = 'cancelled';\n      if (writingCheckpoint) {\n        return;\n      }\n    }\n    result.status = result.status || 'complete';\n    result.end_time = new Date().toISOString();\n    result.last_seq = last_seq;\n    replicationCompleted = true;\n\n    if (fatalError) {\n      // need to extend the error because Firefox considers \".result\" read-only\n      fatalError = createError(fatalError);\n      fatalError.result = result;\n\n      // Normalize error name. i.e. 'Unauthorized' -> 'unauthorized' (eg Sync Gateway)\n      var errorName = (fatalError.name || '').toLowerCase();\n      if (errorName === 'unauthorized' || errorName === 'forbidden') {\n        returnValue.emit('error', fatalError);\n        returnValue.removeAllListeners();\n      } else {\n        backOff(opts, returnValue, fatalError, function () {\n          replicate(src, target, opts, returnValue);\n        });\n      }\n    } else {\n      returnValue.emit('complete', result);\n      returnValue.removeAllListeners();\n    }\n  }\n\n\n  function onChange(change, pending, lastSeq) {\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      return completeReplication();\n    }\n    // Attach 'pending' property if server supports it (CouchDB 2.0+)\n    /* istanbul ignore if */\n    if (typeof pending === 'number') {\n      pendingBatch.pending = pending;\n    }\n\n    var filter = filterChange(opts)(change);\n    if (!filter) {\n      return;\n    }\n    pendingBatch.seq = change.seq || lastSeq;\n    pendingBatch.changes.push(change);\n    nextTick(function () {\n      processPendingBatch(batches.length === 0 && changesOpts.live);\n    });\n  }\n\n\n  function onChangesComplete(changes) {\n    changesPending = false;\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      return completeReplication();\n    }\n\n    // if no results were returned then we're done,\n    // else fetch more\n    if (changes.results.length > 0) {\n      changesOpts.since = changes.results[changes.results.length - 1].seq;\n      getChanges();\n      processPendingBatch(true);\n    } else {\n\n      var complete = function () {\n        if (continuous) {\n          changesOpts.live = true;\n          getChanges();\n        } else {\n          changesCompleted = true;\n        }\n        processPendingBatch(true);\n      };\n\n      // update the checkpoint so we start from the right seq next time\n      if (!currentBatch && changes.results.length === 0) {\n        writingCheckpoint = true;\n        checkpointer.writeCheckpoint(changes.last_seq,\n            session).then(function () {\n          writingCheckpoint = false;\n          result.last_seq = last_seq = changes.last_seq;\n          complete();\n        })\n        .catch(onCheckpointError);\n      } else {\n        complete();\n      }\n    }\n  }\n\n\n  function onChangesError(err) {\n    changesPending = false;\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      return completeReplication();\n    }\n    abortReplication('changes rejected', err);\n  }\n\n\n  function getChanges() {\n    if (!(\n      !changesPending &&\n      !changesCompleted &&\n      batches.length < batches_limit\n      )) {\n      return;\n    }\n    changesPending = true;\n    function abortChanges() {\n      changes.cancel();\n    }\n    function removeListener() {\n      returnValue.removeListener('cancel', abortChanges);\n    }\n\n    if (returnValue._changes) { // remove old changes() and listeners\n      returnValue.removeListener('cancel', returnValue._abortChanges);\n      returnValue._changes.cancel();\n    }\n    returnValue.once('cancel', abortChanges);\n\n    var changes = src.changes(changesOpts)\n      .on('change', onChange);\n    changes.then(removeListener, removeListener);\n    changes.then(onChangesComplete)\n      .catch(onChangesError);\n\n    if (opts.retry) {\n      // save for later so we can cancel if necessary\n      returnValue._changes = changes;\n      returnValue._abortChanges = abortChanges;\n    }\n  }\n\n\n  function startChanges() {\n    initCheckpointer().then(function () {\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        return;\n      }\n      return checkpointer.getCheckpoint().then(function (checkpoint) {\n        last_seq = checkpoint;\n        changesOpts = {\n          since: last_seq,\n          limit: batch_size,\n          batch_size: batch_size,\n          style: 'all_docs',\n          doc_ids: doc_ids,\n          selector: selector,\n          return_docs: true // required so we know when we're done\n        };\n        if (opts.filter) {\n          if (typeof opts.filter !== 'string') {\n            // required for the client-side filter in onChange\n            changesOpts.include_docs = true;\n          } else { // ddoc filter\n            changesOpts.filter = opts.filter;\n          }\n        }\n        if ('heartbeat' in opts) {\n          changesOpts.heartbeat = opts.heartbeat;\n        }\n        if ('timeout' in opts) {\n          changesOpts.timeout = opts.timeout;\n        }\n        if (opts.query_params) {\n          changesOpts.query_params = opts.query_params;\n        }\n        if (opts.view) {\n          changesOpts.view = opts.view;\n        }\n        getChanges();\n      });\n    }).catch(function (err) {\n      abortReplication('getCheckpoint rejected with ', err);\n    });\n  }\n\n  /* istanbul ignore next */\n  function onCheckpointError(err) {\n    writingCheckpoint = false;\n    abortReplication('writeCheckpoint completed with error', err);\n  }\n\n  /* istanbul ignore if */\n  if (returnValue.cancelled) { // cancelled immediately\n    completeReplication();\n    return;\n  }\n\n  if (!returnValue._addedListeners) {\n    returnValue.once('cancel', completeReplication);\n\n    if (typeof opts.complete === 'function') {\n      returnValue.once('error', opts.complete);\n      returnValue.once('complete', function (result) {\n        opts.complete(null, result);\n      });\n    }\n    returnValue._addedListeners = true;\n  }\n\n  if (typeof opts.since === 'undefined') {\n    startChanges();\n  } else {\n    initCheckpointer().then(function () {\n      writingCheckpoint = true;\n      return checkpointer.writeCheckpoint(opts.since, session);\n    }).then(function () {\n      writingCheckpoint = false;\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        return;\n      }\n      last_seq = opts.since;\n      startChanges();\n    }).catch(onCheckpointError);\n  }\n}\n\n// We create a basic promise so the caller can cancel the replication possibly\n// before we have actually started listening to changes etc\ninherits(Replication, EventEmitter);\nfunction Replication() {\n  EventEmitter.call(this);\n  this.cancelled = false;\n  this.state = 'pending';\n  var self = this;\n  var promise = new Promise(function (fulfill, reject) {\n    self.once('complete', fulfill);\n    self.once('error', reject);\n  });\n  self.then = function (resolve, reject) {\n    return promise.then(resolve, reject);\n  };\n  self.catch = function (reject) {\n    return promise.catch(reject);\n  };\n  // As we allow error handling via \"error\" event as well,\n  // put a stub in here so that rejecting never throws UnhandledError.\n  self.catch(function () {});\n}\n\nReplication.prototype.cancel = function () {\n  this.cancelled = true;\n  this.state = 'cancelled';\n  this.emit('cancel');\n};\n\nReplication.prototype.ready = function (src, target) {\n  var self = this;\n  if (self._readyCalled) {\n    return;\n  }\n  self._readyCalled = true;\n\n  function onDestroy() {\n    self.cancel();\n  }\n  src.once('destroyed', onDestroy);\n  target.once('destroyed', onDestroy);\n  function cleanup() {\n    src.removeListener('destroyed', onDestroy);\n    target.removeListener('destroyed', onDestroy);\n  }\n  self.once('complete', cleanup);\n};\n\nfunction toPouch(db, opts) {\n  var PouchConstructor = opts.PouchConstructor;\n  if (typeof db === 'string') {\n    return new PouchConstructor(db, opts);\n  } else {\n    return db;\n  }\n}\n\nfunction replicateWrapper(src, target, opts, callback) {\n\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  if (typeof opts === 'undefined') {\n    opts = {};\n  }\n\n  if (opts.doc_ids && !Array.isArray(opts.doc_ids)) {\n    throw createError(BAD_REQUEST,\n                       \"`doc_ids` filter parameter is not a list.\");\n  }\n\n  opts.complete = callback;\n  opts = clone(opts);\n  opts.continuous = opts.continuous || opts.live;\n  opts.retry = ('retry' in opts) ? opts.retry : false;\n  /*jshint validthis:true */\n  opts.PouchConstructor = opts.PouchConstructor || this;\n  var replicateRet = new Replication(opts);\n  var srcPouch = toPouch(src, opts);\n  var targetPouch = toPouch(target, opts);\n  replicate(srcPouch, targetPouch, opts, replicateRet);\n  return replicateRet;\n}\n\ninherits(Sync, EventEmitter);\nfunction sync(src, target, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  if (typeof opts === 'undefined') {\n    opts = {};\n  }\n  opts = clone(opts);\n  /*jshint validthis:true */\n  opts.PouchConstructor = opts.PouchConstructor || this;\n  src = toPouch(src, opts);\n  target = toPouch(target, opts);\n  return new Sync(src, target, opts, callback);\n}\n\nfunction Sync(src, target, opts, callback) {\n  var self = this;\n  this.canceled = false;\n\n  var optsPush = opts.push ? assign({}, opts, opts.push) : opts;\n  var optsPull = opts.pull ? assign({}, opts, opts.pull) : opts;\n\n  this.push = replicateWrapper(src, target, optsPush);\n  this.pull = replicateWrapper(target, src, optsPull);\n\n  this.pushPaused = true;\n  this.pullPaused = true;\n\n  function pullChange(change) {\n    self.emit('change', {\n      direction: 'pull',\n      change: change\n    });\n  }\n  function pushChange(change) {\n    self.emit('change', {\n      direction: 'push',\n      change: change\n    });\n  }\n  function pushDenied(doc) {\n    self.emit('denied', {\n      direction: 'push',\n      doc: doc\n    });\n  }\n  function pullDenied(doc) {\n    self.emit('denied', {\n      direction: 'pull',\n      doc: doc\n    });\n  }\n  function pushPaused() {\n    self.pushPaused = true;\n    /* istanbul ignore if */\n    if (self.pullPaused) {\n      self.emit('paused');\n    }\n  }\n  function pullPaused() {\n    self.pullPaused = true;\n    /* istanbul ignore if */\n    if (self.pushPaused) {\n      self.emit('paused');\n    }\n  }\n  function pushActive() {\n    self.pushPaused = false;\n    /* istanbul ignore if */\n    if (self.pullPaused) {\n      self.emit('active', {\n        direction: 'push'\n      });\n    }\n  }\n  function pullActive() {\n    self.pullPaused = false;\n    /* istanbul ignore if */\n    if (self.pushPaused) {\n      self.emit('active', {\n        direction: 'pull'\n      });\n    }\n  }\n\n  var removed = {};\n\n  function removeAll(type) { // type is 'push' or 'pull'\n    return function (event, func) {\n      var isChange = event === 'change' &&\n        (func === pullChange || func === pushChange);\n      var isDenied = event === 'denied' &&\n        (func === pullDenied || func === pushDenied);\n      var isPaused = event === 'paused' &&\n        (func === pullPaused || func === pushPaused);\n      var isActive = event === 'active' &&\n        (func === pullActive || func === pushActive);\n\n      if (isChange || isDenied || isPaused || isActive) {\n        if (!(event in removed)) {\n          removed[event] = {};\n        }\n        removed[event][type] = true;\n        if (Object.keys(removed[event]).length === 2) {\n          // both push and pull have asked to be removed\n          self.removeAllListeners(event);\n        }\n      }\n    };\n  }\n\n  if (opts.live) {\n    this.push.on('complete', self.pull.cancel.bind(self.pull));\n    this.pull.on('complete', self.push.cancel.bind(self.push));\n  }\n\n  function addOneListener(ee, event, listener) {\n    if (ee.listeners(event).indexOf(listener) == -1) {\n      ee.on(event, listener);\n    }\n  }\n\n  this.on('newListener', function (event) {\n    if (event === 'change') {\n      addOneListener(self.pull, 'change', pullChange);\n      addOneListener(self.push, 'change', pushChange);\n    } else if (event === 'denied') {\n      addOneListener(self.pull, 'denied', pullDenied);\n      addOneListener(self.push, 'denied', pushDenied);\n    } else if (event === 'active') {\n      addOneListener(self.pull, 'active', pullActive);\n      addOneListener(self.push, 'active', pushActive);\n    } else if (event === 'paused') {\n      addOneListener(self.pull, 'paused', pullPaused);\n      addOneListener(self.push, 'paused', pushPaused);\n    }\n  });\n\n  this.on('removeListener', function (event) {\n    if (event === 'change') {\n      self.pull.removeListener('change', pullChange);\n      self.push.removeListener('change', pushChange);\n    } else if (event === 'denied') {\n      self.pull.removeListener('denied', pullDenied);\n      self.push.removeListener('denied', pushDenied);\n    } else if (event === 'active') {\n      self.pull.removeListener('active', pullActive);\n      self.push.removeListener('active', pushActive);\n    } else if (event === 'paused') {\n      self.pull.removeListener('paused', pullPaused);\n      self.push.removeListener('paused', pushPaused);\n    }\n  });\n\n  this.pull.on('removeListener', removeAll('pull'));\n  this.push.on('removeListener', removeAll('push'));\n\n  var promise = Promise.all([\n    this.push,\n    this.pull\n  ]).then(function (resp) {\n    var out = {\n      push: resp[0],\n      pull: resp[1]\n    };\n    self.emit('complete', out);\n    if (callback) {\n      callback(null, out);\n    }\n    self.removeAllListeners();\n    return out;\n  }, function (err) {\n    self.cancel();\n    if (callback) {\n      // if there's a callback, then the callback can receive\n      // the error event\n      callback(err);\n    } else {\n      // if there's no callback, then we're safe to emit an error\n      // event, which would otherwise throw an unhandled error\n      // due to 'error' being a special event in EventEmitters\n      self.emit('error', err);\n    }\n    self.removeAllListeners();\n    if (callback) {\n      // no sense throwing if we're already emitting an 'error' event\n      throw err;\n    }\n  });\n\n  this.then = function (success, err) {\n    return promise.then(success, err);\n  };\n\n  this.catch = function (err) {\n    return promise.catch(err);\n  };\n}\n\nSync.prototype.cancel = function () {\n  if (!this.canceled) {\n    this.canceled = true;\n    this.push.cancel();\n    this.pull.cancel();\n  }\n};\n\nfunction replication(PouchDB) {\n  PouchDB.replicate = replicateWrapper;\n  PouchDB.sync = sync;\n\n  Object.defineProperty(PouchDB.prototype, 'replicate', {\n    get: function () {\n      var self = this;\n      if (typeof this.replicateMethods === 'undefined') {\n        this.replicateMethods = {\n          from: function (other, opts, callback) {\n            return self.constructor.replicate(other, self, opts, callback);\n          },\n          to: function (other, opts, callback) {\n            return self.constructor.replicate(self, other, opts, callback);\n          }\n        };\n      }\n      return this.replicateMethods;\n    }\n  });\n\n  PouchDB.prototype.sync = function (dbName, opts, callback) {\n    return this.constructor.sync(this, dbName, opts, callback);\n  };\n}\n\nexport default replication;\n"]},"metadata":{},"sourceType":"module"}
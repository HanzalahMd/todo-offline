{"ast":null,"code":"import { assign, uuid, rev, invalidIdError, normalizeDdocFunctionName, parseDdocFunctionName } from 'pouchdb-utils';\nexport { invalidIdError, normalizeDdocFunctionName, parseDdocFunctionName } from 'pouchdb-utils';\nimport { atob, btoa, binaryStringToBlobOrBuffer, blobOrBufferToBinaryString, blobOrBufferToBase64 } from 'pouchdb-binary-utils';\nimport { binaryMd5 } from 'pouchdb-md5';\nimport { Map } from 'pouchdb-collections';\nimport { DOC_VALIDATION, INVALID_REV, createError, BAD_ARG, REV_CONFLICT, MISSING_DOC } from 'pouchdb-errors';\nimport { isDeleted, merge, winningRev, revExists, isLocalId } from 'pouchdb-merge';\nexport { isDeleted, isLocalId } from 'pouchdb-merge';\n\nfunction allDocsKeysQuery(api, opts) {\n  var keys = opts.keys;\n  var finalResults = {\n    offset: opts.skip\n  };\n  return Promise.all(keys.map(function (key) {\n    var subOpts = assign({\n      key: key,\n      deleted: 'ok'\n    }, opts);\n    ['limit', 'skip', 'keys'].forEach(function (optKey) {\n      delete subOpts[optKey];\n    });\n    return new Promise(function (resolve, reject) {\n      api._allDocs(subOpts, function (err, res) {\n        /* istanbul ignore if */\n        if (err) {\n          return reject(err);\n        }\n        /* istanbul ignore if */\n\n\n        if (opts.update_seq && res.update_seq !== undefined) {\n          finalResults.update_seq = res.update_seq;\n        }\n\n        finalResults.total_rows = res.total_rows;\n        resolve(res.rows[0] || {\n          key: key,\n          error: 'not_found'\n        });\n      });\n    });\n  })).then(function (results) {\n    finalResults.rows = results;\n    return finalResults;\n  });\n}\n\nfunction toObject(array) {\n  return array.reduce(function (obj, item) {\n    obj[item] = true;\n    return obj;\n  }, {});\n} // List of top level reserved words for doc\n\n\nvar reservedWords = toObject(['_id', '_rev', '_attachments', '_deleted', '_revisions', '_revs_info', '_conflicts', '_deleted_conflicts', '_local_seq', '_rev_tree', //replication documents\n'_replication_id', '_replication_state', '_replication_state_time', '_replication_state_reason', '_replication_stats', // Specific to Couchbase Sync Gateway\n'_removed']); // List of reserved words that should end up the document\n\nvar dataWords = toObject(['_attachments', //replication documents\n'_replication_id', '_replication_state', '_replication_state_time', '_replication_state_reason', '_replication_stats']);\n\nfunction parseRevisionInfo(rev$$1) {\n  if (!/^\\d+-/.test(rev$$1)) {\n    return createError(INVALID_REV);\n  }\n\n  var idx = rev$$1.indexOf('-');\n  var left = rev$$1.substring(0, idx);\n  var right = rev$$1.substring(idx + 1);\n  return {\n    prefix: parseInt(left, 10),\n    id: right\n  };\n}\n\nfunction makeRevTreeFromRevisions(revisions, opts) {\n  var pos = revisions.start - revisions.ids.length + 1;\n  var revisionIds = revisions.ids;\n  var ids = [revisionIds[0], opts, []];\n\n  for (var i = 1, len = revisionIds.length; i < len; i++) {\n    ids = [revisionIds[i], {\n      status: 'missing'\n    }, [ids]];\n  }\n\n  return [{\n    pos: pos,\n    ids: ids\n  }];\n} // Preprocess documents, parse their revisions, assign an id and a\n// revision for new writes that are missing them, etc\n\n\nfunction parseDoc(doc, newEdits, dbOpts) {\n  if (!dbOpts) {\n    dbOpts = {\n      deterministic_revs: true\n    };\n  }\n\n  var nRevNum;\n  var newRevId;\n  var revInfo;\n  var opts = {\n    status: 'available'\n  };\n\n  if (doc._deleted) {\n    opts.deleted = true;\n  }\n\n  if (newEdits) {\n    if (!doc._id) {\n      doc._id = uuid();\n    }\n\n    newRevId = rev(doc, dbOpts.deterministic_revs);\n\n    if (doc._rev) {\n      revInfo = parseRevisionInfo(doc._rev);\n\n      if (revInfo.error) {\n        return revInfo;\n      }\n\n      doc._rev_tree = [{\n        pos: revInfo.prefix,\n        ids: [revInfo.id, {\n          status: 'missing'\n        }, [[newRevId, opts, []]]]\n      }];\n      nRevNum = revInfo.prefix + 1;\n    } else {\n      doc._rev_tree = [{\n        pos: 1,\n        ids: [newRevId, opts, []]\n      }];\n      nRevNum = 1;\n    }\n  } else {\n    if (doc._revisions) {\n      doc._rev_tree = makeRevTreeFromRevisions(doc._revisions, opts);\n      nRevNum = doc._revisions.start;\n      newRevId = doc._revisions.ids[0];\n    }\n\n    if (!doc._rev_tree) {\n      revInfo = parseRevisionInfo(doc._rev);\n\n      if (revInfo.error) {\n        return revInfo;\n      }\n\n      nRevNum = revInfo.prefix;\n      newRevId = revInfo.id;\n      doc._rev_tree = [{\n        pos: nRevNum,\n        ids: [newRevId, opts, []]\n      }];\n    }\n  }\n\n  invalidIdError(doc._id);\n  doc._rev = nRevNum + '-' + newRevId;\n  var result = {\n    metadata: {},\n    data: {}\n  };\n\n  for (var key in doc) {\n    /* istanbul ignore else */\n    if (Object.prototype.hasOwnProperty.call(doc, key)) {\n      var specialKey = key[0] === '_';\n\n      if (specialKey && !reservedWords[key]) {\n        var error = createError(DOC_VALIDATION, key);\n        error.message = DOC_VALIDATION.message + ': ' + key;\n        throw error;\n      } else if (specialKey && !dataWords[key]) {\n        result.metadata[key.slice(1)] = doc[key];\n      } else {\n        result.data[key] = doc[key];\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction parseBase64(data) {\n  try {\n    return atob(data);\n  } catch (e) {\n    var err = createError(BAD_ARG, 'Attachment is not a valid base64 string');\n    return {\n      error: err\n    };\n  }\n}\n\nfunction preprocessString(att, blobType, callback) {\n  var asBinary = parseBase64(att.data);\n\n  if (asBinary.error) {\n    return callback(asBinary.error);\n  }\n\n  att.length = asBinary.length;\n\n  if (blobType === 'blob') {\n    att.data = binaryStringToBlobOrBuffer(asBinary, att.content_type);\n  } else if (blobType === 'base64') {\n    att.data = btoa(asBinary);\n  } else {\n    // binary\n    att.data = asBinary;\n  }\n\n  binaryMd5(asBinary, function (result) {\n    att.digest = 'md5-' + result;\n    callback();\n  });\n}\n\nfunction preprocessBlob(att, blobType, callback) {\n  binaryMd5(att.data, function (md5) {\n    att.digest = 'md5-' + md5; // size is for blobs (browser), length is for buffers (node)\n\n    att.length = att.data.size || att.data.length || 0;\n\n    if (blobType === 'binary') {\n      blobOrBufferToBinaryString(att.data, function (binString) {\n        att.data = binString;\n        callback();\n      });\n    } else if (blobType === 'base64') {\n      blobOrBufferToBase64(att.data, function (b64) {\n        att.data = b64;\n        callback();\n      });\n    } else {\n      callback();\n    }\n  });\n}\n\nfunction preprocessAttachment(att, blobType, callback) {\n  if (att.stub) {\n    return callback();\n  }\n\n  if (typeof att.data === 'string') {\n    // input is a base64 string\n    preprocessString(att, blobType, callback);\n  } else {\n    // input is a blob\n    preprocessBlob(att, blobType, callback);\n  }\n}\n\nfunction preprocessAttachments(docInfos, blobType, callback) {\n  if (!docInfos.length) {\n    return callback();\n  }\n\n  var docv = 0;\n  var overallErr;\n  docInfos.forEach(function (docInfo) {\n    var attachments = docInfo.data && docInfo.data._attachments ? Object.keys(docInfo.data._attachments) : [];\n    var recv = 0;\n\n    if (!attachments.length) {\n      return done();\n    }\n\n    function processedAttachment(err) {\n      overallErr = err;\n      recv++;\n\n      if (recv === attachments.length) {\n        done();\n      }\n    }\n\n    for (var key in docInfo.data._attachments) {\n      if (docInfo.data._attachments.hasOwnProperty(key)) {\n        preprocessAttachment(docInfo.data._attachments[key], blobType, processedAttachment);\n      }\n    }\n  });\n\n  function done() {\n    docv++;\n\n    if (docInfos.length === docv) {\n      if (overallErr) {\n        callback(overallErr);\n      } else {\n        callback();\n      }\n    }\n  }\n}\n\nfunction updateDoc(revLimit, prev, docInfo, results, i, cb, writeDoc, newEdits) {\n  if (revExists(prev.rev_tree, docInfo.metadata.rev) && !newEdits) {\n    results[i] = docInfo;\n    return cb();\n  } // sometimes this is pre-calculated. historically not always\n\n\n  var previousWinningRev = prev.winningRev || winningRev(prev);\n  var previouslyDeleted = 'deleted' in prev ? prev.deleted : isDeleted(prev, previousWinningRev);\n  var deleted = 'deleted' in docInfo.metadata ? docInfo.metadata.deleted : isDeleted(docInfo.metadata);\n  var isRoot = /^1-/.test(docInfo.metadata.rev);\n\n  if (previouslyDeleted && !deleted && newEdits && isRoot) {\n    var newDoc = docInfo.data;\n    newDoc._rev = previousWinningRev;\n    newDoc._id = docInfo.metadata.id;\n    docInfo = parseDoc(newDoc, newEdits);\n  }\n\n  var merged = merge(prev.rev_tree, docInfo.metadata.rev_tree[0], revLimit);\n  var inConflict = newEdits && (previouslyDeleted && deleted && merged.conflicts !== 'new_leaf' || !previouslyDeleted && merged.conflicts !== 'new_leaf' || previouslyDeleted && !deleted && merged.conflicts === 'new_branch');\n\n  if (inConflict) {\n    var err = createError(REV_CONFLICT);\n    results[i] = err;\n    return cb();\n  }\n\n  var newRev = docInfo.metadata.rev;\n  docInfo.metadata.rev_tree = merged.tree;\n  docInfo.stemmedRevs = merged.stemmedRevs || [];\n  /* istanbul ignore else */\n\n  if (prev.rev_map) {\n    docInfo.metadata.rev_map = prev.rev_map; // used only by leveldb\n  } // recalculate\n\n\n  var winningRev$$1 = winningRev(docInfo.metadata);\n  var winningRevIsDeleted = isDeleted(docInfo.metadata, winningRev$$1); // calculate the total number of documents that were added/removed,\n  // from the perspective of total_rows/doc_count\n\n  var delta = previouslyDeleted === winningRevIsDeleted ? 0 : previouslyDeleted < winningRevIsDeleted ? -1 : 1;\n  var newRevIsDeleted;\n\n  if (newRev === winningRev$$1) {\n    // if the new rev is the same as the winning rev, we can reuse that value\n    newRevIsDeleted = winningRevIsDeleted;\n  } else {\n    // if they're not the same, then we need to recalculate\n    newRevIsDeleted = isDeleted(docInfo.metadata, newRev);\n  }\n\n  writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted, true, delta, i, cb);\n}\n\nfunction rootIsMissing(docInfo) {\n  return docInfo.metadata.rev_tree[0].ids[1].status === 'missing';\n}\n\nfunction processDocs(revLimit, docInfos, api, fetchedDocs, tx, results, writeDoc, opts, overallCallback) {\n  // Default to 1000 locally\n  revLimit = revLimit || 1000;\n\n  function insertDoc(docInfo, resultsIdx, callback) {\n    // Cant insert new deleted documents\n    var winningRev$$1 = winningRev(docInfo.metadata);\n    var deleted = isDeleted(docInfo.metadata, winningRev$$1);\n\n    if ('was_delete' in opts && deleted) {\n      results[resultsIdx] = createError(MISSING_DOC, 'deleted');\n      return callback();\n    } // 4712 - detect whether a new document was inserted with a _rev\n\n\n    var inConflict = newEdits && rootIsMissing(docInfo);\n\n    if (inConflict) {\n      var err = createError(REV_CONFLICT);\n      results[resultsIdx] = err;\n      return callback();\n    }\n\n    var delta = deleted ? 0 : 1;\n    writeDoc(docInfo, winningRev$$1, deleted, deleted, false, delta, resultsIdx, callback);\n  }\n\n  var newEdits = opts.new_edits;\n  var idsToDocs = new Map();\n  var docsDone = 0;\n  var docsToDo = docInfos.length;\n\n  function checkAllDocsDone() {\n    if (++docsDone === docsToDo && overallCallback) {\n      overallCallback();\n    }\n  }\n\n  docInfos.forEach(function (currentDoc, resultsIdx) {\n    if (currentDoc._id && isLocalId(currentDoc._id)) {\n      var fun = currentDoc._deleted ? '_removeLocal' : '_putLocal';\n      api[fun](currentDoc, {\n        ctx: tx\n      }, function (err, res) {\n        results[resultsIdx] = err || res;\n        checkAllDocsDone();\n      });\n      return;\n    }\n\n    var id = currentDoc.metadata.id;\n\n    if (idsToDocs.has(id)) {\n      docsToDo--; // duplicate\n\n      idsToDocs.get(id).push([currentDoc, resultsIdx]);\n    } else {\n      idsToDocs.set(id, [[currentDoc, resultsIdx]]);\n    }\n  }); // in the case of new_edits, the user can provide multiple docs\n  // with the same id. these need to be processed sequentially\n\n  idsToDocs.forEach(function (docs, id) {\n    var numDone = 0;\n\n    function docWritten() {\n      if (++numDone < docs.length) {\n        nextDoc();\n      } else {\n        checkAllDocsDone();\n      }\n    }\n\n    function nextDoc() {\n      var value = docs[numDone];\n      var currentDoc = value[0];\n      var resultsIdx = value[1];\n\n      if (fetchedDocs.has(id)) {\n        updateDoc(revLimit, fetchedDocs.get(id), currentDoc, results, resultsIdx, docWritten, writeDoc, newEdits);\n      } else {\n        // Ensure stemming applies to new writes as well\n        var merged = merge([], currentDoc.metadata.rev_tree[0], revLimit);\n        currentDoc.metadata.rev_tree = merged.tree;\n        currentDoc.stemmedRevs = merged.stemmedRevs || [];\n        insertDoc(currentDoc, resultsIdx, docWritten);\n      }\n    }\n\n    nextDoc();\n  });\n}\n\nexport { allDocsKeysQuery, parseDoc, preprocessAttachments, processDocs, updateDoc };","map":{"version":3,"sources":["/Users/Hanzalah/Desktop/github/todo-offline/rxdb-hasura-demo/node_modules/pouchdb-adapter-utils/lib/index.es.js"],"names":["assign","uuid","rev","invalidIdError","normalizeDdocFunctionName","parseDdocFunctionName","atob","btoa","binaryStringToBlobOrBuffer","blobOrBufferToBinaryString","blobOrBufferToBase64","binaryMd5","Map","DOC_VALIDATION","INVALID_REV","createError","BAD_ARG","REV_CONFLICT","MISSING_DOC","isDeleted","merge","winningRev","revExists","isLocalId","allDocsKeysQuery","api","opts","keys","finalResults","offset","skip","Promise","all","map","key","subOpts","deleted","forEach","optKey","resolve","reject","_allDocs","err","res","update_seq","undefined","total_rows","rows","error","then","results","toObject","array","reduce","obj","item","reservedWords","dataWords","parseRevisionInfo","rev$$1","test","idx","indexOf","left","substring","right","prefix","parseInt","id","makeRevTreeFromRevisions","revisions","pos","start","ids","length","revisionIds","i","len","status","parseDoc","doc","newEdits","dbOpts","deterministic_revs","nRevNum","newRevId","revInfo","_deleted","_id","_rev","_rev_tree","_revisions","result","metadata","data","Object","prototype","hasOwnProperty","call","specialKey","message","slice","parseBase64","e","preprocessString","att","blobType","callback","asBinary","content_type","digest","preprocessBlob","md5","size","binString","b64","preprocessAttachment","stub","preprocessAttachments","docInfos","docv","overallErr","docInfo","attachments","_attachments","recv","done","processedAttachment","updateDoc","revLimit","prev","cb","writeDoc","rev_tree","previousWinningRev","previouslyDeleted","isRoot","newDoc","merged","inConflict","conflicts","newRev","tree","stemmedRevs","rev_map","winningRev$$1","winningRevIsDeleted","delta","newRevIsDeleted","rootIsMissing","processDocs","fetchedDocs","tx","overallCallback","insertDoc","resultsIdx","new_edits","idsToDocs","docsDone","docsToDo","checkAllDocsDone","currentDoc","fun","ctx","has","get","push","set","docs","numDone","docWritten","nextDoc","value"],"mappings":"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","sourcesContent":["import { assign, uuid, rev, invalidIdError, normalizeDdocFunctionName, parseDdocFunctionName } from 'pouchdb-utils';\nexport { invalidIdError, normalizeDdocFunctionName, parseDdocFunctionName } from 'pouchdb-utils';\nimport { atob, btoa, binaryStringToBlobOrBuffer, blobOrBufferToBinaryString, blobOrBufferToBase64 } from 'pouchdb-binary-utils';\nimport { binaryMd5 } from 'pouchdb-md5';\nimport { Map } from 'pouchdb-collections';\nimport { DOC_VALIDATION, INVALID_REV, createError, BAD_ARG, REV_CONFLICT, MISSING_DOC } from 'pouchdb-errors';\nimport { isDeleted, merge, winningRev, revExists, isLocalId } from 'pouchdb-merge';\nexport { isDeleted, isLocalId } from 'pouchdb-merge';\n\nfunction allDocsKeysQuery(api, opts) {\n  var keys = opts.keys;\n  var finalResults = {\n    offset: opts.skip\n  };\n  return Promise.all(keys.map(function (key) {\n    var subOpts = assign({key: key, deleted: 'ok'}, opts);\n    ['limit', 'skip', 'keys'].forEach(function (optKey) {\n      delete subOpts[optKey];\n    });\n    return new Promise(function (resolve, reject) {\n      api._allDocs(subOpts, function (err, res) {\n        /* istanbul ignore if */\n        if (err) {\n          return reject(err);\n        }\n        /* istanbul ignore if */\n        if (opts.update_seq && res.update_seq !== undefined) {\n          finalResults.update_seq = res.update_seq;\n        }\n        finalResults.total_rows = res.total_rows;\n        resolve(res.rows[0] || {key: key, error: 'not_found'});\n      });\n    });\n  })).then(function (results) {\n    finalResults.rows = results;\n    return finalResults;\n  });\n}\n\nfunction toObject(array) {\n  return array.reduce(function (obj, item) {\n    obj[item] = true;\n    return obj;\n  }, {});\n}\n// List of top level reserved words for doc\nvar reservedWords = toObject([\n  '_id',\n  '_rev',\n  '_attachments',\n  '_deleted',\n  '_revisions',\n  '_revs_info',\n  '_conflicts',\n  '_deleted_conflicts',\n  '_local_seq',\n  '_rev_tree',\n  //replication documents\n  '_replication_id',\n  '_replication_state',\n  '_replication_state_time',\n  '_replication_state_reason',\n  '_replication_stats',\n  // Specific to Couchbase Sync Gateway\n  '_removed'\n]);\n\n// List of reserved words that should end up the document\nvar dataWords = toObject([\n  '_attachments',\n  //replication documents\n  '_replication_id',\n  '_replication_state',\n  '_replication_state_time',\n  '_replication_state_reason',\n  '_replication_stats'\n]);\n\nfunction parseRevisionInfo(rev$$1) {\n  if (!/^\\d+-/.test(rev$$1)) {\n    return createError(INVALID_REV);\n  }\n  var idx = rev$$1.indexOf('-');\n  var left = rev$$1.substring(0, idx);\n  var right = rev$$1.substring(idx + 1);\n  return {\n    prefix: parseInt(left, 10),\n    id: right\n  };\n}\n\nfunction makeRevTreeFromRevisions(revisions, opts) {\n  var pos = revisions.start - revisions.ids.length + 1;\n\n  var revisionIds = revisions.ids;\n  var ids = [revisionIds[0], opts, []];\n\n  for (var i = 1, len = revisionIds.length; i < len; i++) {\n    ids = [revisionIds[i], {status: 'missing'}, [ids]];\n  }\n\n  return [{\n    pos: pos,\n    ids: ids\n  }];\n}\n\n// Preprocess documents, parse their revisions, assign an id and a\n// revision for new writes that are missing them, etc\nfunction parseDoc(doc, newEdits, dbOpts) {\n  if (!dbOpts) {\n    dbOpts = {\n      deterministic_revs: true\n    };\n  }\n\n  var nRevNum;\n  var newRevId;\n  var revInfo;\n  var opts = {status: 'available'};\n  if (doc._deleted) {\n    opts.deleted = true;\n  }\n\n  if (newEdits) {\n    if (!doc._id) {\n      doc._id = uuid();\n    }\n    newRevId = rev(doc, dbOpts.deterministic_revs);\n    if (doc._rev) {\n      revInfo = parseRevisionInfo(doc._rev);\n      if (revInfo.error) {\n        return revInfo;\n      }\n      doc._rev_tree = [{\n        pos: revInfo.prefix,\n        ids: [revInfo.id, {status: 'missing'}, [[newRevId, opts, []]]]\n      }];\n      nRevNum = revInfo.prefix + 1;\n    } else {\n      doc._rev_tree = [{\n        pos: 1,\n        ids : [newRevId, opts, []]\n      }];\n      nRevNum = 1;\n    }\n  } else {\n    if (doc._revisions) {\n      doc._rev_tree = makeRevTreeFromRevisions(doc._revisions, opts);\n      nRevNum = doc._revisions.start;\n      newRevId = doc._revisions.ids[0];\n    }\n    if (!doc._rev_tree) {\n      revInfo = parseRevisionInfo(doc._rev);\n      if (revInfo.error) {\n        return revInfo;\n      }\n      nRevNum = revInfo.prefix;\n      newRevId = revInfo.id;\n      doc._rev_tree = [{\n        pos: nRevNum,\n        ids: [newRevId, opts, []]\n      }];\n    }\n  }\n\n  invalidIdError(doc._id);\n\n  doc._rev = nRevNum + '-' + newRevId;\n\n  var result = {metadata : {}, data : {}};\n  for (var key in doc) {\n    /* istanbul ignore else */\n    if (Object.prototype.hasOwnProperty.call(doc, key)) {\n      var specialKey = key[0] === '_';\n      if (specialKey && !reservedWords[key]) {\n        var error = createError(DOC_VALIDATION, key);\n        error.message = DOC_VALIDATION.message + ': ' + key;\n        throw error;\n      } else if (specialKey && !dataWords[key]) {\n        result.metadata[key.slice(1)] = doc[key];\n      } else {\n        result.data[key] = doc[key];\n      }\n    }\n  }\n  return result;\n}\n\nfunction parseBase64(data) {\n  try {\n    return atob(data);\n  } catch (e) {\n    var err = createError(BAD_ARG,\n      'Attachment is not a valid base64 string');\n    return {error: err};\n  }\n}\n\nfunction preprocessString(att, blobType, callback) {\n  var asBinary = parseBase64(att.data);\n  if (asBinary.error) {\n    return callback(asBinary.error);\n  }\n\n  att.length = asBinary.length;\n  if (blobType === 'blob') {\n    att.data = binaryStringToBlobOrBuffer(asBinary, att.content_type);\n  } else if (blobType === 'base64') {\n    att.data = btoa(asBinary);\n  } else { // binary\n    att.data = asBinary;\n  }\n  binaryMd5(asBinary, function (result) {\n    att.digest = 'md5-' + result;\n    callback();\n  });\n}\n\nfunction preprocessBlob(att, blobType, callback) {\n  binaryMd5(att.data, function (md5) {\n    att.digest = 'md5-' + md5;\n    // size is for blobs (browser), length is for buffers (node)\n    att.length = att.data.size || att.data.length || 0;\n    if (blobType === 'binary') {\n      blobOrBufferToBinaryString(att.data, function (binString) {\n        att.data = binString;\n        callback();\n      });\n    } else if (blobType === 'base64') {\n      blobOrBufferToBase64(att.data, function (b64) {\n        att.data = b64;\n        callback();\n      });\n    } else {\n      callback();\n    }\n  });\n}\n\nfunction preprocessAttachment(att, blobType, callback) {\n  if (att.stub) {\n    return callback();\n  }\n  if (typeof att.data === 'string') { // input is a base64 string\n    preprocessString(att, blobType, callback);\n  } else { // input is a blob\n    preprocessBlob(att, blobType, callback);\n  }\n}\n\nfunction preprocessAttachments(docInfos, blobType, callback) {\n\n  if (!docInfos.length) {\n    return callback();\n  }\n\n  var docv = 0;\n  var overallErr;\n\n  docInfos.forEach(function (docInfo) {\n    var attachments = docInfo.data && docInfo.data._attachments ?\n      Object.keys(docInfo.data._attachments) : [];\n    var recv = 0;\n\n    if (!attachments.length) {\n      return done();\n    }\n\n    function processedAttachment(err) {\n      overallErr = err;\n      recv++;\n      if (recv === attachments.length) {\n        done();\n      }\n    }\n\n    for (var key in docInfo.data._attachments) {\n      if (docInfo.data._attachments.hasOwnProperty(key)) {\n        preprocessAttachment(docInfo.data._attachments[key],\n          blobType, processedAttachment);\n      }\n    }\n  });\n\n  function done() {\n    docv++;\n    if (docInfos.length === docv) {\n      if (overallErr) {\n        callback(overallErr);\n      } else {\n        callback();\n      }\n    }\n  }\n}\n\nfunction updateDoc(revLimit, prev, docInfo, results,\n                   i, cb, writeDoc, newEdits) {\n\n  if (revExists(prev.rev_tree, docInfo.metadata.rev) && !newEdits) {\n    results[i] = docInfo;\n    return cb();\n  }\n\n  // sometimes this is pre-calculated. historically not always\n  var previousWinningRev = prev.winningRev || winningRev(prev);\n  var previouslyDeleted = 'deleted' in prev ? prev.deleted :\n    isDeleted(prev, previousWinningRev);\n  var deleted = 'deleted' in docInfo.metadata ? docInfo.metadata.deleted :\n    isDeleted(docInfo.metadata);\n  var isRoot = /^1-/.test(docInfo.metadata.rev);\n\n  if (previouslyDeleted && !deleted && newEdits && isRoot) {\n    var newDoc = docInfo.data;\n    newDoc._rev = previousWinningRev;\n    newDoc._id = docInfo.metadata.id;\n    docInfo = parseDoc(newDoc, newEdits);\n  }\n\n  var merged = merge(prev.rev_tree, docInfo.metadata.rev_tree[0], revLimit);\n\n  var inConflict = newEdits && ((\n    (previouslyDeleted && deleted && merged.conflicts !== 'new_leaf') ||\n    (!previouslyDeleted && merged.conflicts !== 'new_leaf') ||\n    (previouslyDeleted && !deleted && merged.conflicts === 'new_branch')));\n\n  if (inConflict) {\n    var err = createError(REV_CONFLICT);\n    results[i] = err;\n    return cb();\n  }\n\n  var newRev = docInfo.metadata.rev;\n  docInfo.metadata.rev_tree = merged.tree;\n  docInfo.stemmedRevs = merged.stemmedRevs || [];\n  /* istanbul ignore else */\n  if (prev.rev_map) {\n    docInfo.metadata.rev_map = prev.rev_map; // used only by leveldb\n  }\n\n  // recalculate\n  var winningRev$$1 = winningRev(docInfo.metadata);\n  var winningRevIsDeleted = isDeleted(docInfo.metadata, winningRev$$1);\n\n  // calculate the total number of documents that were added/removed,\n  // from the perspective of total_rows/doc_count\n  var delta = (previouslyDeleted === winningRevIsDeleted) ? 0 :\n    previouslyDeleted < winningRevIsDeleted ? -1 : 1;\n\n  var newRevIsDeleted;\n  if (newRev === winningRev$$1) {\n    // if the new rev is the same as the winning rev, we can reuse that value\n    newRevIsDeleted = winningRevIsDeleted;\n  } else {\n    // if they're not the same, then we need to recalculate\n    newRevIsDeleted = isDeleted(docInfo.metadata, newRev);\n  }\n\n  writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted,\n    true, delta, i, cb);\n}\n\nfunction rootIsMissing(docInfo) {\n  return docInfo.metadata.rev_tree[0].ids[1].status === 'missing';\n}\n\nfunction processDocs(revLimit, docInfos, api, fetchedDocs, tx, results,\n                     writeDoc, opts, overallCallback) {\n\n  // Default to 1000 locally\n  revLimit = revLimit || 1000;\n\n  function insertDoc(docInfo, resultsIdx, callback) {\n    // Cant insert new deleted documents\n    var winningRev$$1 = winningRev(docInfo.metadata);\n    var deleted = isDeleted(docInfo.metadata, winningRev$$1);\n    if ('was_delete' in opts && deleted) {\n      results[resultsIdx] = createError(MISSING_DOC, 'deleted');\n      return callback();\n    }\n\n    // 4712 - detect whether a new document was inserted with a _rev\n    var inConflict = newEdits && rootIsMissing(docInfo);\n\n    if (inConflict) {\n      var err = createError(REV_CONFLICT);\n      results[resultsIdx] = err;\n      return callback();\n    }\n\n    var delta = deleted ? 0 : 1;\n\n    writeDoc(docInfo, winningRev$$1, deleted, deleted, false,\n      delta, resultsIdx, callback);\n  }\n\n  var newEdits = opts.new_edits;\n  var idsToDocs = new Map();\n\n  var docsDone = 0;\n  var docsToDo = docInfos.length;\n\n  function checkAllDocsDone() {\n    if (++docsDone === docsToDo && overallCallback) {\n      overallCallback();\n    }\n  }\n\n  docInfos.forEach(function (currentDoc, resultsIdx) {\n\n    if (currentDoc._id && isLocalId(currentDoc._id)) {\n      var fun = currentDoc._deleted ? '_removeLocal' : '_putLocal';\n      api[fun](currentDoc, {ctx: tx}, function (err, res) {\n        results[resultsIdx] = err || res;\n        checkAllDocsDone();\n      });\n      return;\n    }\n\n    var id = currentDoc.metadata.id;\n    if (idsToDocs.has(id)) {\n      docsToDo--; // duplicate\n      idsToDocs.get(id).push([currentDoc, resultsIdx]);\n    } else {\n      idsToDocs.set(id, [[currentDoc, resultsIdx]]);\n    }\n  });\n\n  // in the case of new_edits, the user can provide multiple docs\n  // with the same id. these need to be processed sequentially\n  idsToDocs.forEach(function (docs, id) {\n    var numDone = 0;\n\n    function docWritten() {\n      if (++numDone < docs.length) {\n        nextDoc();\n      } else {\n        checkAllDocsDone();\n      }\n    }\n    function nextDoc() {\n      var value = docs[numDone];\n      var currentDoc = value[0];\n      var resultsIdx = value[1];\n\n      if (fetchedDocs.has(id)) {\n        updateDoc(revLimit, fetchedDocs.get(id), currentDoc, results,\n          resultsIdx, docWritten, writeDoc, newEdits);\n      } else {\n        // Ensure stemming applies to new writes as well\n        var merged = merge([], currentDoc.metadata.rev_tree[0], revLimit);\n        currentDoc.metadata.rev_tree = merged.tree;\n        currentDoc.stemmedRevs = merged.stemmedRevs || [];\n        insertDoc(currentDoc, resultsIdx, docWritten);\n      }\n    }\n    nextDoc();\n  });\n}\n\nexport { allDocsKeysQuery, parseDoc, preprocessAttachments, processDocs, updateDoc };\n"]},"metadata":{},"sourceType":"module"}